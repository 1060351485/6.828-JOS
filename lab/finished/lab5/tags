!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALLOC_ZERO	./kern/pmap.h	/^	ALLOC_ZERO = 1<<0,$/;"	e	enum:__anon2
Argstate	./inc/args.h	/^struct Argstate {$/;"	s
Argstate::argc	./inc/args.h	/^	int *argc;$/;"	m	struct:Argstate	access:public
Argstate::argv	./inc/args.h	/^	const char **argv;$/;"	m	struct:Argstate	access:public
Argstate::argvalue	./inc/args.h	/^	const char *argvalue;$/;"	m	struct:Argstate	access:public
Argstate::curarg	./inc/args.h	/^	const char *curarg;$/;"	m	struct:Argstate	access:public
BLKBITSIZE	./inc/fs.h	13;"	d
BLKFILES	./inc/fs.h	45;"	d
BLKSECTS	./fs/fs.h	5;"	d
BLKSIZE	./inc/fs.h	12;"	d
CGA_BASE	./kern/console.h	13;"	d
CGA_BUF	./kern/console.h	14;"	d
CMDBYTE	./inc/kbdreg.h	60;"	d
CPU_HALTED	./kern/cpu.h	/^	CPU_HALTED,$/;"	e	enum:__anon1
CPU_STARTED	./kern/cpu.h	/^	CPU_STARTED,$/;"	e	enum:__anon1
CPU_UNUSED	./kern/cpu.h	/^	CPU_UNUSED = 0,$/;"	e	enum:__anon1
CR0_AM	./inc/mmu.h	86;"	d
CR0_CD	./inc/mmu.h	88;"	d
CR0_EM	./inc/mmu.h	81;"	d
CR0_ET	./inc/mmu.h	83;"	d
CR0_MP	./inc/mmu.h	80;"	d
CR0_NE	./inc/mmu.h	84;"	d
CR0_NW	./inc/mmu.h	87;"	d
CR0_PE	./inc/mmu.h	79;"	d
CR0_PG	./inc/mmu.h	89;"	d
CR0_TS	./inc/mmu.h	82;"	d
CR0_WP	./inc/mmu.h	85;"	d
CR4_DE	./inc/mmu.h	94;"	d
CR4_MCE	./inc/mmu.h	92;"	d
CR4_PCE	./inc/mmu.h	91;"	d
CR4_PSE	./inc/mmu.h	93;"	d
CR4_PVI	./inc/mmu.h	96;"	d
CR4_TSD	./inc/mmu.h	95;"	d
CR4_VME	./inc/mmu.h	97;"	d
CRT_COLS	./kern/console.h	17;"	d
CRT_ROWS	./kern/console.h	16;"	d
CRT_SIZE	./kern/console.h	18;"	d
CpuInfo	./kern/cpu.h	/^struct CpuInfo {$/;"	s
CpuInfo::cpu_env	./kern/cpu.h	/^	struct Env *cpu_env;            \/\/ The currently-running environment.$/;"	m	struct:CpuInfo	typeref:struct:CpuInfo::Env	access:public
CpuInfo::cpu_id	./kern/cpu.h	/^	uint8_t cpu_id;                 \/\/ Local APIC ID; index into cpus[] below$/;"	m	struct:CpuInfo	access:public
CpuInfo::cpu_status	./kern/cpu.h	/^	volatile unsigned cpu_status;   \/\/ The status of the CPU$/;"	m	struct:CpuInfo	access:public
CpuInfo::cpu_ts	./kern/cpu.h	/^	struct Taskstate cpu_ts;        \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:CpuInfo	typeref:struct:CpuInfo::Taskstate	access:public
DEBUG_SPINLOCK	./kern/spinlock.h	7;"	d
DISKMAP	./fs/fs.h	9;"	d
DISKSIZE	./fs/fs.h	12;"	d
Dev	./inc/fd.h	/^struct Dev {$/;"	s
Dev::dev_close	./inc/fd.h	/^	int (*dev_close)(struct Fd *fd);$/;"	m	struct:Dev	access:public
Dev::dev_id	./inc/fd.h	/^	int dev_id;$/;"	m	struct:Dev	access:public
Dev::dev_name	./inc/fd.h	/^	const char *dev_name;$/;"	m	struct:Dev	access:public
Dev::dev_read	./inc/fd.h	/^	ssize_t (*dev_read)(struct Fd *fd, void *buf, size_t len);$/;"	m	struct:Dev	access:public
Dev::dev_stat	./inc/fd.h	/^	int (*dev_stat)(struct Fd *fd, struct Stat *stat);$/;"	m	struct:Dev	access:public
Dev::dev_trunc	./inc/fd.h	/^	int (*dev_trunc)(struct Fd *fd, off_t length);$/;"	m	struct:Dev	access:public
Dev::dev_write	./inc/fd.h	/^	ssize_t (*dev_write)(struct Fd *fd, const void *buf, size_t len);$/;"	m	struct:Dev	access:public
ELF_MAGIC	./inc/elf.h	4;"	d
ELF_PROG_FLAG_EXEC	./inc/elf.h	52;"	d
ELF_PROG_FLAG_READ	./inc/elf.h	54;"	d
ELF_PROG_FLAG_WRITE	./inc/elf.h	53;"	d
ELF_PROG_LOAD	./inc/elf.h	49;"	d
ELF_SHN_UNDEF	./inc/elf.h	63;"	d
ELF_SHT_NULL	./inc/elf.h	57;"	d
ELF_SHT_PROGBITS	./inc/elf.h	58;"	d
ELF_SHT_STRTAB	./inc/elf.h	60;"	d
ELF_SHT_SYMTAB	./inc/elf.h	59;"	d
ENVX	./inc/env.h	30;"	d
ENV_CREATE	./kern/env.h	29;"	d
ENV_DYING	./inc/env.h	/^	ENV_DYING,$/;"	e	enum:__anon6
ENV_FREE	./inc/env.h	/^	ENV_FREE = 0,$/;"	e	enum:__anon6
ENV_NOT_RUNNABLE	./inc/env.h	/^	ENV_NOT_RUNNABLE$/;"	e	enum:__anon6
ENV_PASTE3	./kern/env.h	27;"	d
ENV_RUNNABLE	./inc/env.h	/^	ENV_RUNNABLE,$/;"	e	enum:__anon6
ENV_RUNNING	./inc/env.h	/^	ENV_RUNNING,$/;"	e	enum:__anon6
ENV_TYPE_FS	./inc/env.h	/^	ENV_TYPE_FS,		\/\/ File system server$/;"	e	enum:EnvType
ENV_TYPE_USER	./inc/env.h	/^	ENV_TYPE_USER = 0,$/;"	e	enum:EnvType
EXTPHYSMEM	./inc/memlayout.h	93;"	d
E_BAD_ENV	./inc/error.h	/^	E_BAD_ENV	,	\/\/ Environment doesn't exist or otherwise$/;"	e	enum:__anon3
E_BAD_PATH	./inc/error.h	/^	E_BAD_PATH	,	\/\/ Bad path$/;"	e	enum:__anon3
E_EOF	./inc/error.h	/^	E_EOF		,	\/\/ Unexpected end of file$/;"	e	enum:__anon3
E_FAULT	./inc/error.h	/^	E_FAULT		,	\/\/ Memory fault$/;"	e	enum:__anon3
E_FILE_EXISTS	./inc/error.h	/^	E_FILE_EXISTS	,	\/\/ File already exists$/;"	e	enum:__anon3
E_INVAL	./inc/error.h	/^	E_INVAL		,	\/\/ Invalid parameter$/;"	e	enum:__anon3
E_IPC_NOT_RECV	./inc/error.h	/^	E_IPC_NOT_RECV	,	\/\/ Attempt to send to env that is not recving$/;"	e	enum:__anon3
E_MAX_OPEN	./inc/error.h	/^	E_MAX_OPEN	,	\/\/ Too many files are open$/;"	e	enum:__anon3
E_NOT_EXEC	./inc/error.h	/^	E_NOT_EXEC	,	\/\/ File not a valid executable$/;"	e	enum:__anon3
E_NOT_FOUND	./inc/error.h	/^	E_NOT_FOUND	, 	\/\/ File or block not found$/;"	e	enum:__anon3
E_NOT_SUPP	./inc/error.h	/^	E_NOT_SUPP	,	\/\/ Operation not supported$/;"	e	enum:__anon3
E_NO_DISK	./inc/error.h	/^	E_NO_DISK	,	\/\/ No free space left on disk$/;"	e	enum:__anon3
E_NO_FREE_ENV	./inc/error.h	/^	E_NO_FREE_ENV	,	\/\/ Attempt to create a new environment beyond$/;"	e	enum:__anon3
E_NO_MEM	./inc/error.h	/^	E_NO_MEM	,	\/\/ Request failed due to memory shortage$/;"	e	enum:__anon3
E_UNSPECIFIED	./inc/error.h	/^	E_UNSPECIFIED	= 1,	\/\/ Unspecified or unknown problem$/;"	e	enum:__anon3
Eipdebuginfo	./kern/kdebug.h	/^struct Eipdebuginfo {$/;"	s
Eipdebuginfo::eip_file	./kern/kdebug.h	/^	const char *eip_file;		\/\/ Source code filename for EIP$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_addr	./kern/kdebug.h	/^	uintptr_t eip_fn_addr;		\/\/ Address of start of function$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_name	./kern/kdebug.h	/^	const char *eip_fn_name;	\/\/ Name of function containing EIP$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_namelen	./kern/kdebug.h	/^	int eip_fn_namelen;		\/\/ Length of function name$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_fn_narg	./kern/kdebug.h	/^	int eip_fn_narg;		\/\/ Number of function arguments$/;"	m	struct:Eipdebuginfo	access:public
Eipdebuginfo::eip_line	./kern/kdebug.h	/^	int eip_line;			\/\/ Source code linenumber for EIP$/;"	m	struct:Eipdebuginfo	access:public
Elf	./inc/elf.h	/^struct Elf {$/;"	s
Elf::e_ehsize	./inc/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
Elf::e_elf	./inc/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
Elf::e_entry	./inc/elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
Elf::e_flags	./inc/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
Elf::e_machine	./inc/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
Elf::e_magic	./inc/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
Elf::e_phentsize	./inc/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
Elf::e_phnum	./inc/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
Elf::e_phoff	./inc/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
Elf::e_shentsize	./inc/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
Elf::e_shnum	./inc/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
Elf::e_shoff	./inc/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
Elf::e_shstrndx	./inc/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
Elf::e_type	./inc/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
Elf::e_version	./inc/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
Env	./inc/env.h	/^struct Env {$/;"	s
Env::env_cpunum	./inc/env.h	/^	int env_cpunum;			\/\/ The CPU that the env is running on$/;"	m	struct:Env	access:public
Env::env_id	./inc/env.h	/^	envid_t env_id;			\/\/ Unique environment identifier$/;"	m	struct:Env	access:public
Env::env_ipc_dstva	./inc/env.h	/^	void *env_ipc_dstva;		\/\/ VA at which to map received page$/;"	m	struct:Env	access:public
Env::env_ipc_from	./inc/env.h	/^	envid_t env_ipc_from;		\/\/ envid of the sender$/;"	m	struct:Env	access:public
Env::env_ipc_perm	./inc/env.h	/^	int env_ipc_perm;		\/\/ Perm of page mapping received$/;"	m	struct:Env	access:public
Env::env_ipc_recving	./inc/env.h	/^	bool env_ipc_recving;		\/\/ Env is blocked receiving$/;"	m	struct:Env	access:public
Env::env_ipc_value	./inc/env.h	/^	uint32_t env_ipc_value;		\/\/ Data value sent to us$/;"	m	struct:Env	access:public
Env::env_link	./inc/env.h	/^	struct Env *env_link;		\/\/ Next free Env$/;"	m	struct:Env	typeref:struct:Env::Env	access:public
Env::env_parent_id	./inc/env.h	/^	envid_t env_parent_id;		\/\/ env_id of this env's parent$/;"	m	struct:Env	access:public
Env::env_pgdir	./inc/env.h	/^	pde_t *env_pgdir;		\/\/ Kernel virtual address of page dir$/;"	m	struct:Env	access:public
Env::env_pgfault_upcall	./inc/env.h	/^	void *env_pgfault_upcall;	\/\/ Page fault upcall entry point$/;"	m	struct:Env	access:public
Env::env_runs	./inc/env.h	/^	uint32_t env_runs;		\/\/ Number of times environment has run$/;"	m	struct:Env	access:public
Env::env_status	./inc/env.h	/^	unsigned env_status;		\/\/ Status of the environment$/;"	m	struct:Env	access:public
Env::env_tf	./inc/env.h	/^	struct Trapframe env_tf;	\/\/ Saved registers$/;"	m	struct:Env	typeref:struct:Env::Trapframe	access:public
Env::env_type	./inc/env.h	/^	enum EnvType env_type;		\/\/ Indicates special system environments$/;"	m	struct:Env	typeref:enum:Env::EnvType	access:public
EnvType	./inc/env.h	/^enum EnvType {$/;"	g
FEC_PR	./inc/mmu.h	123;"	d
FEC_U	./inc/mmu.h	125;"	d
FEC_WR	./inc/mmu.h	124;"	d
FL_AC	./inc/mmu.h	117;"	d
FL_AF	./inc/mmu.h	102;"	d
FL_CF	./inc/mmu.h	100;"	d
FL_DF	./inc/mmu.h	107;"	d
FL_ID	./inc/mmu.h	120;"	d
FL_IF	./inc/mmu.h	106;"	d
FL_IOPL_0	./inc/mmu.h	110;"	d
FL_IOPL_1	./inc/mmu.h	111;"	d
FL_IOPL_2	./inc/mmu.h	112;"	d
FL_IOPL_3	./inc/mmu.h	113;"	d
FL_IOPL_MASK	./inc/mmu.h	109;"	d
FL_NT	./inc/mmu.h	114;"	d
FL_OF	./inc/mmu.h	108;"	d
FL_PF	./inc/mmu.h	101;"	d
FL_RF	./inc/mmu.h	115;"	d
FL_SF	./inc/mmu.h	104;"	d
FL_TF	./inc/mmu.h	105;"	d
FL_VIF	./inc/mmu.h	118;"	d
FL_VIP	./inc/mmu.h	119;"	d
FL_VM	./inc/mmu.h	116;"	d
FL_ZF	./inc/mmu.h	103;"	d
FSREQ_FLUSH	./inc/fs.h	/^	FSREQ_FLUSH,$/;"	e	enum:__anon8
FSREQ_OPEN	./inc/fs.h	/^	FSREQ_OPEN = 1,$/;"	e	enum:__anon8
FSREQ_READ	./inc/fs.h	/^	FSREQ_READ,$/;"	e	enum:__anon8
FSREQ_REMOVE	./inc/fs.h	/^	FSREQ_REMOVE,$/;"	e	enum:__anon8
FSREQ_SET_SIZE	./inc/fs.h	/^	FSREQ_SET_SIZE,$/;"	e	enum:__anon8
FSREQ_STAT	./inc/fs.h	/^	FSREQ_STAT,$/;"	e	enum:__anon8
FSREQ_SYNC	./inc/fs.h	/^	FSREQ_SYNC$/;"	e	enum:__anon8
FSREQ_WRITE	./inc/fs.h	/^	FSREQ_WRITE,$/;"	e	enum:__anon8
FS_MAGIC	./inc/fs.h	54;"	d
FTYPE_DIR	./inc/fs.h	49;"	d
FTYPE_REG	./inc/fs.h	48;"	d
Fd	./inc/fd.h	/^struct Fd {$/;"	s
Fd::__anon5::fd_file	./inc/fd.h	/^		struct FdFile fd_file;$/;"	m	union:Fd::__anon5	typeref:struct:Fd::__anon5::FdFile	access:public
Fd::fd_dev_id	./inc/fd.h	/^	int fd_dev_id;$/;"	m	struct:Fd	access:public
Fd::fd_offset	./inc/fd.h	/^	off_t fd_offset;$/;"	m	struct:Fd	access:public
Fd::fd_omode	./inc/fd.h	/^	int fd_omode;$/;"	m	struct:Fd	access:public
FdFile	./inc/fd.h	/^struct FdFile {$/;"	s
FdFile::id	./inc/fd.h	/^	int id;$/;"	m	struct:FdFile	access:public
File	./inc/fs.h	/^struct File {$/;"	s
File::f_direct	./inc/fs.h	/^	uint32_t f_direct[NDIRECT];	\/\/ direct blocks$/;"	m	struct:File	access:public
File::f_indirect	./inc/fs.h	/^	uint32_t f_indirect;		\/\/ indirect block$/;"	m	struct:File	access:public
File::f_name	./inc/fs.h	/^	char f_name[MAXNAMELEN];	\/\/ filename$/;"	m	struct:File	access:public
File::f_pad	./inc/fs.h	/^	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];$/;"	m	struct:File	access:public
File::f_size	./inc/fs.h	/^	off_t f_size;			\/\/ file size in bytes$/;"	m	struct:File	access:public
File::f_type	./inc/fs.h	/^	uint32_t f_type;		\/\/ file type$/;"	m	struct:File	access:public
Fsipc	./inc/fs.h	/^union Fsipc {$/;"	u
Fsipc::Fsreq_flush	./inc/fs.h	/^	struct Fsreq_flush {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_flush::req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_flush	access:public
Fsipc::Fsreq_open	./inc/fs.h	/^	struct Fsreq_open {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_open::req_omode	./inc/fs.h	/^		int req_omode;$/;"	m	struct:Fsipc::Fsreq_open	access:public
Fsipc::Fsreq_open::req_path	./inc/fs.h	/^		char req_path[MAXPATHLEN];$/;"	m	struct:Fsipc::Fsreq_open	access:public
Fsipc::Fsreq_read	./inc/fs.h	/^	struct Fsreq_read {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_read::req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_read	access:public
Fsipc::Fsreq_read::req_n	./inc/fs.h	/^		size_t req_n;$/;"	m	struct:Fsipc::Fsreq_read	access:public
Fsipc::Fsreq_remove	./inc/fs.h	/^	struct Fsreq_remove {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_remove::req_path	./inc/fs.h	/^		char req_path[MAXPATHLEN];$/;"	m	struct:Fsipc::Fsreq_remove	access:public
Fsipc::Fsreq_set_size	./inc/fs.h	/^	struct Fsreq_set_size {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_set_size::req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_set_size	access:public
Fsipc::Fsreq_set_size::req_size	./inc/fs.h	/^		off_t req_size;$/;"	m	struct:Fsipc::Fsreq_set_size	access:public
Fsipc::Fsreq_stat	./inc/fs.h	/^	struct Fsreq_stat {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_stat::req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_stat	access:public
Fsipc::Fsreq_write	./inc/fs.h	/^	struct Fsreq_write {$/;"	s	union:Fsipc	access:public
Fsipc::Fsreq_write::req_buf	./inc/fs.h	/^		char req_buf[PGSIZE - (sizeof(int) + sizeof(size_t))];$/;"	m	struct:Fsipc::Fsreq_write	access:public
Fsipc::Fsreq_write::req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_write	access:public
Fsipc::Fsreq_write::req_n	./inc/fs.h	/^		size_t req_n;$/;"	m	struct:Fsipc::Fsreq_write	access:public
Fsipc::Fsret_read	./inc/fs.h	/^	struct Fsret_read {$/;"	s	union:Fsipc	access:public
Fsipc::Fsret_read::ret_buf	./inc/fs.h	/^		char ret_buf[PGSIZE];$/;"	m	struct:Fsipc::Fsret_read	access:public
Fsipc::Fsret_stat	./inc/fs.h	/^	struct Fsret_stat {$/;"	s	union:Fsipc	access:public
Fsipc::Fsret_stat::ret_isdir	./inc/fs.h	/^		int ret_isdir;$/;"	m	struct:Fsipc::Fsret_stat	access:public
Fsipc::Fsret_stat::ret_name	./inc/fs.h	/^		char ret_name[MAXNAMELEN];$/;"	m	struct:Fsipc::Fsret_stat	access:public
Fsipc::Fsret_stat::ret_size	./inc/fs.h	/^		off_t ret_size;$/;"	m	struct:Fsipc::Fsret_stat	access:public
Fsipc::_pad	./inc/fs.h	/^	char _pad[PGSIZE];$/;"	m	union:Fsipc	access:public
Fsipc::flush	./inc/fs.h	/^	} flush;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_flush	access:public
Fsipc::open	./inc/fs.h	/^	} open;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_open	access:public
Fsipc::read	./inc/fs.h	/^	} read;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_read	access:public
Fsipc::readRet	./inc/fs.h	/^	} readRet;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsret_read	access:public
Fsipc::remove	./inc/fs.h	/^	} remove;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_remove	access:public
Fsipc::set_size	./inc/fs.h	/^	} set_size;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_set_size	access:public
Fsipc::stat	./inc/fs.h	/^	} stat;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_stat	access:public
Fsipc::statRet	./inc/fs.h	/^	} statRet;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsret_stat	access:public
Fsipc::write	./inc/fs.h	/^	} write;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_write	access:public
Fsreq_flush	./inc/fs.h	/^	struct Fsreq_flush {$/;"	s	union:Fsipc	access:public
Fsreq_open	./inc/fs.h	/^	struct Fsreq_open {$/;"	s	union:Fsipc	access:public
Fsreq_read	./inc/fs.h	/^	struct Fsreq_read {$/;"	s	union:Fsipc	access:public
Fsreq_remove	./inc/fs.h	/^	struct Fsreq_remove {$/;"	s	union:Fsipc	access:public
Fsreq_set_size	./inc/fs.h	/^	struct Fsreq_set_size {$/;"	s	union:Fsipc	access:public
Fsreq_stat	./inc/fs.h	/^	struct Fsreq_stat {$/;"	s	union:Fsipc	access:public
Fsreq_write	./inc/fs.h	/^	struct Fsreq_write {$/;"	s	union:Fsipc	access:public
Fsret_read	./inc/fs.h	/^	struct Fsret_read {$/;"	s	union:Fsipc	access:public
Fsret_stat	./inc/fs.h	/^	struct Fsret_stat {$/;"	s	union:Fsipc	access:public
GD_KD	./inc/memlayout.h	16;"	d
GD_KT	./inc/memlayout.h	15;"	d
GD_TSS0	./inc/memlayout.h	19;"	d
GD_UD	./inc/memlayout.h	18;"	d
GD_UT	./inc/memlayout.h	17;"	d
Gatedesc	./inc/mmu.h	/^struct Gatedesc {$/;"	s
Gatedesc::gd_args	./inc/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_dpl	./inc/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_15_0	./inc/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_off_31_16	./inc/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_p	./inc/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_rsv1	./inc/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_s	./inc/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_sel	./inc/mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
Gatedesc::gd_type	./inc/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
IOPHYSMEM	./inc/memlayout.h	92;"	d
IO_PIC1	./kern/picirq.h	12;"	d
IO_PIC2	./kern/picirq.h	13;"	d
IO_RTC	./kern/kclock.h	9;"	d
IRQ_ERROR	./inc/trap.h	40;"	d
IRQ_IDE	./inc/trap.h	39;"	d
IRQ_KBD	./inc/trap.h	36;"	d
IRQ_OFFSET	./inc/trap.h	32;"	d
IRQ_SERIAL	./inc/trap.h	37;"	d
IRQ_SLAVE	./kern/picirq.h	15;"	d
IRQ_SPURIOUS	./inc/trap.h	38;"	d
IRQ_TIMER	./inc/trap.h	35;"	d
JOS_INC_ARGS_H	./inc/args.h	2;"	d
JOS_INC_ASSERT_H	./inc/assert.h	4;"	d
JOS_INC_CPU_H	./kern/cpu.h	3;"	d
JOS_INC_ELF_H	./inc/elf.h	2;"	d
JOS_INC_ENV_H	./inc/env.h	4;"	d
JOS_INC_ERROR_H	./inc/error.h	4;"	d
JOS_INC_FD_H	./inc/fd.h	6;"	d
JOS_INC_FS_H	./inc/fs.h	4;"	d
JOS_INC_LIB_H	./inc/lib.h	8;"	d
JOS_INC_MEMLAYOUT_H	./inc/memlayout.h	2;"	d
JOS_INC_MMU_H	./inc/mmu.h	2;"	d
JOS_INC_PARTITION_H	./inc/partition.h	2;"	d
JOS_INC_SPINLOCK_H	./kern/spinlock.h	2;"	d
JOS_INC_STDARG_H	./inc/stdarg.h	4;"	d
JOS_INC_STDIO_H	./inc/stdio.h	2;"	d
JOS_INC_STRING_H	./inc/string.h	2;"	d
JOS_INC_SYSCALL_H	./inc/syscall.h	2;"	d
JOS_INC_TRAP_H	./inc/trap.h	2;"	d
JOS_INC_TYPES_H	./inc/types.h	2;"	d
JOS_INC_X86_H	./inc/x86.h	2;"	d
JOS_KBDREG_H	./inc/kbdreg.h	2;"	d
JOS_KERN_ENV_H	./kern/env.h	4;"	d
JOS_KERN_KCLOCK_H	./kern/kclock.h	4;"	d
JOS_KERN_KDEBUG_H	./kern/kdebug.h	2;"	d
JOS_KERN_MONITOR_H	./kern/monitor.h	2;"	d
JOS_KERN_PICIRQ_H	./kern/picirq.h	4;"	d
JOS_KERN_PMAP_H	./kern/pmap.h	4;"	d
JOS_KERN_SCHED_H	./kern/sched.h	4;"	d
JOS_KERN_SYSCALL_H	./kern/syscall.h	2;"	d
JOS_KERN_TRAP_H	./kern/trap.h	4;"	d
JOS_STAB_H	./inc/stab.h	2;"	d
KADDR	./kern/pmap.h	38;"	d
KBCMDP	./inc/kbdreg.h	29;"	d
KBC_AUXDISABLE	./inc/kbdreg.h	32;"	d
KBC_AUXECHO	./inc/kbdreg.h	36;"	d
KBC_AUXENABLE	./inc/kbdreg.h	33;"	d
KBC_AUXTEST	./inc/kbdreg.h	34;"	d
KBC_AUXWRITE	./inc/kbdreg.h	37;"	d
KBC_DISABLE	./inc/kbdreg.h	66;"	d
KBC_ECHO	./inc/kbdreg.h	71;"	d
KBC_ENABLE	./inc/kbdreg.h	67;"	d
KBC_KBDDISABLE	./inc/kbdreg.h	40;"	d
KBC_KBDECHO	./inc/kbdreg.h	35;"	d
KBC_KBDENABLE	./inc/kbdreg.h	41;"	d
KBC_KBDTEST	./inc/kbdreg.h	39;"	d
KBC_MODEIND	./inc/kbdreg.h	70;"	d
KBC_PULSE0	./inc/kbdreg.h	42;"	d
KBC_PULSE1	./inc/kbdreg.h	43;"	d
KBC_PULSE2	./inc/kbdreg.h	44;"	d
KBC_PULSE3	./inc/kbdreg.h	45;"	d
KBC_RAMREAD	./inc/kbdreg.h	30;"	d
KBC_RAMWRITE	./inc/kbdreg.h	31;"	d
KBC_RESEND	./inc/kbdreg.h	64;"	d
KBC_RESET	./inc/kbdreg.h	63;"	d
KBC_SELFTEST	./inc/kbdreg.h	38;"	d
KBC_SETDEFAULT	./inc/kbdreg.h	65;"	d
KBC_SETTABLE	./inc/kbdreg.h	69;"	d
KBC_TYPEMATIC	./inc/kbdreg.h	68;"	d
KBDATAP	./inc/kbdreg.h	47;"	d
KBOUTP	./inc/kbdreg.h	48;"	d
KBR_ACK	./inc/kbdreg.h	76;"	d
KBR_BREAK	./inc/kbdreg.h	79;"	d
KBR_ECHO	./inc/kbdreg.h	81;"	d
KBR_EXTENDED	./inc/kbdreg.h	74;"	d
KBR_FAILURE	./inc/kbdreg.h	78;"	d
KBR_OVERRUN	./inc/kbdreg.h	77;"	d
KBR_RESEND	./inc/kbdreg.h	75;"	d
KBR_RSTDONE	./inc/kbdreg.h	80;"	d
KBSTATP	./inc/kbdreg.h	19;"	d
KBS_DIB	./inc/kbdreg.h	20;"	d
KBS_IBF	./inc/kbdreg.h	21;"	d
KBS_NOSEC	./inc/kbdreg.h	24;"	d
KBS_OCMD	./inc/kbdreg.h	23;"	d
KBS_PERR	./inc/kbdreg.h	27;"	d
KBS_RERR	./inc/kbdreg.h	26;"	d
KBS_TERR	./inc/kbdreg.h	25;"	d
KBS_WARM	./inc/kbdreg.h	22;"	d
KC8_CPU	./inc/kbdreg.h	57;"	d
KC8_IGNSEC	./inc/kbdreg.h	56;"	d
KC8_KDISABLE	./inc/kbdreg.h	55;"	d
KC8_KENABLE	./inc/kbdreg.h	59;"	d
KC8_MDISABLE	./inc/kbdreg.h	54;"	d
KC8_MENABLE	./inc/kbdreg.h	58;"	d
KC8_TRANS	./inc/kbdreg.h	53;"	d
KERNBASE	./inc/memlayout.h	87;"	d
KEY_DEL	./inc/kbdreg.h	14;"	d
KEY_DN	./inc/kbdreg.h	8;"	d
KEY_END	./inc/kbdreg.h	6;"	d
KEY_HOME	./inc/kbdreg.h	5;"	d
KEY_INS	./inc/kbdreg.h	13;"	d
KEY_LF	./inc/kbdreg.h	9;"	d
KEY_PGDN	./inc/kbdreg.h	12;"	d
KEY_PGUP	./inc/kbdreg.h	11;"	d
KEY_RT	./inc/kbdreg.h	10;"	d
KEY_UP	./inc/kbdreg.h	7;"	d
KSTACKTOP	./inc/memlayout.h	96;"	d
KSTKGAP	./inc/memlayout.h	98;"	d
KSTKSIZE	./inc/memlayout.h	97;"	d
K_LDCMDBYTE	./inc/kbdreg.h	51;"	d
K_RDCMDBYTE	./inc/kbdreg.h	50;"	d
LOG2NENV	./inc/env.h	28;"	d
MAX	./inc/types.h	49;"	d
MAXERROR	./inc/error.h	/^	MAXERROR$/;"	e	enum:__anon3
MAXFILESIZE	./inc/fs.h	27;"	d
MAXNAMELEN	./inc/fs.h	17;"	d
MAXPATHLEN	./inc/fs.h	20;"	d
MAX_IRQS	./kern/picirq.h	9;"	d
MC_NVRAM_SIZE	./kern/kclock.h	12;"	d
MC_NVRAM_START	./kern/kclock.h	11;"	d
MIN	./inc/types.h	43;"	d
MMIOBASE	./inc/memlayout.h	102;"	d
MMIOLIM	./inc/memlayout.h	101;"	d
MONO_BASE	./kern/console.h	11;"	d
MONO_BUF	./kern/console.h	12;"	d
MPENTRY_PADDR	./inc/memlayout.h	142;"	d
NCPU	./kern/cpu.h	11;"	d
NDIRECT	./inc/fs.h	23;"	d
NENV	./inc/env.h	29;"	d
NINDIRECT	./inc/fs.h	25;"	d
NPDENTRIES	./inc/mmu.h	45;"	d
NPTENTRIES	./inc/mmu.h	46;"	d
NSYSCALLS	./inc/syscall.h	/^	NSYSCALLS$/;"	e	enum:__anon7
NULL	./inc/stdio.h	7;"	d
NULL	./inc/types.h	5;"	d
NVRAM_BASEHI	./kern/kclock.h	16;"	d
NVRAM_BASELO	./kern/kclock.h	15;"	d
NVRAM_CENTURY	./kern/kclock.h	27;"	d
NVRAM_EXTHI	./kern/kclock.h	20;"	d
NVRAM_EXTLO	./kern/kclock.h	19;"	d
NVRAM_PEXTHI	./kern/kclock.h	24;"	d
NVRAM_PEXTLO	./kern/kclock.h	23;"	d
N_BCOMM	./inc/stab.h	37;"	d
N_BINCL	./inc/stab.h	29;"	d
N_BSLINE	./inc/stab.h	25;"	d
N_DSLINE	./inc/stab.h	24;"	d
N_ECOML	./inc/stab.h	39;"	d
N_ECOMM	./inc/stab.h	38;"	d
N_EINCL	./inc/stab.h	32;"	d
N_ENTRY	./inc/stab.h	33;"	d
N_EXCL	./inc/stab.h	35;"	d
N_FNAME	./inc/stab.h	16;"	d
N_FUN	./inc/stab.h	17;"	d
N_GSYM	./inc/stab.h	15;"	d
N_LBRAC	./inc/stab.h	34;"	d
N_LCSYM	./inc/stab.h	19;"	d
N_LENG	./inc/stab.h	40;"	d
N_LSYM	./inc/stab.h	28;"	d
N_MAIN	./inc/stab.h	20;"	d
N_PC	./inc/stab.h	21;"	d
N_PSYM	./inc/stab.h	31;"	d
N_RBRAC	./inc/stab.h	36;"	d
N_RSYM	./inc/stab.h	22;"	d
N_SLINE	./inc/stab.h	23;"	d
N_SO	./inc/stab.h	27;"	d
N_SOL	./inc/stab.h	30;"	d
N_SSYM	./inc/stab.h	26;"	d
N_STSYM	./inc/stab.h	18;"	d
O_ACCMODE	./inc/lib.h	126;"	d
O_CREAT	./inc/lib.h	128;"	d
O_EXCL	./inc/lib.h	130;"	d
O_MKDIR	./inc/lib.h	131;"	d
O_RDONLY	./inc/lib.h	123;"	d
O_RDWR	./inc/lib.h	125;"	d
O_TRUNC	./inc/lib.h	129;"	d
O_WRONLY	./inc/lib.h	124;"	d
PADDR	./kern/pmap.h	26;"	d
PDX	./inc/mmu.h	33;"	d
PDXSHIFT	./inc/mmu.h	55;"	d
PFTEMP	./inc/memlayout.h	137;"	d
PGADDR	./inc/mmu.h	42;"	d
PGNUM	./inc/mmu.h	30;"	d
PGOFF	./inc/mmu.h	39;"	d
PGSHIFT	./inc/mmu.h	49;"	d
PGSIZE	./inc/mmu.h	48;"	d
PTABLE_MAGIC	./inc/partition.h	14;"	d
PTABLE_MAGIC_OFFSET	./inc/partition.h	13;"	d
PTABLE_OFFSET	./inc/partition.h	11;"	d
PTE_A	./inc/mmu.h	63;"	d
PTE_ADDR	./inc/mmu.h	76;"	d
PTE_AVAIL	./inc/mmu.h	70;"	d
PTE_D	./inc/mmu.h	64;"	d
PTE_G	./inc/mmu.h	66;"	d
PTE_P	./inc/mmu.h	58;"	d
PTE_PCD	./inc/mmu.h	62;"	d
PTE_PS	./inc/mmu.h	65;"	d
PTE_PWT	./inc/mmu.h	61;"	d
PTE_SHARE	./inc/lib.h	80;"	d
PTE_SYSCALL	./inc/mmu.h	73;"	d
PTE_U	./inc/mmu.h	60;"	d
PTE_W	./inc/mmu.h	59;"	d
PTSHIFT	./inc/mmu.h	52;"	d
PTSIZE	./inc/mmu.h	51;"	d
PTX	./inc/mmu.h	36;"	d
PTXSHIFT	./inc/mmu.h	54;"	d
PTYPE_DOS_EXTENDED	./inc/partition.h	20;"	d
PTYPE_JOSFS	./inc/partition.h	18;"	d
PTYPE_JOS_KERN	./inc/partition.h	17;"	d
PTYPE_LINUX_EXTENDED	./inc/partition.h	22;"	d
PTYPE_W95_EXTENDED	./inc/partition.h	21;"	d
PageInfo	./inc/memlayout.h	/^struct PageInfo {$/;"	s
PageInfo::pp_link	./inc/memlayout.h	/^	struct PageInfo *pp_link;$/;"	m	struct:PageInfo	typeref:struct:PageInfo::PageInfo	access:public
PageInfo::pp_ref	./inc/memlayout.h	/^	uint16_t pp_ref;$/;"	m	struct:PageInfo	access:public
Partitiondesc	./inc/partition.h	/^struct Partitiondesc {$/;"	s
Partitiondesc::boot	./inc/partition.h	/^	uint8_t boot;$/;"	m	struct:Partitiondesc	access:public
Partitiondesc::chs_begin	./inc/partition.h	/^	uint8_t chs_begin[3];$/;"	m	struct:Partitiondesc	access:public
Partitiondesc::chs_end	./inc/partition.h	/^	uint8_t chs_end[3];$/;"	m	struct:Partitiondesc	access:public
Partitiondesc::lba_length	./inc/partition.h	/^	uint32_t lba_length;$/;"	m	struct:Partitiondesc	access:public
Partitiondesc::lba_start	./inc/partition.h	/^	uint32_t lba_start;$/;"	m	struct:Partitiondesc	access:public
Partitiondesc::type	./inc/partition.h	/^	uint8_t type;$/;"	m	struct:Partitiondesc	access:public
Proghdr	./inc/elf.h	/^struct Proghdr {$/;"	s
Proghdr::p_align	./inc/elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
Proghdr::p_filesz	./inc/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_flags	./inc/elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
Proghdr::p_memsz	./inc/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
Proghdr::p_offset	./inc/elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
Proghdr::p_pa	./inc/elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
Proghdr::p_type	./inc/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
Proghdr::p_va	./inc/elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
Pseudodesc	./inc/mmu.h	/^struct Pseudodesc {$/;"	s
Pseudodesc::pd_base	./inc/mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
Pseudodesc::pd_lim	./inc/mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
PushRegs	./inc/trap.h	/^struct PushRegs {$/;"	s
PushRegs::reg_eax	./inc/trap.h	/^	uint32_t reg_eax;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_ebp	./inc/trap.h	/^	uint32_t reg_ebp;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_ebx	./inc/trap.h	/^	uint32_t reg_ebx;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_ecx	./inc/trap.h	/^	uint32_t reg_ecx;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_edi	./inc/trap.h	/^	uint32_t reg_edi;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_edx	./inc/trap.h	/^	uint32_t reg_edx;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_esi	./inc/trap.h	/^	uint32_t reg_esi;$/;"	m	struct:PushRegs	access:public
PushRegs::reg_oesp	./inc/trap.h	/^	uint32_t reg_oesp;		\/* Useless *\/$/;"	m	struct:PushRegs	access:public
ROUNDDOWN	./inc/types.h	58;"	d
ROUNDUP	./inc/types.h	64;"	d
SECTSIZE	./fs/fs.h	4;"	d
SEG	./inc/mmu.h	142;"	d
SEG	./inc/mmu.h	172;"	d
SEG16	./inc/mmu.h	176;"	d
SEG_FAULT	./inc/mmu.h	170;"	d
SEG_NULL	./inc/mmu.h	139;"	d
SEG_NULL	./inc/mmu.h	168;"	d
SETCALLGATE	./inc/mmu.h	296;"	d
SETGATE	./inc/mmu.h	282;"	d
STA_A	./inc/mmu.h	189;"	d
STA_C	./inc/mmu.h	186;"	d
STA_E	./inc/mmu.h	185;"	d
STA_R	./inc/mmu.h	188;"	d
STA_W	./inc/mmu.h	187;"	d
STA_X	./inc/mmu.h	184;"	d
STS_CG16	./inc/mmu.h	195;"	d
STS_CG32	./inc/mmu.h	201;"	d
STS_IG16	./inc/mmu.h	197;"	d
STS_IG32	./inc/mmu.h	202;"	d
STS_LDT	./inc/mmu.h	193;"	d
STS_T16A	./inc/mmu.h	192;"	d
STS_T16B	./inc/mmu.h	194;"	d
STS_T32A	./inc/mmu.h	199;"	d
STS_T32B	./inc/mmu.h	200;"	d
STS_TG	./inc/mmu.h	196;"	d
STS_TG16	./inc/mmu.h	198;"	d
STS_TG32	./inc/mmu.h	203;"	d
SYS_cgetc	./inc/syscall.h	/^	SYS_cgetc,$/;"	e	enum:__anon7
SYS_cputs	./inc/syscall.h	/^	SYS_cputs = 0,$/;"	e	enum:__anon7
SYS_env_destroy	./inc/syscall.h	/^	SYS_env_destroy,$/;"	e	enum:__anon7
SYS_env_set_pgfault_upcall	./inc/syscall.h	/^	SYS_env_set_pgfault_upcall,$/;"	e	enum:__anon7
SYS_env_set_status	./inc/syscall.h	/^	SYS_env_set_status,$/;"	e	enum:__anon7
SYS_env_set_trapframe	./inc/syscall.h	/^	SYS_env_set_trapframe,$/;"	e	enum:__anon7
SYS_exofork	./inc/syscall.h	/^	SYS_exofork,$/;"	e	enum:__anon7
SYS_getenvid	./inc/syscall.h	/^	SYS_getenvid,$/;"	e	enum:__anon7
SYS_ipc_recv	./inc/syscall.h	/^	SYS_ipc_recv,$/;"	e	enum:__anon7
SYS_ipc_try_send	./inc/syscall.h	/^	SYS_ipc_try_send,$/;"	e	enum:__anon7
SYS_page_alloc	./inc/syscall.h	/^	SYS_page_alloc,$/;"	e	enum:__anon7
SYS_page_map	./inc/syscall.h	/^	SYS_page_map,$/;"	e	enum:__anon7
SYS_page_unmap	./inc/syscall.h	/^	SYS_page_unmap,$/;"	e	enum:__anon7
SYS_yield	./inc/syscall.h	/^	SYS_yield,$/;"	e	enum:__anon7
Secthdr	./inc/elf.h	/^struct Secthdr {$/;"	s
Secthdr::sh_addr	./inc/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_addralign	./inc/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_entsize	./inc/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_flags	./inc/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_info	./inc/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_link	./inc/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_name	./inc/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_offset	./inc/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_size	./inc/elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
Secthdr::sh_type	./inc/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
Segdesc	./inc/mmu.h	/^struct Segdesc {$/;"	s
Segdesc::sd_avl	./inc/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_15_0	./inc/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_23_16	./inc/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_base_31_24	./inc/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
Segdesc::sd_db	./inc/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
Segdesc::sd_dpl	./inc/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
Segdesc::sd_g	./inc/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_15_0	./inc/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_lim_19_16	./inc/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
Segdesc::sd_p	./inc/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
Segdesc::sd_rsv1	./inc/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
Segdesc::sd_s	./inc/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
Segdesc::sd_type	./inc/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
Stab	./inc/stab.h	/^struct Stab {$/;"	s
Stab::n_desc	./inc/stab.h	/^	uint16_t n_desc;        \/\/ description field$/;"	m	struct:Stab	access:public
Stab::n_other	./inc/stab.h	/^	uint8_t n_other;        \/\/ misc info (usually empty)$/;"	m	struct:Stab	access:public
Stab::n_strx	./inc/stab.h	/^	uint32_t n_strx;	\/\/ index into string table of name$/;"	m	struct:Stab	access:public
Stab::n_type	./inc/stab.h	/^	uint8_t n_type;         \/\/ type of symbol$/;"	m	struct:Stab	access:public
Stab::n_value	./inc/stab.h	/^	uintptr_t n_value;	\/\/ value of symbol$/;"	m	struct:Stab	access:public
Stat	./inc/fd.h	/^struct Stat {$/;"	s
Stat::st_dev	./inc/fd.h	/^	struct Dev *st_dev;$/;"	m	struct:Stat	typeref:struct:Stat::Dev	access:public
Stat::st_isdir	./inc/fd.h	/^	int st_isdir;$/;"	m	struct:Stat	access:public
Stat::st_name	./inc/fd.h	/^	char st_name[MAXNAMELEN];$/;"	m	struct:Stat	access:public
Stat::st_size	./inc/fd.h	/^	off_t st_size;$/;"	m	struct:Stat	access:public
Super	./inc/fs.h	/^struct Super {$/;"	s
Super::s_magic	./inc/fs.h	/^	uint32_t s_magic;		\/\/ Magic number: FS_MAGIC$/;"	m	struct:Super	access:public
Super::s_nblocks	./inc/fs.h	/^	uint32_t s_nblocks;		\/\/ Total number of blocks on disk$/;"	m	struct:Super	access:public
Super::s_root	./inc/fs.h	/^	struct File s_root;		\/\/ Root directory node$/;"	m	struct:Super	typeref:struct:Super::File	access:public
T_ALIGN	./inc/trap.h	23;"	d
T_BOUND	./inc/trap.h	11;"	d
T_BRKPT	./inc/trap.h	9;"	d
T_DBLFLT	./inc/trap.h	14;"	d
T_DEBUG	./inc/trap.h	7;"	d
T_DEFAULT	./inc/trap.h	30;"	d
T_DEVICE	./inc/trap.h	13;"	d
T_DIVIDE	./inc/trap.h	6;"	d
T_FPERR	./inc/trap.h	22;"	d
T_GPFLT	./inc/trap.h	19;"	d
T_ILLOP	./inc/trap.h	12;"	d
T_MCHK	./inc/trap.h	24;"	d
T_NMI	./inc/trap.h	8;"	d
T_OFLOW	./inc/trap.h	10;"	d
T_PGFLT	./inc/trap.h	20;"	d
T_SEGNP	./inc/trap.h	17;"	d
T_SIMDERR	./inc/trap.h	25;"	d
T_STACK	./inc/trap.h	18;"	d
T_SYSCALL	./inc/trap.h	29;"	d
T_TSS	./inc/trap.h	16;"	d
Taskstate	./inc/mmu.h	/^struct Taskstate {$/;"	s
Taskstate::ts_cr3	./inc/mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
Taskstate::ts_cs	./inc/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ds	./inc/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eax	./inc/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebp	./inc/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ebx	./inc/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ecx	./inc/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edi	./inc/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_edx	./inc/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eflags	./inc/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_eip	./inc/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
Taskstate::ts_es	./inc/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esi	./inc/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp	./inc/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp0	./inc/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp1	./inc/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_esp2	./inc/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_fs	./inc/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_gs	./inc/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_iomb	./inc/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ldt	./inc/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_link	./inc/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding1	./inc/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding10	./inc/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding2	./inc/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding3	./inc/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding4	./inc/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding5	./inc/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding6	./inc/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding7	./inc/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding8	./inc/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_padding9	./inc/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss	./inc/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss0	./inc/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss1	./inc/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_ss2	./inc/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
Taskstate::ts_t	./inc/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
Trapframe	./inc/trap.h	/^struct Trapframe {$/;"	s
Trapframe::tf_cs	./inc/trap.h	/^	uint16_t tf_cs;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_ds	./inc/trap.h	/^	uint16_t tf_ds;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_eflags	./inc/trap.h	/^	uint32_t tf_eflags;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_eip	./inc/trap.h	/^	uintptr_t tf_eip;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_err	./inc/trap.h	/^	uint32_t tf_err;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_es	./inc/trap.h	/^	uint16_t tf_es;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_esp	./inc/trap.h	/^	uintptr_t tf_esp;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_padding1	./inc/trap.h	/^	uint16_t tf_padding1;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_padding2	./inc/trap.h	/^	uint16_t tf_padding2;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_padding3	./inc/trap.h	/^	uint16_t tf_padding3;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_padding4	./inc/trap.h	/^	uint16_t tf_padding4;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_regs	./inc/trap.h	/^	struct PushRegs tf_regs;$/;"	m	struct:Trapframe	typeref:struct:Trapframe::PushRegs	access:public
Trapframe::tf_ss	./inc/trap.h	/^	uint16_t tf_ss;$/;"	m	struct:Trapframe	access:public
Trapframe::tf_trapno	./inc/trap.h	/^	uint32_t tf_trapno;$/;"	m	struct:Trapframe	access:public
UENVS	./inc/memlayout.h	116;"	d
ULIM	./inc/memlayout.h	104;"	d
UPAGES	./inc/memlayout.h	114;"	d
USED	./inc/lib.h	24;"	d
USTABDATA	./inc/memlayout.h	139;"	d
USTACKTOP	./inc/memlayout.h	128;"	d
UTEMP	./inc/memlayout.h	134;"	d
UTEXT	./inc/memlayout.h	131;"	d
UTOP	./inc/memlayout.h	123;"	d
UTrapframe	./inc/trap.h	/^struct UTrapframe {$/;"	s
UTrapframe::utf_eflags	./inc/trap.h	/^	uint32_t utf_eflags;$/;"	m	struct:UTrapframe	access:public
UTrapframe::utf_eip	./inc/trap.h	/^	uintptr_t utf_eip;$/;"	m	struct:UTrapframe	access:public
UTrapframe::utf_err	./inc/trap.h	/^	uint32_t utf_err;$/;"	m	struct:UTrapframe	access:public
UTrapframe::utf_esp	./inc/trap.h	/^	uintptr_t utf_esp;$/;"	m	struct:UTrapframe	access:public
UTrapframe::utf_fault_va	./inc/trap.h	/^	uint32_t utf_fault_va;	\/* va for T_PGFLT, 0 otherwise *\/$/;"	m	struct:UTrapframe	access:public
UTrapframe::utf_regs	./inc/trap.h	/^	struct PushRegs utf_regs;$/;"	m	struct:UTrapframe	typeref:struct:UTrapframe::PushRegs	access:public
UVPT	./inc/memlayout.h	112;"	d
UXSTACKTOP	./inc/memlayout.h	125;"	d
_CONSOLE_H_	./kern/console.h	4;"	d
__spin_initlock	./kern/spinlock.h	/^void __spin_initlock(struct spinlock *lk, char *name);$/;"	p	signature:(struct spinlock *lk, char *name)
_kaddr	./kern/pmap.h	/^_kaddr(const char *file, int line, physaddr_t pa)$/;"	f	signature:(const char *file, int line, physaddr_t pa)
_pad	./inc/fs.h	/^	char _pad[PGSIZE];$/;"	m	union:Fsipc	access:public
_paddr	./kern/pmap.h	/^_paddr(const char *file, int line, void *kva)$/;"	f	signature:(const char *file, int line, void *kva)
_panic	./inc/assert.h	/^void _panic(const char*, int, const char*, ...) __attribute__((noreturn));$/;"	p	signature:(const char*, int, const char*, ...)
_warn	./inc/assert.h	/^void _warn(const char*, int, const char*, ...);$/;"	p	signature:(const char*, int, const char*, ...)
alloc_block	./fs/fs.h	/^int	alloc_block(void);$/;"	p	signature:(void)
argc	./inc/args.h	/^	int *argc;$/;"	m	struct:Argstate	access:public
argnext	./inc/args.h	/^int argnext(struct Argstate *);$/;"	p	signature:(struct Argstate *)
argnextvalue	./inc/args.h	/^char *argnextvalue(struct Argstate *);$/;"	p	signature:(struct Argstate *)
argstart	./inc/args.h	/^void argstart(int *argc, char **argv, struct Argstate *args);$/;"	p	signature:(int *argc, char **argv, struct Argstate *args)
argv	./inc/args.h	/^	const char **argv;$/;"	m	struct:Argstate	access:public
argvalue	./inc/args.h	/^	const char *argvalue;$/;"	m	struct:Argstate	access:public
argvalue	./inc/args.h	/^char *argvalue(struct Argstate *);$/;"	p	signature:(struct Argstate *)
assert	./inc/assert.h	14;"	d
backtrace	./kern/trap.h	/^void backtrace(struct Trapframe *);$/;"	p	signature:(struct Trapframe *)
bc_init	./fs/fs.h	/^void	bc_init(void);$/;"	p	signature:(void)
bitmap	./fs/fs.h	/^uint32_t *bitmap;		\/\/ bitmap blocks mapped in memory$/;"	v
block_is_free	./fs/fs.h	/^bool	block_is_free(uint32_t blockno);$/;"	p	signature:(uint32_t blockno)
bool	./inc/types.h	/^typedef _Bool bool;$/;"	t
boot	./inc/partition.h	/^	uint8_t boot;$/;"	m	struct:Partitiondesc	access:public
breakpoint	./inc/x86.h	/^breakpoint(void)$/;"	f	signature:(void)
breakpoint	./inc/x86.h	/^static __inline void breakpoint(void) __attribute__((always_inline));$/;"	p	signature:(void)
breakpoint_handler	./kern/trap.h	/^void breakpoint_handler(struct Trapframe*);$/;"	p	signature:(struct Trapframe*)
chs_begin	./inc/partition.h	/^	uint8_t chs_begin[3];$/;"	m	struct:Partitiondesc	access:public
chs_end	./inc/partition.h	/^	uint8_t chs_end[3];$/;"	m	struct:Partitiondesc	access:public
close	./inc/lib.h	/^int	close(int fd);$/;"	p	signature:(int fd)
close_all	./inc/lib.h	/^void	close_all(void);$/;"	p	signature:(void)
cons_getc	./kern/console.h	/^int cons_getc(void);$/;"	p	signature:(void)
cons_init	./kern/console.h	/^void cons_init(void);$/;"	p	signature:(void)
continue_exec	./kern/monitor.h	/^int continue_exec(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
cprintf	./inc/stdio.h	/^int	cprintf(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
cpu	./kern/spinlock.h	/^	struct CpuInfo *cpu;   \/\/ The CPU holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::CpuInfo	access:public
cpu_env	./kern/cpu.h	/^	struct Env *cpu_env;            \/\/ The currently-running environment.$/;"	m	struct:CpuInfo	typeref:struct:CpuInfo::Env	access:public
cpu_id	./kern/cpu.h	/^	uint8_t cpu_id;                 \/\/ Local APIC ID; index into cpus[] below$/;"	m	struct:CpuInfo	access:public
cpu_status	./kern/cpu.h	/^	volatile unsigned cpu_status;   \/\/ The status of the CPU$/;"	m	struct:CpuInfo	access:public
cpu_ts	./kern/cpu.h	/^	struct Taskstate cpu_ts;        \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:CpuInfo	typeref:struct:CpuInfo::Taskstate	access:public
cpuid	./inc/x86.h	/^cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)$/;"	f	signature:(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
cpuid	./inc/x86.h	/^static __inline void cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp);$/;"	p	signature:(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
cpunum	./kern/cpu.h	/^int cpunum(void);$/;"	p	signature:(void)
cputchar	./inc/lib.h	/^void	cputchar(int c);$/;"	p	signature:(int c)
cputchar	./inc/stdio.h	/^void	cputchar(int c);$/;"	p	signature:(int c)
curarg	./inc/args.h	/^	const char *curarg;$/;"	m	struct:Argstate	access:public
curenv	./kern/env.h	10;"	d
debuginfo_eip	./kern/kdebug.h	/^int debuginfo_eip(uintptr_t eip, struct Eipdebuginfo *info);$/;"	p	signature:(uintptr_t eip, struct Eipdebuginfo *info)
dev_close	./inc/fd.h	/^	int (*dev_close)(struct Fd *fd);$/;"	m	struct:Dev	access:public
dev_id	./inc/fd.h	/^	int dev_id;$/;"	m	struct:Dev	access:public
dev_lookup	./inc/fd.h	/^int	dev_lookup(int devid, struct Dev **dev_store);$/;"	p	signature:(int devid, struct Dev **dev_store)
dev_name	./inc/fd.h	/^	const char *dev_name;$/;"	m	struct:Dev	access:public
dev_read	./inc/fd.h	/^	ssize_t (*dev_read)(struct Fd *fd, void *buf, size_t len);$/;"	m	struct:Dev	access:public
dev_stat	./inc/fd.h	/^	int (*dev_stat)(struct Fd *fd, struct Stat *stat);$/;"	m	struct:Dev	access:public
dev_trunc	./inc/fd.h	/^	int (*dev_trunc)(struct Fd *fd, off_t length);$/;"	m	struct:Dev	access:public
dev_write	./inc/fd.h	/^	ssize_t (*dev_write)(struct Fd *fd, const void *buf, size_t len);$/;"	m	struct:Dev	access:public
diskaddr	./fs/fs.h	/^void*	diskaddr(uint32_t blockno);$/;"	p	signature:(uint32_t blockno)
dup	./inc/lib.h	/^int	dup(int oldfd, int newfd);$/;"	p	signature:(int oldfd, int newfd)
e_ehsize	./inc/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf	access:public
e_elf	./inc/elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf	access:public
e_entry	./inc/elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf	access:public
e_flags	./inc/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf	access:public
e_machine	./inc/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf	access:public
e_magic	./inc/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf	access:public
e_phentsize	./inc/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf	access:public
e_phnum	./inc/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf	access:public
e_phoff	./inc/elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf	access:public
e_shentsize	./inc/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf	access:public
e_shnum	./inc/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf	access:public
e_shoff	./inc/elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf	access:public
e_shstrndx	./inc/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf	access:public
e_type	./inc/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf	access:public
e_version	./inc/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf	access:public
eip_file	./kern/kdebug.h	/^	const char *eip_file;		\/\/ Source code filename for EIP$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_addr	./kern/kdebug.h	/^	uintptr_t eip_fn_addr;		\/\/ Address of start of function$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_name	./kern/kdebug.h	/^	const char *eip_fn_name;	\/\/ Name of function containing EIP$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_namelen	./kern/kdebug.h	/^	int eip_fn_namelen;		\/\/ Length of function name$/;"	m	struct:Eipdebuginfo	access:public
eip_fn_narg	./kern/kdebug.h	/^	int eip_fn_narg;		\/\/ Number of function arguments$/;"	m	struct:Eipdebuginfo	access:public
eip_line	./kern/kdebug.h	/^	int eip_line;			\/\/ Source code linenumber for EIP$/;"	m	struct:Eipdebuginfo	access:public
env_alloc	./kern/env.h	/^int	env_alloc(struct Env **e, envid_t parent_id);$/;"	p	signature:(struct Env **e, envid_t parent_id)
env_cpunum	./inc/env.h	/^	int env_cpunum;			\/\/ The CPU that the env is running on$/;"	m	struct:Env	access:public
env_create	./kern/env.h	/^void	env_create(uint8_t *binary, enum EnvType type);$/;"	p	signature:(uint8_t *binary, enum EnvType type)
env_destroy	./kern/env.h	/^void	env_destroy(struct Env *e);	\/\/ Does not return if e == curenv$/;"	p	signature:(struct Env *e)
env_free	./kern/env.h	/^void	env_free(struct Env *e);$/;"	p	signature:(struct Env *e)
env_id	./inc/env.h	/^	envid_t env_id;			\/\/ Unique environment identifier$/;"	m	struct:Env	access:public
env_init	./kern/env.h	/^void	env_init(void);$/;"	p	signature:(void)
env_init_percpu	./kern/env.h	/^void	env_init_percpu(void);$/;"	p	signature:(void)
env_ipc_dstva	./inc/env.h	/^	void *env_ipc_dstva;		\/\/ VA at which to map received page$/;"	m	struct:Env	access:public
env_ipc_from	./inc/env.h	/^	envid_t env_ipc_from;		\/\/ envid of the sender$/;"	m	struct:Env	access:public
env_ipc_perm	./inc/env.h	/^	int env_ipc_perm;		\/\/ Perm of page mapping received$/;"	m	struct:Env	access:public
env_ipc_recving	./inc/env.h	/^	bool env_ipc_recving;		\/\/ Env is blocked receiving$/;"	m	struct:Env	access:public
env_ipc_value	./inc/env.h	/^	uint32_t env_ipc_value;		\/\/ Data value sent to us$/;"	m	struct:Env	access:public
env_link	./inc/env.h	/^	struct Env *env_link;		\/\/ Next free Env$/;"	m	struct:Env	typeref:struct:Env::Env	access:public
env_parent_id	./inc/env.h	/^	envid_t env_parent_id;		\/\/ env_id of this env's parent$/;"	m	struct:Env	access:public
env_pgdir	./inc/env.h	/^	pde_t *env_pgdir;		\/\/ Kernel virtual address of page dir$/;"	m	struct:Env	access:public
env_pgfault_upcall	./inc/env.h	/^	void *env_pgfault_upcall;	\/\/ Page fault upcall entry point$/;"	m	struct:Env	access:public
env_pop_tf	./kern/env.h	/^void	env_pop_tf(struct Trapframe *tf) __attribute__((noreturn));$/;"	p	signature:(struct Trapframe *tf)
env_run	./kern/env.h	/^void	env_run(struct Env *e) __attribute__((noreturn));$/;"	p	signature:(struct Env *e)
env_runs	./inc/env.h	/^	uint32_t env_runs;		\/\/ Number of times environment has run$/;"	m	struct:Env	access:public
env_status	./inc/env.h	/^	unsigned env_status;		\/\/ Status of the environment$/;"	m	struct:Env	access:public
env_tf	./inc/env.h	/^	struct Trapframe env_tf;	\/\/ Saved registers$/;"	m	struct:Env	typeref:struct:Env::Trapframe	access:public
env_type	./inc/env.h	/^	enum EnvType env_type;		\/\/ Indicates special system environments$/;"	m	struct:Env	typeref:enum:Env::EnvType	access:public
envid2env	./kern/env.h	/^int	envid2env(envid_t envid, struct Env **env_store, bool checkperm);$/;"	p	signature:(envid_t envid, struct Env **env_store, bool checkperm)
envid_t	./inc/env.h	/^typedef int32_t envid_t;$/;"	t
exit	./inc/lib.h	/^void	exit(void);$/;"	p	signature:(void)
f_direct	./inc/fs.h	/^	uint32_t f_direct[NDIRECT];	\/\/ direct blocks$/;"	m	struct:File	access:public
f_indirect	./inc/fs.h	/^	uint32_t f_indirect;		\/\/ indirect block$/;"	m	struct:File	access:public
f_name	./inc/fs.h	/^	char f_name[MAXNAMELEN];	\/\/ filename$/;"	m	struct:File	access:public
f_pad	./inc/fs.h	/^	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];$/;"	m	struct:File	access:public
f_size	./inc/fs.h	/^	off_t f_size;			\/\/ file size in bytes$/;"	m	struct:File	access:public
f_type	./inc/fs.h	/^	uint32_t f_type;		\/\/ file type$/;"	m	struct:File	access:public
false	./inc/types.h	/^enum { false, true };$/;"	e	enum:__anon4
fd2data	./inc/fd.h	/^char*	fd2data(struct Fd *fd);$/;"	p	signature:(struct Fd *fd)
fd2num	./inc/fd.h	/^int	fd2num(struct Fd *fd);$/;"	p	signature:(struct Fd *fd)
fd_alloc	./inc/fd.h	/^int	fd_alloc(struct Fd **fd_store);$/;"	p	signature:(struct Fd **fd_store)
fd_close	./inc/fd.h	/^int	fd_close(struct Fd *fd, bool must_exist);$/;"	p	signature:(struct Fd *fd, bool must_exist)
fd_dev_id	./inc/fd.h	/^	int fd_dev_id;$/;"	m	struct:Fd	access:public
fd_file	./inc/fd.h	/^		struct FdFile fd_file;$/;"	m	union:Fd::__anon5	typeref:struct:Fd::__anon5::FdFile	access:public
fd_lookup	./inc/fd.h	/^int	fd_lookup(int fdnum, struct Fd **fd_store);$/;"	p	signature:(int fdnum, struct Fd **fd_store)
fd_offset	./inc/fd.h	/^	off_t fd_offset;$/;"	m	struct:Fd	access:public
fd_omode	./inc/fd.h	/^	int fd_omode;$/;"	m	struct:Fd	access:public
file_create	./fs/fs.h	/^int	file_create(const char *path, struct File **f);$/;"	p	signature:(const char *path, struct File **f)
file_flush	./fs/fs.h	/^void	file_flush(struct File *f);$/;"	p	signature:(struct File *f)
file_get_block	./fs/fs.h	/^int	file_get_block(struct File *f, uint32_t file_blockno, char **pblk);$/;"	p	signature:(struct File *f, uint32_t file_blockno, char **pblk)
file_open	./fs/fs.h	/^int	file_open(const char *path, struct File **f);$/;"	p	signature:(const char *path, struct File **f)
file_read	./fs/fs.h	/^ssize_t	file_read(struct File *f, void *buf, size_t count, off_t offset);$/;"	p	signature:(struct File *f, void *buf, size_t count, off_t offset)
file_remove	./fs/fs.h	/^int	file_remove(const char *path);$/;"	p	signature:(const char *path)
file_set_size	./fs/fs.h	/^int	file_set_size(struct File *f, off_t newsize);$/;"	p	signature:(struct File *f, off_t newsize)
file_write	./fs/fs.h	/^int	file_write(struct File *f, const void *buf, size_t count, off_t offset);$/;"	p	signature:(struct File *f, const void *buf, size_t count, off_t offset)
flush	./inc/fs.h	/^	} flush;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_flush	access:public
flush_block	./fs/fs.h	/^void	flush_block(void *addr);$/;"	p	signature:(void *addr)
fork	./inc/lib.h	/^envid_t	fork(void);$/;"	p	signature:(void)
fprintf	./inc/stdio.h	/^int	fprintf(int fd, const char *fmt, ...);$/;"	p	signature:(int fd, const char *fmt, ...)
fs_init	./fs/fs.h	/^void	fs_init(void);$/;"	p	signature:(void)
fs_sync	./fs/fs.h	/^void	fs_sync(void);$/;"	p	signature:(void)
fs_test	./fs/fs.h	/^void	fs_test(void);$/;"	p	signature:(void)
fstat	./inc/lib.h	/^int	fstat(int fd, struct Stat *statbuf);$/;"	p	signature:(int fd, struct Stat *statbuf)
ftruncate	./inc/lib.h	/^int	ftruncate(int fd, off_t size);$/;"	p	signature:(int fd, off_t size)
gd_args	./inc/mmu.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:Gatedesc	access:public
gd_dpl	./inc/mmu.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:Gatedesc	access:public
gd_off_15_0	./inc/mmu.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_off_31_16	./inc/mmu.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:Gatedesc	access:public
gd_p	./inc/mmu.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:Gatedesc	access:public
gd_rsv1	./inc/mmu.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:Gatedesc	access:public
gd_s	./inc/mmu.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:Gatedesc	access:public
gd_sel	./inc/mmu.h	/^	unsigned gd_sel : 16;        \/\/ segment selector$/;"	m	struct:Gatedesc	access:public
gd_type	./inc/mmu.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:Gatedesc	access:public
getchar	./inc/lib.h	/^int	getchar(void);$/;"	p	signature:(void)
getchar	./inc/stdio.h	/^int	getchar(void);$/;"	p	signature:(void)
id	./inc/fd.h	/^	int id;$/;"	m	struct:FdFile	access:public
ide_probe_disk1	./fs/fs.h	/^bool	ide_probe_disk1(void);$/;"	p	signature:(void)
ide_read	./fs/fs.h	/^int	ide_read(uint32_t secno, void *dst, size_t nsecs);$/;"	p	signature:(uint32_t secno, void *dst, size_t nsecs)
ide_set_disk	./fs/fs.h	/^void	ide_set_disk(int diskno);$/;"	p	signature:(int diskno)
ide_set_partition	./fs/fs.h	/^void	ide_set_partition(uint32_t first_sect, uint32_t nsect);$/;"	p	signature:(uint32_t first_sect, uint32_t nsect)
ide_write	./fs/fs.h	/^int	ide_write(uint32_t secno, const void *src, size_t nsecs);$/;"	p	signature:(uint32_t secno, const void *src, size_t nsecs)
inb	./inc/x86.h	/^inb(int port)$/;"	f	signature:(int port)
inb	./inc/x86.h	/^static __inline uint8_t inb(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
inl	./inc/x86.h	/^inl(int port)$/;"	f	signature:(int port)
inl	./inc/x86.h	/^static __inline uint32_t inl(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
insb	./inc/x86.h	/^insb(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insb	./inc/x86.h	/^static __inline void insb(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
insl	./inc/x86.h	/^insl(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insl	./inc/x86.h	/^static __inline void insl(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
insw	./inc/x86.h	/^insw(int port, void *addr, int cnt)$/;"	f	signature:(int port, void *addr, int cnt)
insw	./inc/x86.h	/^static __inline void insw(int port, void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, void *addr, int cnt)
int16_t	./inc/types.h	/^typedef short int16_t;$/;"	t
int32_t	./inc/types.h	/^typedef int int32_t;$/;"	t
int64_t	./inc/types.h	/^typedef long long int64_t;$/;"	t
int8_t	./inc/types.h	/^typedef __signed char int8_t;$/;"	t
intptr_t	./inc/types.h	/^typedef int32_t intptr_t;$/;"	t
invlpg	./inc/x86.h	/^invlpg(void *addr)$/;"	f	signature:(void *addr)
invlpg	./inc/x86.h	/^static __inline void invlpg(void *addr) __attribute__((always_inline));$/;"	p	signature:(void *addr)
inw	./inc/x86.h	/^inw(int port)$/;"	f	signature:(int port)
inw	./inc/x86.h	/^static __inline uint16_t inw(int port) __attribute__((always_inline));$/;"	p	signature:(int port)
ipc_find_env	./inc/lib.h	/^envid_t	ipc_find_env(enum EnvType type);$/;"	p	signature:(enum EnvType type)
ipc_recv	./inc/lib.h	/^int32_t ipc_recv(envid_t *from_env_store, void *pg, int *perm_store);$/;"	p	signature:(envid_t *from_env_store, void *pg, int *perm_store)
ipc_send	./inc/lib.h	/^void	ipc_send(envid_t to_env, uint32_t value, void *pg, int perm);$/;"	p	signature:(envid_t to_env, uint32_t value, void *pg, int perm)
irq_setmask_8259A	./kern/picirq.h	/^void irq_setmask_8259A(uint16_t mask);$/;"	p	signature:(uint16_t mask)
iscons	./inc/lib.h	/^int	iscons(int fd);$/;"	p	signature:(int fd)
iscons	./inc/stdio.h	/^int	iscons(int fd);$/;"	p	signature:(int fd)
kbd_intr	./kern/console.h	/^void kbd_intr(void); \/\/ irq 1$/;"	p	signature:(void)
lapic_eoi	./kern/cpu.h	/^void lapic_eoi(void);$/;"	p	signature:(void)
lapic_init	./kern/cpu.h	/^void lapic_init(void);$/;"	p	signature:(void)
lapic_ipi	./kern/cpu.h	/^void lapic_ipi(int vector);$/;"	p	signature:(int vector)
lapic_startap	./kern/cpu.h	/^void lapic_startap(uint8_t apicid, uint32_t addr);$/;"	p	signature:(uint8_t apicid, uint32_t addr)
lba_length	./inc/partition.h	/^	uint32_t lba_length;$/;"	m	struct:Partitiondesc	access:public
lba_start	./inc/partition.h	/^	uint32_t lba_start;$/;"	m	struct:Partitiondesc	access:public
lcr0	./inc/x86.h	/^lcr0(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr0	./inc/x86.h	/^static __inline void lcr0(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lcr3	./inc/x86.h	/^lcr3(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr3	./inc/x86.h	/^static __inline void lcr3(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lcr4	./inc/x86.h	/^lcr4(uint32_t val)$/;"	f	signature:(uint32_t val)
lcr4	./inc/x86.h	/^static __inline void lcr4(uint32_t val) __attribute__((always_inline));$/;"	p	signature:(uint32_t val)
lgdt	./inc/x86.h	/^lgdt(void *p)$/;"	f	signature:(void *p)
lidt	./inc/x86.h	/^lidt(void *p)$/;"	f	signature:(void *p)
lidt	./inc/x86.h	/^static __inline void lidt(void *p) __attribute__((always_inline));$/;"	p	signature:(void *p)
lldt	./inc/x86.h	/^lldt(uint16_t sel)$/;"	f	signature:(uint16_t sel)
lldt	./inc/x86.h	/^static __inline void lldt(uint16_t sel) __attribute__((always_inline));$/;"	p	signature:(uint16_t sel)
lock_kernel	./kern/spinlock.h	/^lock_kernel(void)$/;"	f	signature:(void)
locked	./kern/spinlock.h	/^	unsigned locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock	access:public
ltr	./inc/x86.h	/^ltr(uint16_t sel)$/;"	f	signature:(uint16_t sel)
ltr	./inc/x86.h	/^static __inline void ltr(uint16_t sel) __attribute__((always_inline));$/;"	p	signature:(uint16_t sel)
mc146818_read	./kern/kclock.h	/^unsigned mc146818_read(unsigned reg);$/;"	p	signature:(unsigned reg)
mc146818_write	./kern/kclock.h	/^void mc146818_write(unsigned reg, unsigned datum);$/;"	p	signature:(unsigned reg, unsigned datum)
mem_init	./kern/pmap.h	/^void	mem_init(void);$/;"	p	signature:(void)
memcmp	./inc/string.h	/^int	memcmp(const void *s1, const void *s2, size_t len);$/;"	p	signature:(const void *s1, const void *s2, size_t len)
memcpy	./inc/string.h	/^void *	memcpy(void *dst, const void *src, size_t len);$/;"	p	signature:(void *dst, const void *src, size_t len)
memfind	./inc/string.h	/^void *	memfind(const void *s, int c, size_t len);$/;"	p	signature:(const void *s, int c, size_t len)
memmove	./inc/string.h	/^void *	memmove(void *dst, const void *src, size_t len);$/;"	p	signature:(void *dst, const void *src, size_t len)
memset	./inc/string.h	/^void *	memset(void *dst, int c, size_t len);$/;"	p	signature:(void *dst, int c, size_t len)
mmio_map_region	./kern/pmap.h	/^void *	mmio_map_region(physaddr_t pa, size_t size);$/;"	p	signature:(physaddr_t pa, size_t size)
mon_backtrace	./kern/monitor.h	/^int mon_backtrace(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
mon_help	./kern/monitor.h	/^int mon_help(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
mon_kerninfo	./kern/monitor.h	/^int mon_kerninfo(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
monitor	./kern/monitor.h	/^void monitor(struct Trapframe *tf);$/;"	p	signature:(struct Trapframe *tf)
mp_init	./kern/cpu.h	/^void mp_init(void);$/;"	p	signature:(void)
n_desc	./inc/stab.h	/^	uint16_t n_desc;        \/\/ description field$/;"	m	struct:Stab	access:public
n_other	./inc/stab.h	/^	uint8_t n_other;        \/\/ misc info (usually empty)$/;"	m	struct:Stab	access:public
n_strx	./inc/stab.h	/^	uint32_t n_strx;	\/\/ index into string table of name$/;"	m	struct:Stab	access:public
n_type	./inc/stab.h	/^	uint8_t n_type;         \/\/ type of symbol$/;"	m	struct:Stab	access:public
n_value	./inc/stab.h	/^	uintptr_t n_value;	\/\/ value of symbol$/;"	m	struct:Stab	access:public
name	./kern/spinlock.h	/^	char *name;            \/\/ Name of lock.$/;"	m	struct:spinlock	access:public
off_t	./inc/types.h	/^typedef int32_t off_t;$/;"	t
offsetof	./inc/types.h	71;"	d
open	./inc/fs.h	/^	} open;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_open	access:public
open	./inc/lib.h	/^int	open(const char *path, int mode);$/;"	p	signature:(const char *path, int mode)
opencons	./inc/lib.h	/^int	opencons(void);$/;"	p	signature:(void)
outb	./inc/x86.h	/^outb(int port, uint8_t data)$/;"	f	signature:(int port, uint8_t data)
outb	./inc/x86.h	/^static __inline void outb(int port, uint8_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint8_t data)
outl	./inc/x86.h	/^outl(int port, uint32_t data)$/;"	f	signature:(int port, uint32_t data)
outl	./inc/x86.h	/^static __inline void outl(int port, uint32_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint32_t data)
outsb	./inc/x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsb	./inc/x86.h	/^static __inline void outsb(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outsl	./inc/x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsl	./inc/x86.h	/^static __inline void outsl(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outsw	./inc/x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f	signature:(int port, const void *addr, int cnt)
outsw	./inc/x86.h	/^static __inline void outsw(int port, const void *addr, int cnt) __attribute__((always_inline));$/;"	p	signature:(int port, const void *addr, int cnt)
outw	./inc/x86.h	/^outw(int port, uint16_t data)$/;"	f	signature:(int port, uint16_t data)
outw	./inc/x86.h	/^static __inline void outw(int port, uint16_t data) __attribute__((always_inline));$/;"	p	signature:(int port, uint16_t data)
p_align	./inc/elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr	access:public
p_filesz	./inc/elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr	access:public
p_flags	./inc/elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr	access:public
p_memsz	./inc/elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr	access:public
p_offset	./inc/elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr	access:public
p_pa	./inc/elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr	access:public
p_type	./inc/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr	access:public
p_va	./inc/elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr	access:public
pa2page	./kern/pmap.h	/^pa2page(physaddr_t pa)$/;"	f	signature:(physaddr_t pa)
page2kva	./kern/pmap.h	/^page2kva(struct PageInfo *pp)$/;"	f	signature:(struct PageInfo *pp)
page2pa	./kern/pmap.h	/^page2pa(struct PageInfo *pp)$/;"	f	signature:(struct PageInfo *pp)
page_alloc	./kern/pmap.h	/^struct PageInfo *page_alloc(int alloc_flags);$/;"	p	signature:(int alloc_flags)
page_decref	./kern/pmap.h	/^void	page_decref(struct PageInfo *pp);$/;"	p	signature:(struct PageInfo *pp)
page_fault_handler	./kern/trap.h	/^void page_fault_handler(struct Trapframe *);$/;"	p	signature:(struct Trapframe *)
page_free	./kern/pmap.h	/^void	page_free(struct PageInfo *pp);$/;"	p	signature:(struct PageInfo *pp)
page_init	./kern/pmap.h	/^void	page_init(void);$/;"	p	signature:(void)
page_insert	./kern/pmap.h	/^int	page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);$/;"	p	signature:(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
page_lookup	./kern/pmap.h	/^struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);$/;"	p	signature:(pde_t *pgdir, void *va, pte_t **pte_store)
page_remove	./kern/pmap.h	/^void	page_remove(pde_t *pgdir, void *va);$/;"	p	signature:(pde_t *pgdir, void *va)
pageref	./inc/lib.h	/^int	pageref(void *addr);$/;"	p	signature:(void *addr)
panic	./inc/assert.h	12;"	d
pcs	./kern/spinlock.h	/^	uintptr_t pcs[10];     \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock	access:public
pd_base	./inc/mmu.h	/^	uint32_t pd_base;		\/\/ Base address$/;"	m	struct:Pseudodesc	access:public
pd_lim	./inc/mmu.h	/^	uint16_t pd_lim;		\/\/ Limit$/;"	m	struct:Pseudodesc	access:public
pde_t	./inc/memlayout.h	/^typedef uint32_t pde_t;$/;"	t
pgdir_walk	./kern/pmap.h	/^pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);$/;"	p	signature:(pde_t *pgdir, const void *va, int create)
physaddr_t	./inc/types.h	/^typedef uint32_t physaddr_t;$/;"	t
pic_init	./kern/picirq.h	/^void pic_init(void);$/;"	p	signature:(void)
pipe	./inc/lib.h	/^int	pipe(int pipefds[2]);$/;"	p	signature:(int pipefds[2])
pipeisclosed	./inc/lib.h	/^int	pipeisclosed(int pipefd);$/;"	p	signature:(int pipefd)
pp_link	./inc/memlayout.h	/^	struct PageInfo *pp_link;$/;"	m	struct:PageInfo	typeref:struct:PageInfo::PageInfo	access:public
pp_ref	./inc/memlayout.h	/^	uint16_t pp_ref;$/;"	m	struct:PageInfo	access:public
ppn_t	./inc/types.h	/^typedef uint32_t ppn_t;$/;"	t
print_regs	./kern/trap.h	/^void print_regs(struct PushRegs *regs);$/;"	p	signature:(struct PushRegs *regs)
print_trapframe	./kern/trap.h	/^void print_trapframe(struct Trapframe *tf);$/;"	p	signature:(struct Trapframe *tf)
printf	./inc/stdio.h	/^int	printf(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
printfmt	./inc/stdio.h	/^void	printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);$/;"	p	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
pte_t	./inc/memlayout.h	/^typedef uint32_t pte_t;$/;"	t
rcr0	./inc/x86.h	/^rcr0(void)$/;"	f	signature:(void)
rcr0	./inc/x86.h	/^static __inline uint32_t rcr0(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr2	./inc/x86.h	/^rcr2(void)$/;"	f	signature:(void)
rcr2	./inc/x86.h	/^static __inline uint32_t rcr2(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr3	./inc/x86.h	/^rcr3(void)$/;"	f	signature:(void)
rcr3	./inc/x86.h	/^static __inline uint32_t rcr3(void) __attribute__((always_inline));$/;"	p	signature:(void)
rcr4	./inc/x86.h	/^rcr4(void)$/;"	f	signature:(void)
rcr4	./inc/x86.h	/^static __inline uint32_t rcr4(void) __attribute__((always_inline));$/;"	p	signature:(void)
read	./inc/fs.h	/^	} read;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_read	access:public
read	./inc/lib.h	/^ssize_t	read(int fd, void *buf, size_t nbytes);$/;"	p	signature:(int fd, void *buf, size_t nbytes)
readRet	./inc/fs.h	/^	} readRet;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsret_read	access:public
read_ebp	./inc/x86.h	/^read_ebp(void)$/;"	f	signature:(void)
read_ebp	./inc/x86.h	/^static __inline uint32_t read_ebp(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_eflags	./inc/x86.h	/^read_eflags(void)$/;"	f	signature:(void)
read_eflags	./inc/x86.h	/^static __inline uint32_t read_eflags(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_esp	./inc/x86.h	/^read_esp(void)$/;"	f	signature:(void)
read_esp	./inc/x86.h	/^static __inline uint32_t read_esp(void) __attribute__((always_inline));$/;"	p	signature:(void)
read_tsc	./inc/x86.h	/^read_tsc(void)$/;"	f	signature:(void)
read_tsc	./inc/x86.h	/^static __inline uint64_t read_tsc(void) __attribute__((always_inline));$/;"	p	signature:(void)
readline	./inc/lib.h	/^char*	readline(const char *buf);$/;"	p	signature:(const char *buf)
readline	./inc/stdio.h	/^char*	readline(const char *prompt);$/;"	p	signature:(const char *prompt)
readn	./inc/lib.h	/^ssize_t	readn(int fd, void *buf, size_t nbytes);$/;"	p	signature:(int fd, void *buf, size_t nbytes)
reg_eax	./inc/trap.h	/^	uint32_t reg_eax;$/;"	m	struct:PushRegs	access:public
reg_ebp	./inc/trap.h	/^	uint32_t reg_ebp;$/;"	m	struct:PushRegs	access:public
reg_ebx	./inc/trap.h	/^	uint32_t reg_ebx;$/;"	m	struct:PushRegs	access:public
reg_ecx	./inc/trap.h	/^	uint32_t reg_ecx;$/;"	m	struct:PushRegs	access:public
reg_edi	./inc/trap.h	/^	uint32_t reg_edi;$/;"	m	struct:PushRegs	access:public
reg_edx	./inc/trap.h	/^	uint32_t reg_edx;$/;"	m	struct:PushRegs	access:public
reg_esi	./inc/trap.h	/^	uint32_t reg_esi;$/;"	m	struct:PushRegs	access:public
reg_oesp	./inc/trap.h	/^	uint32_t reg_oesp;		\/* Useless *\/$/;"	m	struct:PushRegs	access:public
remove	./inc/fs.h	/^	} remove;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_remove	access:public
remove	./inc/lib.h	/^int	remove(const char *path);$/;"	p	signature:(const char *path)
req_buf	./inc/fs.h	/^		char req_buf[PGSIZE - (sizeof(int) + sizeof(size_t))];$/;"	m	struct:Fsipc::Fsreq_write	access:public
req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_flush	access:public
req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_read	access:public
req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_set_size	access:public
req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_stat	access:public
req_fileid	./inc/fs.h	/^		int req_fileid;$/;"	m	struct:Fsipc::Fsreq_write	access:public
req_n	./inc/fs.h	/^		size_t req_n;$/;"	m	struct:Fsipc::Fsreq_read	access:public
req_n	./inc/fs.h	/^		size_t req_n;$/;"	m	struct:Fsipc::Fsreq_write	access:public
req_omode	./inc/fs.h	/^		int req_omode;$/;"	m	struct:Fsipc::Fsreq_open	access:public
req_path	./inc/fs.h	/^		char req_path[MAXPATHLEN];$/;"	m	struct:Fsipc::Fsreq_open	access:public
req_path	./inc/fs.h	/^		char req_path[MAXPATHLEN];$/;"	m	struct:Fsipc::Fsreq_remove	access:public
req_size	./inc/fs.h	/^		off_t req_size;$/;"	m	struct:Fsipc::Fsreq_set_size	access:public
ret_buf	./inc/fs.h	/^		char ret_buf[PGSIZE];$/;"	m	struct:Fsipc::Fsret_read	access:public
ret_isdir	./inc/fs.h	/^		int ret_isdir;$/;"	m	struct:Fsipc::Fsret_stat	access:public
ret_name	./inc/fs.h	/^		char ret_name[MAXNAMELEN];$/;"	m	struct:Fsipc::Fsret_stat	access:public
ret_size	./inc/fs.h	/^		off_t ret_size;$/;"	m	struct:Fsipc::Fsret_stat	access:public
s_magic	./inc/fs.h	/^	uint32_t s_magic;		\/\/ Magic number: FS_MAGIC$/;"	m	struct:Super	access:public
s_nblocks	./inc/fs.h	/^	uint32_t s_nblocks;		\/\/ Total number of blocks on disk$/;"	m	struct:Super	access:public
s_root	./inc/fs.h	/^	struct File s_root;		\/\/ Root directory node$/;"	m	struct:Super	typeref:struct:Super::File	access:public
sched_yield	./kern/sched.h	/^void sched_yield(void) __attribute__((noreturn));$/;"	p	signature:(void)
sd_avl	./inc/mmu.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:Segdesc	access:public
sd_base_15_0	./inc/mmu.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_23_16	./inc/mmu.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_base_31_24	./inc/mmu.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:Segdesc	access:public
sd_db	./inc/mmu.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:Segdesc	access:public
sd_dpl	./inc/mmu.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:Segdesc	access:public
sd_g	./inc/mmu.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:Segdesc	access:public
sd_lim_15_0	./inc/mmu.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_lim_19_16	./inc/mmu.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:Segdesc	access:public
sd_p	./inc/mmu.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:Segdesc	access:public
sd_rsv1	./inc/mmu.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:Segdesc	access:public
sd_s	./inc/mmu.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:Segdesc	access:public
sd_type	./inc/mmu.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:Segdesc	access:public
seek	./inc/lib.h	/^int	seek(int fd, off_t offset);$/;"	p	signature:(int fd, off_t offset)
serial_intr	./kern/console.h	/^void serial_intr(void); \/\/ irq 4$/;"	p	signature:(void)
set_pgfault_handler	./inc/lib.h	/^void	set_pgfault_handler(void (*handler)(struct UTrapframe *utf));$/;"	p	signature:(void (*handler)(struct UTrapframe *utf))
set_size	./inc/fs.h	/^	} set_size;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_set_size	access:public
sfork	./inc/lib.h	/^envid_t	sfork(void);	\/\/ Challenge!$/;"	p	signature:(void)
sh_addr	./inc/elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr	access:public
sh_addralign	./inc/elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr	access:public
sh_entsize	./inc/elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr	access:public
sh_flags	./inc/elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr	access:public
sh_info	./inc/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr	access:public
sh_link	./inc/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr	access:public
sh_name	./inc/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr	access:public
sh_offset	./inc/elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr	access:public
sh_size	./inc/elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr	access:public
sh_type	./inc/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr	access:public
single_step	./kern/monitor.h	/^int single_step(int argc, char **argv, struct Trapframe *tf);$/;"	p	signature:(int argc, char **argv, struct Trapframe *tf)
size_t	./inc/types.h	/^typedef uint32_t size_t;$/;"	t
snprintf	./inc/stdio.h	/^int	snprintf(char *str, int size, const char *fmt, ...);$/;"	p	signature:(char *str, int size, const char *fmt, ...)
spawn	./inc/lib.h	/^envid_t	spawn(const char *program, const char **argv);$/;"	p	signature:(const char *program, const char **argv)
spawnl	./inc/lib.h	/^envid_t	spawnl(const char *program, const char *arg0, ...);$/;"	p	signature:(const char *program, const char *arg0, ...)
spin_initlock	./kern/spinlock.h	26;"	d
spin_lock	./kern/spinlock.h	/^void spin_lock(struct spinlock *lk);$/;"	p	signature:(struct spinlock *lk)
spin_unlock	./kern/spinlock.h	/^void spin_unlock(struct spinlock *lk);$/;"	p	signature:(struct spinlock *lk)
spinlock	./kern/spinlock.h	/^struct spinlock {$/;"	s
spinlock::cpu	./kern/spinlock.h	/^	struct CpuInfo *cpu;   \/\/ The CPU holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::CpuInfo	access:public
spinlock::locked	./kern/spinlock.h	/^	unsigned locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock	access:public
spinlock::name	./kern/spinlock.h	/^	char *name;            \/\/ Name of lock.$/;"	m	struct:spinlock	access:public
spinlock::pcs	./kern/spinlock.h	/^	uintptr_t pcs[10];     \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock	access:public
ssize_t	./inc/types.h	/^typedef int32_t ssize_t;$/;"	t
st_dev	./inc/fd.h	/^	struct Dev *st_dev;$/;"	m	struct:Stat	typeref:struct:Stat::Dev	access:public
st_isdir	./inc/fd.h	/^	int st_isdir;$/;"	m	struct:Stat	access:public
st_name	./inc/fd.h	/^	char st_name[MAXNAMELEN];$/;"	m	struct:Stat	access:public
st_size	./inc/fd.h	/^	off_t st_size;$/;"	m	struct:Stat	access:public
stat	./inc/fs.h	/^	} stat;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_stat	access:public
stat	./inc/lib.h	/^int	stat(const char *path, struct Stat *statbuf);$/;"	p	signature:(const char *path, struct Stat *statbuf)
statRet	./inc/fs.h	/^	} statRet;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsret_stat	access:public
static_assert	./inc/assert.h	18;"	d
strcat	./inc/string.h	/^char *	strcat(char *dst, const char *src);$/;"	p	signature:(char *dst, const char *src)
strchr	./inc/string.h	/^char *	strchr(const char *s, char c);$/;"	p	signature:(const char *s, char c)
strcmp	./inc/string.h	/^int	strcmp(const char *s1, const char *s2);$/;"	p	signature:(const char *s1, const char *s2)
strcpy	./inc/string.h	/^char *	strcpy(char *dst, const char *src);$/;"	p	signature:(char *dst, const char *src)
strfind	./inc/string.h	/^char *	strfind(const char *s, char c);$/;"	p	signature:(const char *s, char c)
strlcpy	./inc/string.h	/^size_t	strlcpy(char *dst, const char *src, size_t size);$/;"	p	signature:(char *dst, const char *src, size_t size)
strlen	./inc/string.h	/^int	strlen(const char *s);$/;"	p	signature:(const char *s)
strncmp	./inc/string.h	/^int	strncmp(const char *s1, const char *s2, size_t size);$/;"	p	signature:(const char *s1, const char *s2, size_t size)
strncpy	./inc/string.h	/^char *	strncpy(char *dst, const char *src, size_t size);$/;"	p	signature:(char *dst, const char *src, size_t size)
strnlen	./inc/string.h	/^int	strnlen(const char *s, size_t size);$/;"	p	signature:(const char *s, size_t size)
strtol	./inc/string.h	/^long	strtol(const char *s, char **endptr, int base);$/;"	p	signature:(const char *s, char **endptr, int base)
super	./fs/fs.h	/^struct Super *super;		\/\/ superblock$/;"	v	typeref:struct:Super
sync	./inc/lib.h	/^int	sync(void);$/;"	p	signature:(void)
sys_cgetc	./inc/lib.h	/^int	sys_cgetc(void);$/;"	p	signature:(void)
sys_cputs	./inc/lib.h	/^void	sys_cputs(const char *string, size_t len);$/;"	p	signature:(const char *string, size_t len)
sys_env_destroy	./inc/lib.h	/^int	sys_env_destroy(envid_t);$/;"	p	signature:(envid_t)
sys_env_set_pgfault_upcall	./inc/lib.h	/^int	sys_env_set_pgfault_upcall(envid_t env, void *upcall);$/;"	p	signature:(envid_t env, void *upcall)
sys_env_set_status	./inc/lib.h	/^int	sys_env_set_status(envid_t env, int status);$/;"	p	signature:(envid_t env, int status)
sys_env_set_trapframe	./inc/lib.h	/^int	sys_env_set_trapframe(envid_t env, struct Trapframe *tf);$/;"	p	signature:(envid_t env, struct Trapframe *tf)
sys_exofork	./inc/lib.h	/^static envid_t sys_exofork(void);$/;"	p	signature:(void)
sys_exofork	./inc/lib.h	/^sys_exofork(void)$/;"	f	signature:(void)
sys_getenvid	./inc/lib.h	/^envid_t	sys_getenvid(void);$/;"	p	signature:(void)
sys_ipc_recv	./inc/lib.h	/^int	sys_ipc_recv(void *rcv_pg);$/;"	p	signature:(void *rcv_pg)
sys_ipc_try_send	./inc/lib.h	/^int	sys_ipc_try_send(envid_t to_env, uint32_t value, void *pg, int perm);$/;"	p	signature:(envid_t to_env, uint32_t value, void *pg, int perm)
sys_page_alloc	./inc/lib.h	/^int	sys_page_alloc(envid_t env, void *pg, int perm);$/;"	p	signature:(envid_t env, void *pg, int perm)
sys_page_map	./inc/lib.h	/^int	sys_page_map(envid_t src_env, void *src_pg,$/;"	p	signature:(envid_t src_env, void *src_pg, envid_t dst_env, void *dst_pg, int perm)
sys_page_unmap	./inc/lib.h	/^int	sys_page_unmap(envid_t env, void *pg);$/;"	p	signature:(envid_t env, void *pg)
sys_yield	./inc/lib.h	/^void	sys_yield(void);$/;"	p	signature:(void)
syscall	./kern/syscall.h	/^int32_t syscall(uint32_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5);$/;"	p	signature:(uint32_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
system_call_handler	./kern/trap.h	/^int32_t system_call_handler(struct Trapframe*);$/;"	p	signature:(struct Trapframe*)
tf_cs	./inc/trap.h	/^	uint16_t tf_cs;$/;"	m	struct:Trapframe	access:public
tf_ds	./inc/trap.h	/^	uint16_t tf_ds;$/;"	m	struct:Trapframe	access:public
tf_eflags	./inc/trap.h	/^	uint32_t tf_eflags;$/;"	m	struct:Trapframe	access:public
tf_eip	./inc/trap.h	/^	uintptr_t tf_eip;$/;"	m	struct:Trapframe	access:public
tf_err	./inc/trap.h	/^	uint32_t tf_err;$/;"	m	struct:Trapframe	access:public
tf_es	./inc/trap.h	/^	uint16_t tf_es;$/;"	m	struct:Trapframe	access:public
tf_esp	./inc/trap.h	/^	uintptr_t tf_esp;$/;"	m	struct:Trapframe	access:public
tf_padding1	./inc/trap.h	/^	uint16_t tf_padding1;$/;"	m	struct:Trapframe	access:public
tf_padding2	./inc/trap.h	/^	uint16_t tf_padding2;$/;"	m	struct:Trapframe	access:public
tf_padding3	./inc/trap.h	/^	uint16_t tf_padding3;$/;"	m	struct:Trapframe	access:public
tf_padding4	./inc/trap.h	/^	uint16_t tf_padding4;$/;"	m	struct:Trapframe	access:public
tf_regs	./inc/trap.h	/^	struct PushRegs tf_regs;$/;"	m	struct:Trapframe	typeref:struct:Trapframe::PushRegs	access:public
tf_ss	./inc/trap.h	/^	uint16_t tf_ss;$/;"	m	struct:Trapframe	access:public
tf_trapno	./inc/trap.h	/^	uint32_t tf_trapno;$/;"	m	struct:Trapframe	access:public
thiscpu	./kern/cpu.h	38;"	d
tlb_invalidate	./kern/pmap.h	/^void	tlb_invalidate(pde_t *pgdir, void *va);$/;"	p	signature:(pde_t *pgdir, void *va)
tlbflush	./inc/x86.h	/^static __inline void tlbflush(void) __attribute__((always_inline));$/;"	p	signature:(void)
tlbflush	./inc/x86.h	/^tlbflush(void)$/;"	f	signature:(void)
trap_init	./kern/trap.h	/^void trap_init(void);$/;"	p	signature:(void)
trap_init_percpu	./kern/trap.h	/^void trap_init_percpu(void);$/;"	p	signature:(void)
true	./inc/types.h	/^enum { false, true };$/;"	e	enum:__anon4
ts_cr3	./inc/mmu.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:Taskstate	access:public
ts_cs	./inc/mmu.h	/^	uint16_t ts_cs;$/;"	m	struct:Taskstate	access:public
ts_ds	./inc/mmu.h	/^	uint16_t ts_ds;$/;"	m	struct:Taskstate	access:public
ts_eax	./inc/mmu.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:Taskstate	access:public
ts_ebp	./inc/mmu.h	/^	uintptr_t ts_ebp;$/;"	m	struct:Taskstate	access:public
ts_ebx	./inc/mmu.h	/^	uint32_t ts_ebx;$/;"	m	struct:Taskstate	access:public
ts_ecx	./inc/mmu.h	/^	uint32_t ts_ecx;$/;"	m	struct:Taskstate	access:public
ts_edi	./inc/mmu.h	/^	uint32_t ts_edi;$/;"	m	struct:Taskstate	access:public
ts_edx	./inc/mmu.h	/^	uint32_t ts_edx;$/;"	m	struct:Taskstate	access:public
ts_eflags	./inc/mmu.h	/^	uint32_t ts_eflags;$/;"	m	struct:Taskstate	access:public
ts_eip	./inc/mmu.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:Taskstate	access:public
ts_es	./inc/mmu.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:Taskstate	access:public
ts_esi	./inc/mmu.h	/^	uint32_t ts_esi;$/;"	m	struct:Taskstate	access:public
ts_esp	./inc/mmu.h	/^	uintptr_t ts_esp;$/;"	m	struct:Taskstate	access:public
ts_esp0	./inc/mmu.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:Taskstate	access:public
ts_esp1	./inc/mmu.h	/^	uintptr_t ts_esp1;$/;"	m	struct:Taskstate	access:public
ts_esp2	./inc/mmu.h	/^	uintptr_t ts_esp2;$/;"	m	struct:Taskstate	access:public
ts_fs	./inc/mmu.h	/^	uint16_t ts_fs;$/;"	m	struct:Taskstate	access:public
ts_gs	./inc/mmu.h	/^	uint16_t ts_gs;$/;"	m	struct:Taskstate	access:public
ts_iomb	./inc/mmu.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:Taskstate	access:public
ts_ldt	./inc/mmu.h	/^	uint16_t ts_ldt;$/;"	m	struct:Taskstate	access:public
ts_link	./inc/mmu.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:Taskstate	access:public
ts_padding1	./inc/mmu.h	/^	uint16_t ts_padding1;$/;"	m	struct:Taskstate	access:public
ts_padding10	./inc/mmu.h	/^	uint16_t ts_padding10;$/;"	m	struct:Taskstate	access:public
ts_padding2	./inc/mmu.h	/^	uint16_t ts_padding2;$/;"	m	struct:Taskstate	access:public
ts_padding3	./inc/mmu.h	/^	uint16_t ts_padding3;$/;"	m	struct:Taskstate	access:public
ts_padding4	./inc/mmu.h	/^	uint16_t ts_padding4;$/;"	m	struct:Taskstate	access:public
ts_padding5	./inc/mmu.h	/^	uint16_t ts_padding5;$/;"	m	struct:Taskstate	access:public
ts_padding6	./inc/mmu.h	/^	uint16_t ts_padding6;$/;"	m	struct:Taskstate	access:public
ts_padding7	./inc/mmu.h	/^	uint16_t ts_padding7;$/;"	m	struct:Taskstate	access:public
ts_padding8	./inc/mmu.h	/^	uint16_t ts_padding8;$/;"	m	struct:Taskstate	access:public
ts_padding9	./inc/mmu.h	/^	uint16_t ts_padding9;$/;"	m	struct:Taskstate	access:public
ts_ss	./inc/mmu.h	/^	uint16_t ts_ss;$/;"	m	struct:Taskstate	access:public
ts_ss0	./inc/mmu.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:Taskstate	access:public
ts_ss1	./inc/mmu.h	/^	uint16_t ts_ss1;$/;"	m	struct:Taskstate	access:public
ts_ss2	./inc/mmu.h	/^	uint16_t ts_ss2;$/;"	m	struct:Taskstate	access:public
ts_t	./inc/mmu.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:Taskstate	access:public
type	./inc/partition.h	/^	uint8_t type;$/;"	m	struct:Partitiondesc	access:public
uint16_t	./inc/types.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	./inc/types.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	./inc/types.h	/^typedef unsigned long long uint64_t;$/;"	t
uint8_t	./inc/types.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	./inc/types.h	/^typedef uint32_t uintptr_t;$/;"	t
umain	./inc/lib.h	/^void	umain(int argc, char **argv);$/;"	p	signature:(int argc, char **argv)
unlock_kernel	./kern/spinlock.h	/^unlock_kernel(void)$/;"	f	signature:(void)
user_mem_assert	./kern/pmap.h	/^void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);$/;"	p	signature:(struct Env *env, const void *va, size_t len, int perm)
user_mem_check	./kern/pmap.h	/^int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);$/;"	p	signature:(struct Env *env, const void *va, size_t len, int perm)
utf_eflags	./inc/trap.h	/^	uint32_t utf_eflags;$/;"	m	struct:UTrapframe	access:public
utf_eip	./inc/trap.h	/^	uintptr_t utf_eip;$/;"	m	struct:UTrapframe	access:public
utf_err	./inc/trap.h	/^	uint32_t utf_err;$/;"	m	struct:UTrapframe	access:public
utf_esp	./inc/trap.h	/^	uintptr_t utf_esp;$/;"	m	struct:UTrapframe	access:public
utf_fault_va	./inc/trap.h	/^	uint32_t utf_fault_va;	\/* va for T_PGFLT, 0 otherwise *\/$/;"	m	struct:UTrapframe	access:public
utf_regs	./inc/trap.h	/^	struct PushRegs utf_regs;$/;"	m	struct:UTrapframe	typeref:struct:UTrapframe::PushRegs	access:public
va_arg	./inc/stdarg.h	10;"	d
va_end	./inc/stdarg.h	12;"	d
va_is_dirty	./fs/fs.h	/^bool	va_is_dirty(void *va);$/;"	p	signature:(void *va)
va_is_mapped	./fs/fs.h	/^bool	va_is_mapped(void *va);$/;"	p	signature:(void *va)
va_list	./inc/stdarg.h	/^typedef __builtin_va_list va_list;$/;"	t
va_start	./inc/stdarg.h	8;"	d
vcprintf	./inc/stdio.h	/^int	vcprintf(const char *fmt, va_list);$/;"	p	signature:(const char *fmt, va_list)
vfprintf	./inc/stdio.h	/^int	vfprintf(int fd, const char *fmt, va_list);$/;"	p	signature:(int fd, const char *fmt, va_list)
vprintfmt	./inc/stdio.h	/^void	vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list);$/;"	p	signature:(void (*putch)(int, void*), void *putdat, const char *fmt, va_list)
vsnprintf	./inc/stdio.h	/^int	vsnprintf(char *str, int size, const char *fmt, va_list);$/;"	p	signature:(char *str, int size, const char *fmt, va_list)
wait	./inc/lib.h	/^void	wait(envid_t env);$/;"	p	signature:(envid_t env)
warn	./inc/assert.h	11;"	d
write	./inc/fs.h	/^	} write;$/;"	m	union:Fsipc	typeref:struct:Fsipc::Fsreq_write	access:public
write	./inc/lib.h	/^ssize_t	write(int fd, const void *buf, size_t nbytes);$/;"	p	signature:(int fd, const void *buf, size_t nbytes)
write_eflags	./inc/x86.h	/^static __inline void write_eflags(uint32_t eflags) __attribute__((always_inline));$/;"	p	signature:(uint32_t eflags)
write_eflags	./inc/x86.h	/^write_eflags(uint32_t eflags)$/;"	f	signature:(uint32_t eflags)
xchg	./inc/x86.h	/^xchg(volatile uint32_t *addr, uint32_t newval)$/;"	f	signature:(volatile uint32_t *addr, uint32_t newval)
