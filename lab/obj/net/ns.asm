
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 eb ed 00 00       	call   80ee1c <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800034 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800034:	55                   	push   %ebp
  800035:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800037:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  80003c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80003f:	c6 80 28 50 81 00 00 	movb   $0x0,0x815028(%eax)
}
  800046:	5d                   	pop    %ebp
  800047:	c3                   	ret    

00800048 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  800048:	55                   	push   %ebp
  800049:	89 e5                	mov    %esp,%ebp
  80004b:	57                   	push   %edi
  80004c:	56                   	push   %esi
  80004d:	53                   	push   %ebx
  80004e:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800057:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80005a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80005d:	0f 87 3a 01 00 00    	ja     80019d <serve_thread+0x155>
  800063:	8b 03                	mov    (%ebx),%eax
  800065:	ff 24 85 24 0b 81 00 	jmp    *0x810b24(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  80006c:	8b 46 04             	mov    0x4(%esi),%eax
  80006f:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800072:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800075:	89 44 24 08          	mov    %eax,0x8(%esp)
  800079:	8d 45 84             	lea    -0x7c(%ebp),%eax
  80007c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800080:	8b 06                	mov    (%esi),%eax
  800082:	89 04 24             	mov    %eax,(%esp)
  800085:	e8 e4 0f 00 00       	call   80106e <lwip_accept>
  80008a:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80008c:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800093:	00 
  800094:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800097:	89 44 24 04          	mov    %eax,0x4(%esp)
  80009b:	89 34 24             	mov    %esi,(%esp)
  80009e:	e8 f1 f5 00 00       	call   80f694 <memmove>
		break;
  8000a3:	e9 13 01 00 00       	jmp    8001bb <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8000a8:	8b 46 14             	mov    0x14(%esi),%eax
  8000ab:	89 44 24 08          	mov    %eax,0x8(%esp)
  8000af:	8d 46 04             	lea    0x4(%esi),%eax
  8000b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000b6:	8b 06                	mov    (%esi),%eax
  8000b8:	89 04 24             	mov    %eax,(%esp)
  8000bb:	e8 69 11 00 00       	call   801229 <lwip_bind>
  8000c0:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  8000c2:	e9 f4 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8000c7:	8b 46 04             	mov    0x4(%esi),%eax
  8000ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000ce:	8b 06                	mov    (%esi),%eax
  8000d0:	89 04 24             	mov    %eax,(%esp)
  8000d3:	e8 83 1d 00 00       	call   801e5b <lwip_shutdown>
  8000d8:	89 c7                	mov    %eax,%edi
		break;
  8000da:	e9 dc 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  8000df:	8b 06                	mov    (%esi),%eax
  8000e1:	89 04 24             	mov    %eax,(%esp)
  8000e4:	e8 fe 11 00 00       	call   8012e7 <lwip_close>
  8000e9:	89 c7                	mov    %eax,%edi
		break;
  8000eb:	e9 cb 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  8000f0:	8b 46 14             	mov    0x14(%esi),%eax
  8000f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8000f7:	8d 46 04             	lea    0x4(%esi),%eax
  8000fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000fe:	8b 06                	mov    (%esi),%eax
  800100:	89 04 24             	mov    %eax,(%esp)
  800103:	e8 5d 12 00 00       	call   801365 <lwip_connect>
  800108:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80010a:	e9 ac 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80010f:	8b 46 04             	mov    0x4(%esi),%eax
  800112:	89 44 24 04          	mov    %eax,0x4(%esp)
  800116:	8b 06                	mov    (%esi),%eax
  800118:	89 04 24             	mov    %eax,(%esp)
  80011b:	e8 03 13 00 00       	call   801423 <lwip_listen>
  800120:	89 c7                	mov    %eax,%edi
		break;
  800122:	e9 94 00 00 00       	jmp    8001bb <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800127:	8b 46 08             	mov    0x8(%esi),%eax
  80012a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80012e:	8b 46 04             	mov    0x4(%esi),%eax
  800131:	89 44 24 08          	mov    %eax,0x8(%esp)
  800135:	89 74 24 04          	mov    %esi,0x4(%esp)
  800139:	8b 06                	mov    (%esi),%eax
  80013b:	89 04 24             	mov    %eax,(%esp)
  80013e:	e8 0c 16 00 00       	call   80174f <lwip_recv>
  800143:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  800145:	eb 74                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  800147:	8b 46 08             	mov    0x8(%esi),%eax
  80014a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80014e:	8b 46 04             	mov    0x4(%esi),%eax
  800151:	89 44 24 08          	mov    %eax,0x8(%esp)
  800155:	8d 46 0c             	lea    0xc(%esi),%eax
  800158:	89 44 24 04          	mov    %eax,0x4(%esp)
  80015c:	8b 06                	mov    (%esi),%eax
  80015e:	89 04 24             	mov    %eax,(%esp)
  800161:	e8 9a 17 00 00       	call   801900 <lwip_send>
  800166:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800168:	eb 51                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  80016a:	8b 46 08             	mov    0x8(%esi),%eax
  80016d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800171:	8b 46 04             	mov    0x4(%esi),%eax
  800174:	89 44 24 04          	mov    %eax,0x4(%esp)
  800178:	8b 06                	mov    (%esi),%eax
  80017a:	89 04 24             	mov    %eax,(%esp)
  80017d:	e8 34 18 00 00       	call   8019b6 <lwip_socket>
  800182:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800184:	eb 35                	jmp    8001bb <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800186:	89 74 24 04          	mov    %esi,0x4(%esp)
  80018a:	c7 04 24 40 b2 b3 00 	movl   $0xb3b240,(%esp)
  800191:	e8 09 b1 00 00       	call   80b29f <jif_input>
		r = 0;
  800196:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  80019b:	eb 4c                	jmp    8001e9 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80019d:	89 74 24 08          	mov    %esi,0x8(%esp)
  8001a1:	8b 43 04             	mov    0x4(%ebx),%eax
  8001a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001a8:	c7 04 24 40 09 81 00 	movl   $0x810940,(%esp)
  8001af:	e8 bc ed 00 00       	call   80ef70 <cprintf>
		r = -E_INVAL;
  8001b4:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  8001b9:	eb 2e                	jmp    8001e9 <serve_thread+0x1a1>
	}

	if (r == -1) {
  8001bb:	83 ff ff             	cmp    $0xffffffff,%edi
  8001be:	75 29                	jne    8001e9 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  8001c0:	8b 03                	mov    (%ebx),%eax
  8001c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001c6:	c7 44 24 08 75 0a 81 	movl   $0x810a75,0x8(%esp)
  8001cd:	00 
  8001ce:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  8001d5:	00 
  8001d6:	8d 75 84             	lea    -0x7c(%ebp),%esi
  8001d9:	89 34 24             	mov    %esi,(%esp)
  8001dc:	e8 dc f2 00 00       	call   80f4bd <snprintf>
		perror(buf);
  8001e1:	89 34 24             	mov    %esi,(%esp)
  8001e4:	e8 6e af 00 00       	call   80b157 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  8001e9:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8001ec:	74 1f                	je     80020d <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  8001ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8001f5:	00 
  8001f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8001fd:	00 
  8001fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800202:	8b 43 04             	mov    0x4(%ebx),%eax
  800205:	89 04 24             	mov    %eax,(%esp)
  800208:	e8 54 fe 00 00       	call   810061 <ipc_send>

	put_buffer(args->req);
  80020d:	8b 43 08             	mov    0x8(%ebx),%eax
  800210:	e8 1f fe ff ff       	call   800034 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  800215:	8b 43 08             	mov    0x8(%ebx),%eax
  800218:	89 44 24 04          	mov    %eax,0x4(%esp)
  80021c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800223:	e8 8c f7 00 00       	call   80f9b4 <sys_page_unmap>
	free(args);
  800228:	89 1c 24             	mov    %ebx,(%esp)
  80022b:	e8 90 01 01 00       	call   8103c0 <free>
}
  800230:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  800236:	5b                   	pop    %ebx
  800237:	5e                   	pop    %esi
  800238:	5f                   	pop    %edi
  800239:	5d                   	pop    %ebp
  80023a:	c3                   	ret    

0080023b <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  80023b:	55                   	push   %ebp
  80023c:	89 e5                	mov    %esp,%ebp
  80023e:	56                   	push   %esi
  80023f:	53                   	push   %ebx
  800240:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  800243:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  800246:	e8 2a f9 00 00       	call   80fb75 <sys_time_msec>
  80024b:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  80024d:	e8 1e ab 00 00       	call   80ad70 <lwip_core_lock>
		t->func();
  800252:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800255:	e8 1b ab 00 00       	call   80ad75 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  80025a:	03 33                	add    (%ebx),%esi
  80025c:	89 74 24 08          	mov    %esi,0x8(%esp)
  800260:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800267:	00 
  800268:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80026f:	e8 1c ae 00 00       	call   80b090 <thread_wait>
  800274:	eb d0                	jmp    800246 <net_timer+0xb>

00800276 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800276:	55                   	push   %ebp
  800277:	89 e5                	mov    %esp,%ebp
  800279:	53                   	push   %ebx
  80027a:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80027d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800280:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800282:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800285:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800288:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80028c:	c7 44 24 08 3b 02 80 	movl   $0x80023b,0x8(%esp)
  800293:	00 
  800294:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800298:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80029f:	e8 71 ab 00 00       	call   80ae15 <thread_create>
	if (r < 0)
  8002a4:	85 c0                	test   %eax,%eax
  8002a6:	79 28                	jns    8002d0 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  8002a8:	89 04 24             	mov    %eax,(%esp)
  8002ab:	e8 98 ae 00 00       	call   80b148 <e2s>
  8002b0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002b4:	c7 44 24 08 64 09 81 	movl   $0x810964,0x8(%esp)
  8002bb:	00 
  8002bc:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8002c3:	00 
  8002c4:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  8002cb:	e8 a8 eb 00 00       	call   80ee78 <_panic>
}
  8002d0:	83 c4 14             	add    $0x14,%esp
  8002d3:	5b                   	pop    %ebx
  8002d4:	5d                   	pop    %ebp
  8002d5:	c3                   	ret    

008002d6 <tcpip_init_done>:

static void
tcpip_init_done(void *arg)
{
  8002d6:	55                   	push   %ebp
  8002d7:	89 e5                	mov    %esp,%ebp
  8002d9:	83 ec 18             	sub    $0x18,%esp
  8002dc:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  8002df:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  8002e5:	89 04 24             	mov    %eax,(%esp)
  8002e8:	e8 be aa 00 00       	call   80adab <thread_wakeup>
}
  8002ed:	c9                   	leave  
  8002ee:	c3                   	ret    

008002ef <serve_init>:

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002ef:	55                   	push   %ebp
  8002f0:	89 e5                	mov    %esp,%ebp
  8002f2:	56                   	push   %esi
  8002f3:	53                   	push   %ebx
  8002f4:	83 ec 30             	sub    $0x30,%esp
  8002f7:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  8002fa:	e8 71 aa 00 00       	call   80ad70 <lwip_core_lock>

	uint32_t done = 0;
  8002ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800306:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800309:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80030d:	c7 04 24 d6 02 80 00 	movl   $0x8002d6,(%esp)
  800314:	e8 20 24 00 00       	call   802739 <tcpip_init>
	lwip_core_unlock();
  800319:	e8 57 aa 00 00       	call   80ad75 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80031e:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800325:	ff 
  800326:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80032d:	00 
  80032e:	89 1c 24             	mov    %ebx,(%esp)
  800331:	e8 5a ad 00 00       	call   80b090 <thread_wait>
	lwip_core_lock();
  800336:	e8 35 aa 00 00       	call   80ad70 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  80033b:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  80033e:	8b 45 0c             	mov    0xc(%ebp),%eax
  800341:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800344:	8b 45 10             	mov    0x10(%ebp),%eax
  800347:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  80034a:	c7 44 24 18 57 6a 80 	movl   $0x806a57,0x18(%esp)
  800351:	00 
  800352:	c7 44 24 14 a7 b3 80 	movl   $0x80b3a7,0x14(%esp)
  800359:	00 
  80035a:	c7 44 24 10 00 50 81 	movl   $0x815000,0x10(%esp)
  800361:	00 
  800362:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800369:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80036c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 04          	mov    %eax,0x4(%esp)
  800377:	c7 04 24 40 b2 b3 00 	movl   $0xb3b240,(%esp)
  80037e:	e8 d6 47 00 00       	call   804b59 <netif_add>
  800383:	85 c0                	test   %eax,%eax
  800385:	75 1c                	jne    8003a3 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800387:	c7 44 24 08 84 09 81 	movl   $0x810984,0x8(%esp)
  80038e:	00 
  80038f:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800396:	00 
  800397:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  80039e:	e8 d5 ea 00 00       	call   80ee78 <_panic>

	netif_set_default(nif);
  8003a3:	c7 04 24 40 b2 b3 00 	movl   $0xb3b240,(%esp)
  8003aa:	e8 31 48 00 00       	call   804be0 <netif_set_default>
	netif_set_up(nif);
  8003af:	c7 04 24 40 b2 b3 00 	movl   $0xb3b240,(%esp)
  8003b6:	e8 7b 48 00 00       	call   804c36 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003bb:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003c2:	b9 8f 0a 81 00       	mov    $0x810a8f,%ecx
  8003c7:	ba b5 9b 80 00       	mov    $0x809bb5,%edx
  8003cc:	b8 04 50 81 00       	mov    $0x815004,%eax
  8003d1:	e8 a0 fe ff ff       	call   800276 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003d6:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003dd:	b9 99 0a 81 00       	mov    $0x810a99,%ecx
  8003e2:	ba 70 5c 80 00       	mov    $0x805c70,%edx
  8003e7:	b8 10 50 81 00       	mov    $0x815010,%eax
  8003ec:	e8 85 fe ff ff       	call   800276 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003f1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8003f8:	b9 a5 0a 81 00       	mov    $0x810aa5,%ecx
  8003fd:	ba 9b 60 80 00       	mov    $0x80609b,%edx
  800402:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800407:	e8 6a fe ff ff       	call   800276 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80040c:	89 34 24             	mov    %esi,(%esp)
  80040f:	e8 c4 77 00 00       	call   807bd8 <inet_ntoa>
  800414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800418:	0f b6 05 6a b2 b3 00 	movzbl 0xb3b26a,%eax
  80041f:	89 44 24 18          	mov    %eax,0x18(%esp)
  800423:	0f b6 05 69 b2 b3 00 	movzbl 0xb3b269,%eax
  80042a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80042e:	0f b6 05 68 b2 b3 00 	movzbl 0xb3b268,%eax
  800435:	89 44 24 10          	mov    %eax,0x10(%esp)
  800439:	0f b6 05 67 b2 b3 00 	movzbl 0xb3b267,%eax
  800440:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800444:	0f b6 05 66 b2 b3 00 	movzbl 0xb3b266,%eax
  80044b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80044f:	0f b6 05 65 b2 b3 00 	movzbl 0xb3b265,%eax
  800456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80045a:	c7 04 24 a4 09 81 00 	movl   $0x8109a4,(%esp)
  800461:	e8 0a eb 00 00       	call   80ef70 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  800466:	e8 0a a9 00 00       	call   80ad75 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  80046b:	c7 04 24 b1 0a 81 00 	movl   $0x810ab1,(%esp)
  800472:	e8 f9 ea 00 00       	call   80ef70 <cprintf>
}
  800477:	83 c4 30             	add    $0x30,%esp
  80047a:	5b                   	pop    %ebx
  80047b:	5e                   	pop    %esi
  80047c:	5d                   	pop    %ebp
  80047d:	c3                   	ret    

0080047e <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80047e:	55                   	push   %ebp
  80047f:	89 e5                	mov    %esp,%ebp
  800481:	57                   	push   %edi
  800482:	56                   	push   %esi
  800483:	53                   	push   %ebx
  800484:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800487:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80048c:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80048f:	eb 06                	jmp    800497 <serve+0x19>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  800491:	e8 cb aa 00 00       	call   80af61 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800496:	43                   	inc    %ebx
  800497:	e8 2e a9 00 00       	call   80adca <thread_wakeups_pending>
  80049c:	85 c0                	test   %eax,%eax
  80049e:	74 05                	je     8004a5 <serve+0x27>
  8004a0:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a3:	7e ec                	jle    800491 <serve+0x13>
			thread_yield();

		perm = 0;
  8004a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ac:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8004b1:	80 b8 28 50 81 00 00 	cmpb   $0x0,0x815028(%eax)
  8004b8:	74 08                	je     8004c2 <serve+0x44>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ba:	40                   	inc    %eax
  8004bb:	83 f8 14             	cmp    $0x14,%eax
  8004be:	75 f1                	jne    8004b1 <serve+0x33>
  8004c0:	eb 05                	jmp    8004c7 <serve+0x49>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004c2:	83 f8 14             	cmp    $0x14,%eax
  8004c5:	75 1c                	jne    8004e3 <serve+0x65>
		panic("NS: buffer overflow");
  8004c7:	c7 44 24 08 ca 0a 81 	movl   $0x810aca,0x8(%esp)
  8004ce:	00 
  8004cf:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8004d6:	00 
  8004d7:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  8004de:	e8 95 e9 00 00       	call   80ee78 <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004e3:	8d b0 eb ff 00 00    	lea    0xffeb(%eax),%esi
  8004e9:	c1 e6 0c             	shl    $0xc,%esi
	buse[i] = 1;
  8004ec:	c6 80 28 50 81 00 01 	movb   $0x1,0x815028(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8004f3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8004f7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8004fb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8004fe:	89 04 24             	mov    %eax,(%esp)
  800501:	e8 f2 fa 00 00       	call   80fff8 <ipc_recv>
  800506:	89 c3                	mov    %eax,%ebx
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800508:	83 f8 0c             	cmp    $0xc,%eax
  80050b:	75 67                	jne    800574 <serve+0xf6>
			process_timer(whom);
  80050d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800510:	3b 1d 3c 50 81 00    	cmp    0x81503c,%ebx
  800516:	74 12                	je     80052a <serve+0xac>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800518:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80051c:	c7 04 24 e0 09 81 00 	movl   $0x8109e0,(%esp)
  800523:	e8 48 ea 00 00       	call   80ef70 <cprintf>
  800528:	eb 39                	jmp    800563 <serve+0xe5>
		return;
	}

	start = sys_time_msec();
  80052a:	e8 46 f6 00 00       	call   80fb75 <sys_time_msec>
  80052f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800532:	e8 2a aa 00 00       	call   80af61 <thread_yield>
	now = sys_time_msec();
  800537:	e8 39 f6 00 00       	call   80fb75 <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80053c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800543:	00 
  800544:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80054b:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  80054c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80054f:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800555:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800557:	89 54 24 04          	mov    %edx,0x4(%esp)
  80055b:	89 1c 24             	mov    %ebx,(%esp)
  80055e:	e8 fe fa 00 00       	call   810061 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800563:	89 f0                	mov    %esi,%eax
  800565:	e8 ca fa ff ff       	call   800034 <put_buffer>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80056a:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  80056f:	e9 23 ff ff ff       	jmp    800497 <serve+0x19>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800574:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800578:	75 1d                	jne    800597 <serve+0x119>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80057a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80057d:	89 44 24 04          	mov    %eax,0x4(%esp)
  800581:	c7 04 24 1c 0a 81 00 	movl   $0x810a1c,(%esp)
  800588:	e8 e3 e9 00 00       	call   80ef70 <cprintf>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80058d:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  800592:	e9 00 ff ff ff       	jmp    800497 <serve+0x19>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800597:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80059e:	e8 ed fe 00 00       	call   810490 <malloc>
		if (!args)
  8005a3:	85 c0                	test   %eax,%eax
  8005a5:	75 1c                	jne    8005c3 <serve+0x145>
			panic("could not allocate thread args structure");
  8005a7:	c7 44 24 08 4c 0a 81 	movl   $0x810a4c,0x8(%esp)
  8005ae:	00 
  8005af:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
  8005b6:	00 
  8005b7:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  8005be:	e8 b5 e8 00 00       	call   80ee78 <_panic>

		args->reqno = reqno;
  8005c3:	89 18                	mov    %ebx,(%eax)
		args->whom = whom;
  8005c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005c8:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8005cb:	89 70 08             	mov    %esi,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005d2:	c7 44 24 08 48 00 80 	movl   $0x800048,0x8(%esp)
  8005d9:	00 
  8005da:	c7 44 24 04 de 0a 81 	movl   $0x810ade,0x4(%esp)
  8005e1:	00 
  8005e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005e9:	e8 27 a8 00 00       	call   80ae15 <thread_create>
		thread_yield(); // let the thread created run
  8005ee:	e8 6e a9 00 00       	call   80af61 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8005f3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8005f8:	e9 9a fe ff ff       	jmp    800497 <serve+0x19>

008005fd <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  8005fd:	55                   	push   %ebp
  8005fe:	89 e5                	mov    %esp,%ebp
  800600:	56                   	push   %esi
  800601:	53                   	push   %ebx
  800602:	83 ec 10             	sub    $0x10,%esp
	serve_init(inet_addr(IP),
  800605:	c7 04 24 eb 0a 81 00 	movl   $0x810aeb,(%esp)
  80060c:	e8 ba 78 00 00       	call   807ecb <inet_addr>
  800611:	89 c3                	mov    %eax,%ebx
  800613:	c7 04 24 f4 0a 81 00 	movl   $0x810af4,(%esp)
  80061a:	e8 ac 78 00 00       	call   807ecb <inet_addr>
  80061f:	89 c6                	mov    %eax,%esi
  800621:	c7 04 24 02 0b 81 00 	movl   $0x810b02,(%esp)
  800628:	e8 9e 78 00 00       	call   807ecb <inet_addr>
  80062d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800631:	89 74 24 04          	mov    %esi,0x4(%esp)
  800635:	89 04 24             	mov    %eax,(%esp)
  800638:	e8 b2 fc ff ff       	call   8002ef <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80063d:	e8 3c fe ff ff       	call   80047e <serve>

00800642 <umain>:
}

void
umain(int argc, char **argv)
{
  800642:	55                   	push   %ebp
  800643:	89 e5                	mov    %esp,%ebp
  800645:	53                   	push   %ebx
  800646:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800649:	e8 81 f2 00 00       	call   80f8cf <sys_getenvid>
  80064e:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800650:	c7 05 e8 42 81 00 0c 	movl   $0x810b0c,0x8142e8
  800657:	0b 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  80065a:	e8 a8 f6 00 00       	call   80fd07 <fork>
  80065f:	a3 3c 50 81 00       	mov    %eax,0x81503c
	if (timer_envid < 0)
  800664:	85 c0                	test   %eax,%eax
  800666:	79 1c                	jns    800684 <umain+0x42>
		panic("error forking");
  800668:	c7 44 24 08 0f 0b 81 	movl   $0x810b0f,0x8(%esp)
  80066f:	00 
  800670:	c7 44 24 04 44 01 00 	movl   $0x144,0x4(%esp)
  800677:	00 
  800678:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  80067f:	e8 f4 e7 00 00       	call   80ee78 <_panic>
	else if (timer_envid == 0) {
  800684:	85 c0                	test   %eax,%eax
  800686:	75 15                	jne    80069d <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  800688:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80068f:	00 
  800690:	89 1c 24             	mov    %ebx,(%esp)
  800693:	e8 ac 00 00 00       	call   800744 <timer>
		return;
  800698:	e9 9e 00 00 00       	jmp    80073b <umain+0xf9>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  80069d:	e8 65 f6 00 00       	call   80fd07 <fork>
  8006a2:	a3 40 50 81 00       	mov    %eax,0x815040
	if (input_envid < 0)
  8006a7:	85 c0                	test   %eax,%eax
  8006a9:	79 1c                	jns    8006c7 <umain+0x85>
		panic("error forking");
  8006ab:	c7 44 24 08 0f 0b 81 	movl   $0x810b0f,0x8(%esp)
  8006b2:	00 
  8006b3:	c7 44 24 04 4e 01 00 	movl   $0x14e,0x4(%esp)
  8006ba:	00 
  8006bb:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  8006c2:	e8 b1 e7 00 00       	call   80ee78 <_panic>
	else if (input_envid == 0) {
  8006c7:	85 c0                	test   %eax,%eax
  8006c9:	75 0a                	jne    8006d5 <umain+0x93>
		input(ns_envid);
  8006cb:	89 1c 24             	mov    %ebx,(%esp)
  8006ce:	e8 2d 01 00 00       	call   800800 <input>
		return;
  8006d3:	eb 66                	jmp    80073b <umain+0xf9>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8006d5:	e8 2d f6 00 00       	call   80fd07 <fork>
  8006da:	a3 00 50 81 00       	mov    %eax,0x815000
	if (output_envid < 0)
  8006df:	85 c0                	test   %eax,%eax
  8006e1:	79 1c                	jns    8006ff <umain+0xbd>
		panic("error forking");
  8006e3:	c7 44 24 08 0f 0b 81 	movl   $0x810b0f,0x8(%esp)
  8006ea:	00 
  8006eb:	c7 44 24 04 58 01 00 	movl   $0x158,0x4(%esp)
  8006f2:	00 
  8006f3:	c7 04 24 84 0a 81 00 	movl   $0x810a84,(%esp)
  8006fa:	e8 79 e7 00 00       	call   80ee78 <_panic>
	else if (output_envid == 0) {
  8006ff:	85 c0                	test   %eax,%eax
  800701:	75 0a                	jne    80070d <umain+0xcb>
		output(ns_envid);
  800703:	89 1c 24             	mov    %ebx,(%esp)
  800706:	e8 ad 01 00 00       	call   8008b8 <output>
		return;
  80070b:	eb 2e                	jmp    80073b <umain+0xf9>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80070d:	e8 6a a6 00 00       	call   80ad7c <thread_init>
	thread_create(0, "main", tmain, 0);
  800712:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800719:	00 
  80071a:	c7 44 24 08 fd 05 80 	movl   $0x8005fd,0x8(%esp)
  800721:	00 
  800722:	c7 44 24 04 1d 0b 81 	movl   $0x810b1d,0x4(%esp)
  800729:	00 
  80072a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800731:	e8 df a6 00 00       	call   80ae15 <thread_create>
	thread_yield();
  800736:	e8 26 a8 00 00       	call   80af61 <thread_yield>
	// never coming here!
}
  80073b:	83 c4 14             	add    $0x14,%esp
  80073e:	5b                   	pop    %ebx
  80073f:	5d                   	pop    %ebp
  800740:	c3                   	ret    
  800741:	00 00                	add    %al,(%eax)
	...

00800744 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800744:	55                   	push   %ebp
  800745:	89 e5                	mov    %esp,%ebp
  800747:	57                   	push   %edi
  800748:	56                   	push   %esi
  800749:	53                   	push   %ebx
  80074a:	83 ec 2c             	sub    $0x2c,%esp
  80074d:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800750:	e8 20 f4 00 00       	call   80fb75 <sys_time_msec>
  800755:	89 c3                	mov    %eax,%ebx
  800757:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  80075a:	c7 05 e8 42 81 00 50 	movl   $0x810b50,0x8142e8
  800761:	0b 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800764:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800767:	eb 05                	jmp    80076e <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800769:	e8 80 f1 00 00       	call   80f8ee <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80076e:	e8 02 f4 00 00       	call   80fb75 <sys_time_msec>
  800773:	39 c3                	cmp    %eax,%ebx
  800775:	76 06                	jbe    80077d <timer+0x39>
  800777:	85 c0                	test   %eax,%eax
  800779:	79 ee                	jns    800769 <timer+0x25>
  80077b:	eb 04                	jmp    800781 <timer+0x3d>
			sys_yield();
		}
		if (r < 0)
  80077d:	85 c0                	test   %eax,%eax
  80077f:	79 20                	jns    8007a1 <timer+0x5d>
			panic("sys_time_msec: %e", r);
  800781:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800785:	c7 44 24 08 59 0b 81 	movl   $0x810b59,0x8(%esp)
  80078c:	00 
  80078d:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  800794:	00 
  800795:	c7 04 24 6b 0b 81 00 	movl   $0x810b6b,(%esp)
  80079c:	e8 d7 e6 00 00       	call   80ee78 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007a8:	00 
  8007a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007b0:	00 
  8007b1:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007b8:	00 
  8007b9:	89 3c 24             	mov    %edi,(%esp)
  8007bc:	e8 a0 f8 00 00       	call   810061 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c8:	00 
  8007c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007d0:	00 
  8007d1:	89 34 24             	mov    %esi,(%esp)
  8007d4:	e8 1f f8 00 00       	call   80fff8 <ipc_recv>
  8007d9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8007db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007de:	39 c7                	cmp    %eax,%edi
  8007e0:	74 12                	je     8007f4 <timer+0xb0>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007e6:	c7 04 24 78 0b 81 00 	movl   $0x810b78,(%esp)
  8007ed:	e8 7e e7 00 00       	call   80ef70 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  8007f2:	eb cd                	jmp    8007c1 <timer+0x7d>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8007f4:	e8 7c f3 00 00       	call   80fb75 <sys_time_msec>
  8007f9:	01 c3                	add    %eax,%ebx
			break;
		}
	}
  8007fb:	e9 6e ff ff ff       	jmp    80076e <timer+0x2a>

00800800 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800800:	55                   	push   %ebp
  800801:	89 e5                	mov    %esp,%ebp
  800803:	57                   	push   %edi
  800804:	56                   	push   %esi
  800805:	53                   	push   %ebx
  800806:	81 ec 2c 08 00 00    	sub    $0x82c,%esp
  80080c:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  80080f:	c7 05 e8 42 81 00 b3 	movl   $0x810bb3,0x8142e8
  800816:	0b 81 00 
	int perm = PTE_P | PTE_W | PTE_U;
	size_t length;
	char pkt[PKT_SIZE];

	while (1) {
		while (sys_e1000_receive(pkt, &length) == -E_E1000_RXBUF_EMPTY)
  800819:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  80081c:	8d 9d e4 f7 ff ff    	lea    -0x81c(%ebp),%ebx
  800822:	89 74 24 04          	mov    %esi,0x4(%esp)
  800826:	89 1c 24             	mov    %ebx,(%esp)
  800829:	e8 87 f3 00 00       	call   80fbb5 <sys_e1000_receive>
  80082e:	83 f8 ef             	cmp    $0xffffffef,%eax
  800831:	74 ef                	je     800822 <input+0x22>
		  ;

		int r;
		if ((r = sys_page_alloc(0, &nsipcbuf, perm)) < 0)
  800833:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80083a:	00 
  80083b:	c7 44 24 04 00 c0 b3 	movl   $0xb3c000,0x4(%esp)
  800842:	00 
  800843:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80084a:	e8 be f0 00 00       	call   80f90d <sys_page_alloc>
  80084f:	85 c0                	test   %eax,%eax
  800851:	79 20                	jns    800873 <input+0x73>
		  panic("input: unable to allocate new page, error %e\n", r);
  800853:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800857:	c7 44 24 08 c8 0b 81 	movl   $0x810bc8,0x8(%esp)
  80085e:	00 
  80085f:	c7 44 24 04 1c 00 00 	movl   $0x1c,0x4(%esp)
  800866:	00 
  800867:	c7 04 24 bc 0b 81 00 	movl   $0x810bbc,(%esp)
  80086e:	e8 05 e6 00 00       	call   80ee78 <_panic>

		memmove(nsipcbuf.pkt.jp_data, pkt, length);
  800873:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800876:	89 44 24 08          	mov    %eax,0x8(%esp)
  80087a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80087e:	c7 04 24 04 c0 b3 00 	movl   $0xb3c004,(%esp)
  800885:	e8 0a ee 00 00       	call   80f694 <memmove>
		nsipcbuf.pkt.jp_len = length;
  80088a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80088d:	a3 00 c0 b3 00       	mov    %eax,0xb3c000

		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, perm);
  800892:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  800899:	00 
  80089a:	c7 44 24 08 00 c0 b3 	movl   $0xb3c000,0x8(%esp)
  8008a1:	00 
  8008a2:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008a9:	00 
  8008aa:	89 3c 24             	mov    %edi,(%esp)
  8008ad:	e8 af f7 00 00       	call   810061 <ipc_send>
	}
  8008b2:	e9 6b ff ff ff       	jmp    800822 <input+0x22>
	...

008008b8 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008b8:	55                   	push   %ebp
  8008b9:	89 e5                	mov    %esp,%ebp
  8008bb:	57                   	push   %edi
  8008bc:	56                   	push   %esi
  8008bd:	53                   	push   %ebx
  8008be:	83 ec 2c             	sub    $0x2c,%esp
  8008c1:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_output";
  8008c4:	c7 05 e8 42 81 00 f6 	movl   $0x810bf6,0x8142e8
  8008cb:	0b 81 00 
	//	- send the packet to the device driver
	int r;
	int perm;
	envid_t sender_envid;
	while(1){
		r = ipc_recv(&sender_envid, (void*)&nsipcbuf, &perm);
  8008ce:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  8008d1:	8d 75 e0             	lea    -0x20(%ebp),%esi
  8008d4:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8008d8:	c7 44 24 04 00 c0 b3 	movl   $0xb3c000,0x4(%esp)
  8008df:	00 
  8008e0:	89 34 24             	mov    %esi,(%esp)
  8008e3:	e8 10 f7 00 00       	call   80fff8 <ipc_recv>
		if (r < 0 || (uint32_t*)sender_envid == 0){
  8008e8:	85 c0                	test   %eax,%eax
  8008ea:	78 07                	js     8008f3 <output+0x3b>
  8008ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8008ef:	85 d2                	test   %edx,%edx
  8008f1:	75 12                	jne    800905 <output+0x4d>
			cprintf("output: ipc_recv failed, %e", r);
  8008f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8008f7:	c7 04 24 00 0c 81 00 	movl   $0x810c00,(%esp)
  8008fe:	e8 6d e6 00 00       	call   80ef70 <cprintf>
			continue;
  800903:	eb cf                	jmp    8008d4 <output+0x1c>
		}

		if (sender_envid != ns_envid) {
  800905:	39 fa                	cmp    %edi,%edx
  800907:	74 16                	je     80091f <output+0x67>
			cprintf("output: receive from %08x, expect to receive from %08x", sender_envid, ns_envid);
  800909:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80090d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800911:	c7 04 24 38 0c 81 00 	movl   $0x810c38,(%esp)
  800918:	e8 53 e6 00 00       	call   80ef70 <cprintf>
			continue;
  80091d:	eb b5                	jmp    8008d4 <output+0x1c>
		}
		
		if (!(perm & PTE_P)){
  80091f:	f6 45 e4 01          	testb  $0x1,-0x1c(%ebp)
  800923:	75 0e                	jne    800933 <output+0x7b>
			cprintf("output: permission failed");
  800925:	c7 04 24 1c 0c 81 00 	movl   $0x810c1c,(%esp)
  80092c:	e8 3f e6 00 00       	call   80ef70 <cprintf>
			continue;
  800931:	eb a1                	jmp    8008d4 <output+0x1c>
		}

		if ((r = sys_e1000_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0){
  800933:	a1 00 c0 b3 00       	mov    0xb3c000,%eax
  800938:	89 44 24 04          	mov    %eax,0x4(%esp)
  80093c:	c7 04 24 04 c0 b3 00 	movl   $0xb3c004,(%esp)
  800943:	e8 4c f2 00 00       	call   80fb94 <sys_e1000_transmit>
  800948:	85 c0                	test   %eax,%eax
  80094a:	79 88                	jns    8008d4 <output+0x1c>
			cprintf("output: sys_e1000_transmit failed, %e", r);
  80094c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800950:	c7 04 24 70 0c 81 00 	movl   $0x810c70,(%esp)
  800957:	e8 14 e6 00 00       	call   80ef70 <cprintf>
  80095c:	e9 73 ff ff ff       	jmp    8008d4 <output+0x1c>
  800961:	00 00                	add    %al,(%eax)
	...

00800964 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800964:	55                   	push   %ebp
  800965:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800967:	83 f8 1f             	cmp    $0x1f,%eax
  80096a:	76 11                	jbe    80097d <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  80096c:	c7 05 20 b2 b3 00 09 	movl   $0x9,0xb3b220
  800973:	00 00 00 
    return NULL;
  800976:	b8 00 00 00 00       	mov    $0x0,%eax
  80097b:	eb 24                	jmp    8009a1 <get_socket+0x3d>
  }

  sock = &sockets[s];
  80097d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  800980:	c1 e2 02             	shl    $0x2,%edx
  800983:	8d 82 80 50 81 00    	lea    0x815080(%edx),%eax

  if (!sock->conn) {
  800989:	83 ba 80 50 81 00 00 	cmpl   $0x0,0x815080(%edx)
  800990:	75 0f                	jne    8009a1 <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  800992:	c7 05 20 b2 b3 00 09 	movl   $0x9,0xb3b220
  800999:	00 00 00 
    return NULL;
  80099c:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  8009a1:	5d                   	pop    %ebp
  8009a2:	c3                   	ret    

008009a3 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  8009a3:	55                   	push   %ebp
  8009a4:	89 e5                	mov    %esp,%ebp
  8009a6:	53                   	push   %ebx
  8009a7:	83 ec 14             	sub    $0x14,%esp
  8009aa:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8009ad:	85 c0                	test   %eax,%eax
  8009af:	75 1c                	jne    8009cd <lwip_setsockopt_internal+0x2a>
  8009b1:	c7 44 24 08 96 0c 81 	movl   $0x810c96,0x8(%esp)
  8009b8:	00 
  8009b9:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  8009c0:	00 
  8009c1:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  8009c8:	e8 ab e4 00 00       	call   80ee78 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8009cd:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8009cf:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8009d2:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  8009d5:	8b 40 08             	mov    0x8(%eax),%eax
  8009d8:	83 f8 06             	cmp    $0x6,%eax
  8009db:	0f 84 80 00 00 00    	je     800a61 <lwip_setsockopt_internal+0xbe>
  8009e1:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8009e6:	74 09                	je     8009f1 <lwip_setsockopt_internal+0x4e>
  8009e8:	85 c0                	test   %eax,%eax
  8009ea:	74 53                	je     800a3f <lwip_setsockopt_internal+0x9c>
  8009ec:	e9 a4 00 00 00       	jmp    800a95 <lwip_setsockopt_internal+0xf2>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8009f1:	83 f9 20             	cmp    $0x20,%ecx
  8009f4:	74 11                	je     800a07 <lwip_setsockopt_internal+0x64>
  8009f6:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  8009fc:	74 26                	je     800a24 <lwip_setsockopt_internal+0x81>
  8009fe:	83 f9 08             	cmp    $0x8,%ecx
  800a01:	0f 85 8e 00 00 00    	jne    800a95 <lwip_setsockopt_internal+0xf2>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800a07:	83 3b 00             	cmpl   $0x0,(%ebx)
  800a0a:	74 0b                	je     800a17 <lwip_setsockopt_internal+0x74>
        sock->conn->pcb.ip->so_options |= optname;
  800a0c:	8b 02                	mov    (%edx),%eax
  800a0e:	8b 40 08             	mov    0x8(%eax),%eax
  800a11:	66 09 48 08          	or     %cx,0x8(%eax)
  800a15:	eb 7e                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800a17:	8b 02                	mov    (%edx),%eax
  800a19:	8b 40 08             	mov    0x8(%eax),%eax
  800a1c:	f7 d1                	not    %ecx
  800a1e:	66 21 48 08          	and    %cx,0x8(%eax)
  800a22:	eb 71                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800a24:	83 3b 00             	cmpl   $0x0,(%ebx)
  800a27:	74 0b                	je     800a34 <lwip_setsockopt_internal+0x91>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800a29:	8b 02                	mov    (%edx),%eax
  800a2b:	8b 40 08             	mov    0x8(%eax),%eax
  800a2e:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800a32:	eb 61                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800a34:	8b 02                	mov    (%edx),%eax
  800a36:	8b 40 08             	mov    0x8(%eax),%eax
  800a39:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800a3d:	eb 56                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800a3f:	83 f9 01             	cmp    $0x1,%ecx
  800a42:	74 11                	je     800a55 <lwip_setsockopt_internal+0xb2>
  800a44:	83 f9 02             	cmp    $0x2,%ecx
  800a47:	75 4c                	jne    800a95 <lwip_setsockopt_internal+0xf2>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800a49:	8b 02                	mov    (%edx),%eax
  800a4b:	8b 40 08             	mov    0x8(%eax),%eax
  800a4e:	8b 0b                	mov    (%ebx),%ecx
  800a50:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800a53:	eb 40                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800a55:	8b 02                	mov    (%edx),%eax
  800a57:	8b 40 08             	mov    0x8(%eax),%eax
  800a5a:	8b 0b                	mov    (%ebx),%ecx
  800a5c:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800a5f:	eb 34                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800a61:	83 f9 01             	cmp    $0x1,%ecx
  800a64:	74 07                	je     800a6d <lwip_setsockopt_internal+0xca>
  800a66:	83 f9 02             	cmp    $0x2,%ecx
  800a69:	75 2a                	jne    800a95 <lwip_setsockopt_internal+0xf2>
  800a6b:	eb 1b                	jmp    800a88 <lwip_setsockopt_internal+0xe5>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800a6d:	83 3b 00             	cmpl   $0x0,(%ebx)
  800a70:	74 0b                	je     800a7d <lwip_setsockopt_internal+0xda>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800a72:	8b 02                	mov    (%edx),%eax
  800a74:	8b 40 08             	mov    0x8(%eax),%eax
  800a77:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800a7b:	eb 18                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800a7d:	8b 02                	mov    (%edx),%eax
  800a7f:	8b 40 08             	mov    0x8(%eax),%eax
  800a82:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800a86:	eb 0d                	jmp    800a95 <lwip_setsockopt_internal+0xf2>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800a88:	8b 02                	mov    (%edx),%eax
  800a8a:	8b 40 08             	mov    0x8(%eax),%eax
  800a8d:	8b 0b                	mov    (%ebx),%ecx
  800a8f:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800a95:	8b 02                	mov    (%edx),%eax
  800a97:	8b 40 10             	mov    0x10(%eax),%eax
  800a9a:	89 04 24             	mov    %eax,(%esp)
  800a9d:	e8 43 9d 00 00       	call   80a7e5 <sys_sem_signal>
}
  800aa2:	83 c4 14             	add    $0x14,%esp
  800aa5:	5b                   	pop    %ebx
  800aa6:	5d                   	pop    %ebp
  800aa7:	c3                   	ret    

00800aa8 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800aa8:	55                   	push   %ebp
  800aa9:	89 e5                	mov    %esp,%ebp
  800aab:	53                   	push   %ebx
  800aac:	83 ec 14             	sub    $0x14,%esp
  800aaf:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800ab2:	85 c0                	test   %eax,%eax
  800ab4:	75 1c                	jne    800ad2 <lwip_getsockopt_internal+0x2a>
  800ab6:	c7 44 24 08 96 0c 81 	movl   $0x810c96,0x8(%esp)
  800abd:	00 
  800abe:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800ac5:	00 
  800ac6:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  800acd:	e8 a6 e3 00 00       	call   80ee78 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800ad2:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800ad4:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800ad7:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800ada:	8b 40 08             	mov    0x8(%eax),%eax
  800add:	83 f8 06             	cmp    $0x6,%eax
  800ae0:	0f 84 11 01 00 00    	je     800bf7 <lwip_getsockopt_internal+0x14f>
  800ae6:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800aeb:	74 0d                	je     800afa <lwip_getsockopt_internal+0x52>
  800aed:	85 c0                	test   %eax,%eax
  800aef:	0f 84 de 00 00 00    	je     800bd3 <lwip_getsockopt_internal+0x12b>
  800af5:	e9 26 01 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800afa:	83 f9 20             	cmp    $0x20,%ecx
  800afd:	74 37                	je     800b36 <lwip_getsockopt_internal+0x8e>
  800aff:	83 f9 20             	cmp    $0x20,%ecx
  800b02:	7f 10                	jg     800b14 <lwip_getsockopt_internal+0x6c>
  800b04:	83 f9 02             	cmp    $0x2,%ecx
  800b07:	74 2d                	je     800b36 <lwip_getsockopt_internal+0x8e>
  800b09:	83 f9 08             	cmp    $0x8,%ecx
  800b0c:	0f 85 0e 01 00 00    	jne    800c20 <lwip_getsockopt_internal+0x178>
  800b12:	eb 22                	jmp    800b36 <lwip_getsockopt_internal+0x8e>
  800b14:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800b1a:	74 2c                	je     800b48 <lwip_getsockopt_internal+0xa0>
  800b1c:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800b22:	0f 84 9b 00 00 00    	je     800bc3 <lwip_getsockopt_internal+0x11b>
  800b28:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800b2e:	0f 85 ec 00 00 00    	jne    800c20 <lwip_getsockopt_internal+0x178>
  800b34:	eb 56                	jmp    800b8c <lwip_getsockopt_internal+0xe4>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800b36:	8b 02                	mov    (%edx),%eax
  800b38:	8b 40 08             	mov    0x8(%eax),%eax
  800b3b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800b3f:	21 c1                	and    %eax,%ecx
  800b41:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800b43:	e9 d8 00 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800b48:	8b 02                	mov    (%edx),%eax
  800b4a:	8b 08                	mov    (%eax),%ecx
  800b4c:	89 c8                	mov    %ecx,%eax
  800b4e:	25 f0 00 00 00       	and    $0xf0,%eax
  800b53:	83 f8 20             	cmp    $0x20,%eax
  800b56:	74 22                	je     800b7a <lwip_getsockopt_internal+0xd2>
  800b58:	83 f8 40             	cmp    $0x40,%eax
  800b5b:	74 07                	je     800b64 <lwip_getsockopt_internal+0xbc>
  800b5d:	83 f8 10             	cmp    $0x10,%eax
  800b60:	75 23                	jne    800b85 <lwip_getsockopt_internal+0xdd>
  800b62:	eb 0b                	jmp    800b6f <lwip_getsockopt_internal+0xc7>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800b64:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800b6a:	e9 b1 00 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  800b6f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
        break;
  800b75:	e9 a6 00 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800b7a:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800b80:	e9 9b 00 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800b85:	89 0b                	mov    %ecx,(%ebx)
  800b87:	e9 94 00 00 00       	jmp    800c20 <lwip_getsockopt_internal+0x178>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800b8c:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  800b90:	75 23                	jne    800bb5 <lwip_getsockopt_internal+0x10d>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800b92:	8b 02                	mov    (%edx),%eax
  800b94:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800b98:	f7 d8                	neg    %eax
  800b9a:	83 f8 0e             	cmp    $0xe,%eax
  800b9d:	77 09                	ja     800ba8 <lwip_getsockopt_internal+0x100>
  800b9f:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  800ba6:	eb 05                	jmp    800bad <lwip_getsockopt_internal+0x105>
  800ba8:	b8 05 00 00 00       	mov    $0x5,%eax
  800bad:	89 42 10             	mov    %eax,0x10(%edx)
  800bb0:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
      } 
      *(int *)optval = sock->err;
  800bb5:	8b 42 10             	mov    0x10(%edx),%eax
  800bb8:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800bba:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800bc1:	eb 5d                	jmp    800c20 <lwip_getsockopt_internal+0x178>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800bc3:	8b 02                	mov    (%edx),%eax
  800bc5:	8b 40 08             	mov    0x8(%eax),%eax
  800bc8:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800bcc:	83 e0 01             	and    $0x1,%eax
  800bcf:	89 03                	mov    %eax,(%ebx)
      break;
  800bd1:	eb 4d                	jmp    800c20 <lwip_getsockopt_internal+0x178>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800bd3:	83 f9 01             	cmp    $0x1,%ecx
  800bd6:	74 12                	je     800bea <lwip_getsockopt_internal+0x142>
  800bd8:	83 f9 02             	cmp    $0x2,%ecx
  800bdb:	75 43                	jne    800c20 <lwip_getsockopt_internal+0x178>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800bdd:	8b 02                	mov    (%edx),%eax
  800bdf:	8b 40 08             	mov    0x8(%eax),%eax
  800be2:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800be6:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800be8:	eb 36                	jmp    800c20 <lwip_getsockopt_internal+0x178>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800bea:	8b 02                	mov    (%edx),%eax
  800bec:	8b 40 08             	mov    0x8(%eax),%eax
  800bef:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800bf3:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800bf5:	eb 29                	jmp    800c20 <lwip_getsockopt_internal+0x178>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800bf7:	83 f9 01             	cmp    $0x1,%ecx
  800bfa:	74 07                	je     800c03 <lwip_getsockopt_internal+0x15b>
  800bfc:	83 f9 02             	cmp    $0x2,%ecx
  800bff:	75 1f                	jne    800c20 <lwip_getsockopt_internal+0x178>
  800c01:	eb 10                	jmp    800c13 <lwip_getsockopt_internal+0x16b>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800c03:	8b 02                	mov    (%edx),%eax
  800c05:	8b 40 08             	mov    0x8(%eax),%eax
  800c08:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800c0c:	83 e0 40             	and    $0x40,%eax
  800c0f:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800c11:	eb 0d                	jmp    800c20 <lwip_getsockopt_internal+0x178>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800c13:	8b 02                	mov    (%edx),%eax
  800c15:	8b 40 08             	mov    0x8(%eax),%eax
  800c18:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800c1e:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c20:	8b 02                	mov    (%edx),%eax
  800c22:	8b 40 10             	mov    0x10(%eax),%eax
  800c25:	89 04 24             	mov    %eax,(%esp)
  800c28:	e8 b8 9b 00 00       	call   80a7e5 <sys_sem_signal>
}
  800c2d:	83 c4 14             	add    $0x14,%esp
  800c30:	5b                   	pop    %ebx
  800c31:	5d                   	pop    %ebp
  800c32:	c3                   	ret    

00800c33 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800c33:	55                   	push   %ebp
  800c34:	89 e5                	mov    %esp,%ebp
  800c36:	57                   	push   %edi
  800c37:	56                   	push   %esi
  800c38:	53                   	push   %ebx
  800c39:	83 ec 4c             	sub    $0x4c,%esp
  800c3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800c3f:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800c42:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800c45:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c4c:	00 
  800c4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c54:	00 
  800c55:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800c58:	89 04 24             	mov    %eax,(%esp)
  800c5b:	e8 ea e9 00 00       	call   80f64a <memset>
  FD_ZERO(&lwriteset);
  800c60:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c67:	00 
  800c68:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c6f:	00 
  800c70:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800c73:	89 04 24             	mov    %eax,(%esp)
  800c76:	e8 cf e9 00 00       	call   80f64a <memset>
  FD_ZERO(&lexceptset);
  800c7b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800c82:	00 
  800c83:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800c8a:	00 
  800c8b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800c8e:	89 04 24             	mov    %eax,(%esp)
  800c91:	e8 b4 e9 00 00       	call   80f64a <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  800c96:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800c9d:	bb 00 00 00 00       	mov    $0x0,%ebx
  800ca2:	e9 80 00 00 00       	jmp    800d27 <lwip_selscan+0xf4>
    if (FD_ISSET(i, readset)) {
  800ca7:	89 de                	mov    %ebx,%esi
  800ca9:	85 db                	test   %ebx,%ebx
  800cab:	79 03                	jns    800cb0 <lwip_selscan+0x7d>
  800cad:	8d 73 07             	lea    0x7(%ebx),%esi
  800cb0:	c1 fe 03             	sar    $0x3,%esi
  800cb3:	89 f7                	mov    %esi,%edi
  800cb5:	89 d9                	mov    %ebx,%ecx
  800cb7:	83 e1 07             	and    $0x7,%ecx
  800cba:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  800cbd:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800cc0:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  800cc4:	d3 f8                	sar    %cl,%eax
  800cc6:	a8 01                	test   $0x1,%al
  800cc8:	74 29                	je     800cf3 <lwip_selscan+0xc0>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800cca:	89 d8                	mov    %ebx,%eax
  800ccc:	e8 93 fc ff ff       	call   800964 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800cd1:	85 c0                	test   %eax,%eax
  800cd3:	74 1e                	je     800cf3 <lwip_selscan+0xc0>
  800cd5:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800cd9:	75 07                	jne    800ce2 <lwip_selscan+0xaf>
  800cdb:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800ce0:	74 11                	je     800cf3 <lwip_selscan+0xc0>
        FD_SET(i, &lreadset);
  800ce2:	b8 01 00 00 00       	mov    $0x1,%eax
  800ce7:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800cea:	d3 e0                	shl    %cl,%eax
  800cec:	08 44 3d e4          	or     %al,-0x1c(%ebp,%edi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800cf0:	ff 45 c4             	incl   -0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800cf3:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800cf6:	0f b6 04 31          	movzbl (%ecx,%esi,1),%eax
  800cfa:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800cfd:	d3 f8                	sar    %cl,%eax
  800cff:	a8 01                	test   $0x1,%al
  800d01:	74 23                	je     800d26 <lwip_selscan+0xf3>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800d03:	89 d8                	mov    %ebx,%eax
  800d05:	e8 5a fc ff ff       	call   800964 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800d0a:	85 c0                	test   %eax,%eax
  800d0c:	74 18                	je     800d26 <lwip_selscan+0xf3>
  800d0e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800d13:	74 11                	je     800d26 <lwip_selscan+0xf3>
        FD_SET(i, &lwriteset);
  800d15:	b8 01 00 00 00       	mov    $0x1,%eax
  800d1a:	8a 4d d4             	mov    -0x2c(%ebp),%cl
  800d1d:	d3 e0                	shl    %cl,%eax
  800d1f:	08 44 3d e0          	or     %al,-0x20(%ebp,%edi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800d23:	ff 45 c4             	incl   -0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800d26:	43                   	inc    %ebx
  800d27:	3b 5d d0             	cmp    -0x30(%ebp),%ebx
  800d2a:	0f 8c 77 ff ff ff    	jl     800ca7 <lwip_selscan+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800d30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800d33:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800d36:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800d38:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800d3b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800d3e:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800d40:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800d47:	00 
  800d48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800d4f:	00 
  800d50:	8b 45 08             	mov    0x8(%ebp),%eax
  800d53:	89 04 24             	mov    %eax,(%esp)
  800d56:	e8 ef e8 00 00       	call   80f64a <memset>
  
  return nready;
}
  800d5b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800d5e:	83 c4 4c             	add    $0x4c,%esp
  800d61:	5b                   	pop    %ebx
  800d62:	5e                   	pop    %esi
  800d63:	5f                   	pop    %edi
  800d64:	5d                   	pop    %ebp
  800d65:	c3                   	ret    

00800d66 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800d66:	55                   	push   %ebp
  800d67:	89 e5                	mov    %esp,%ebp
  800d69:	57                   	push   %edi
  800d6a:	56                   	push   %esi
  800d6b:	53                   	push   %ebx
  800d6c:	83 ec 4c             	sub    $0x4c,%esp
  800d6f:	89 d7                	mov    %edx,%edi
  800d71:	89 ce                	mov    %ecx,%esi
  800d73:	8a 55 08             	mov    0x8(%ebp),%dl
  800d76:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800d79:	e8 e6 fb ff ff       	call   800964 <get_socket>
  800d7e:	89 c3                	mov    %eax,%ebx
  if (!sock)
  800d80:	85 c0                	test   %eax,%eax
  800d82:	0f 84 91 00 00 00    	je     800e19 <lwip_getaddrname+0xb3>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800d88:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  800d8f:	00 
  800d90:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800d97:	00 
  800d98:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800d9b:	89 04 24             	mov    %eax,(%esp)
  800d9e:	e8 a7 e8 00 00       	call   80f64a <memset>
  sin.sin_len = sizeof(sin);
  800da3:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800da7:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800dab:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  800daf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800db3:	8d 45 da             	lea    -0x26(%ebp),%eax
  800db6:	89 44 24 08          	mov    %eax,0x8(%esp)
  800dba:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800dbd:	89 44 24 04          	mov    %eax,0x4(%esp)
  800dc1:	8b 03                	mov    (%ebx),%eax
  800dc3:	89 04 24             	mov    %eax,(%esp)
  800dc6:	e8 ec a7 00 00       	call   80b5b7 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800dcb:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800dcf:	89 04 24             	mov    %eax,(%esp)
  800dd2:	e8 a6 6e 00 00       	call   807c7d <htons>
  800dd7:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800ddb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800dde:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800de1:	83 3e 10             	cmpl   $0x10,(%esi)
  800de4:	76 06                	jbe    800dec <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  800de6:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  800dec:	8b 06                	mov    (%esi),%eax
  800dee:	89 44 24 08          	mov    %eax,0x8(%esp)
  800df2:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800df5:	89 44 24 04          	mov    %eax,0x4(%esp)
  800df9:	89 3c 24             	mov    %edi,(%esp)
  800dfc:	e8 fd e8 00 00       	call   80f6fe <memcpy>
  sock_set_errno(sock, 0);
  800e01:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800e08:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  800e0f:	00 00 00 
  return 0;
  800e12:	b8 00 00 00 00       	mov    $0x0,%eax
  800e17:	eb 05                	jmp    800e1e <lwip_getaddrname+0xb8>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800e19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800e1e:	83 c4 4c             	add    $0x4c,%esp
  800e21:	5b                   	pop    %ebx
  800e22:	5e                   	pop    %esi
  800e23:	5f                   	pop    %edi
  800e24:	5d                   	pop    %ebp
  800e25:	c3                   	ret    

00800e26 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800e26:	55                   	push   %ebp
  800e27:	89 e5                	mov    %esp,%ebp
  800e29:	56                   	push   %esi
  800e2a:	53                   	push   %ebx
  800e2b:	83 ec 10             	sub    $0x10,%esp
  800e2e:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800e30:	a1 60 50 81 00       	mov    0x815060,%eax
  800e35:	89 04 24             	mov    %eax,(%esp)
  800e38:	e8 53 48 00 00       	call   805690 <sys_sem_wait>
  800e3d:	b8 80 50 81 00       	mov    $0x815080,%eax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800e42:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800e47:	83 38 00             	cmpl   $0x0,(%eax)
  800e4a:	75 5d                	jne    800ea9 <alloc_socket+0x83>
      sockets[i].conn       = newconn;
  800e4c:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800e53:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800e56:	c1 e1 02             	shl    $0x2,%ecx
  800e59:	89 b1 80 50 81 00    	mov    %esi,0x815080(%ecx)
      sockets[i].lastdata   = NULL;
  800e5f:	c7 81 84 50 81 00 00 	movl   $0x0,0x815084(%ecx)
  800e66:	00 00 00 
      sockets[i].lastoffset = 0;
  800e69:	66 c7 81 88 50 81 00 	movw   $0x0,0x815088(%ecx)
  800e70:	00 00 
      sockets[i].rcvevent   = 0;
  800e72:	66 c7 81 8a 50 81 00 	movw   $0x0,0x81508a(%ecx)
  800e79:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800e7b:	66 c7 81 8c 50 81 00 	movw   $0x1,0x81508c(%ecx)
  800e82:	01 00 
      sockets[i].flags      = 0;
  800e84:	66 c7 81 8e 50 81 00 	movw   $0x0,0x81508e(%ecx)
  800e8b:	00 00 
      sockets[i].err        = 0;
  800e8d:	01 da                	add    %ebx,%edx
  800e8f:	c7 04 95 90 50 81 00 	movl   $0x0,0x815090(,%edx,4)
  800e96:	00 00 00 00 
      sys_sem_signal(socksem);
  800e9a:	a1 60 50 81 00       	mov    0x815060,%eax
  800e9f:	89 04 24             	mov    %eax,(%esp)
  800ea2:	e8 3e 99 00 00       	call   80a7e5 <sys_sem_signal>
      return i;
  800ea7:	eb 1b                	jmp    800ec4 <alloc_socket+0x9e>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ea9:	43                   	inc    %ebx
  800eaa:	83 c0 14             	add    $0x14,%eax
  800ead:	83 fb 20             	cmp    $0x20,%ebx
  800eb0:	75 95                	jne    800e47 <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800eb2:	a1 60 50 81 00       	mov    0x815060,%eax
  800eb7:	89 04 24             	mov    %eax,(%esp)
  800eba:	e8 26 99 00 00       	call   80a7e5 <sys_sem_signal>
  return -1;
  800ebf:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  800ec4:	89 d8                	mov    %ebx,%eax
  800ec6:	83 c4 10             	add    $0x10,%esp
  800ec9:	5b                   	pop    %ebx
  800eca:	5e                   	pop    %esi
  800ecb:	5d                   	pop    %ebp
  800ecc:	c3                   	ret    

00800ecd <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  800ecd:	55                   	push   %ebp
  800ece:	89 e5                	mov    %esp,%ebp
  800ed0:	57                   	push   %edi
  800ed1:	56                   	push   %esi
  800ed2:	53                   	push   %ebx
  800ed3:	83 ec 2c             	sub    $0x2c,%esp
  800ed6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800ed9:	85 f6                	test   %esi,%esi
  800edb:	0f 84 5b 01 00 00    	je     80103c <event_callback+0x16f>
    s = conn->socket;
  800ee1:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  800ee4:	85 db                	test   %ebx,%ebx
  800ee6:	79 3d                	jns    800f25 <event_callback+0x58>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800ee8:	a1 60 50 81 00       	mov    0x815060,%eax
  800eed:	89 04 24             	mov    %eax,(%esp)
  800ef0:	e8 9b 47 00 00       	call   805690 <sys_sem_wait>
      if (conn->socket < 0) {
  800ef5:	8b 46 1c             	mov    0x1c(%esi),%eax
  800ef8:	85 c0                	test   %eax,%eax
  800efa:	79 1c                	jns    800f18 <event_callback+0x4b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800efc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  800f00:	75 04                	jne    800f06 <event_callback+0x39>
          conn->socket--;
  800f02:	48                   	dec    %eax
  800f03:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  800f06:	a1 60 50 81 00       	mov    0x815060,%eax
  800f0b:	89 04 24             	mov    %eax,(%esp)
  800f0e:	e8 d2 98 00 00       	call   80a7e5 <sys_sem_signal>
        return;
  800f13:	e9 24 01 00 00       	jmp    80103c <event_callback+0x16f>
      }
      sys_sem_signal(socksem);
  800f18:	a1 60 50 81 00       	mov    0x815060,%eax
  800f1d:	89 04 24             	mov    %eax,(%esp)
  800f20:	e8 c0 98 00 00       	call   80a7e5 <sys_sem_signal>
    }

    sock = get_socket(s);
  800f25:	89 d8                	mov    %ebx,%eax
  800f27:	e8 38 fa ff ff       	call   800964 <get_socket>
  800f2c:	89 c7                	mov    %eax,%edi
    if (!sock) {
  800f2e:	85 c0                	test   %eax,%eax
  800f30:	0f 84 06 01 00 00    	je     80103c <event_callback+0x16f>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800f36:	a1 64 50 81 00       	mov    0x815064,%eax
  800f3b:	89 04 24             	mov    %eax,(%esp)
  800f3e:	e8 4d 47 00 00       	call   805690 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800f43:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  800f47:	74 1a                	je     800f63 <event_callback+0x96>
  800f49:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  800f4d:	72 0e                	jb     800f5d <event_callback+0x90>
  800f4f:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  800f53:	74 14                	je     800f69 <event_callback+0x9c>
  800f55:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  800f59:	75 1e                	jne    800f79 <event_callback+0xac>
  800f5b:	eb 14                	jmp    800f71 <event_callback+0xa4>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800f5d:	66 ff 47 0a          	incw   0xa(%edi)
      break;
  800f61:	eb 32                	jmp    800f95 <event_callback+0xc8>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800f63:	66 ff 4f 0a          	decw   0xa(%edi)
      break;
  800f67:	eb 2c                	jmp    800f95 <event_callback+0xc8>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800f69:	66 c7 47 0c 01 00    	movw   $0x1,0xc(%edi)
      break;
  800f6f:	eb 24                	jmp    800f95 <event_callback+0xc8>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800f71:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
      break;
  800f77:	eb 1c                	jmp    800f95 <event_callback+0xc8>
    default:
      LWIP_ASSERT("unknown event", 0);
  800f79:	c7 44 24 08 b9 0c 81 	movl   $0x810cb9,0x8(%esp)
  800f80:	00 
  800f81:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  800f88:	00 
  800f89:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  800f90:	e8 e3 de 00 00       	call   80ee78 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800f95:	a1 64 50 81 00       	mov    0x815064,%eax
  800f9a:	89 04 24             	mov    %eax,(%esp)
  800f9d:	e8 43 98 00 00       	call   80a7e5 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800fa2:	89 de                	mov    %ebx,%esi
  800fa4:	85 db                	test   %ebx,%ebx
  800fa6:	79 03                	jns    800fab <event_callback+0xde>
  800fa8:	8d 73 07             	lea    0x7(%ebx),%esi
  800fab:	c1 fe 03             	sar    $0x3,%esi
  800fae:	89 d9                	mov    %ebx,%ecx
  800fb0:	83 e1 07             	and    $0x7,%ecx
  800fb3:	b8 01 00 00 00       	mov    $0x1,%eax
  800fb8:	d3 e0                	shl    %cl,%eax
  800fba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800fbd:	a1 64 50 81 00       	mov    0x815064,%eax
  800fc2:	89 04 24             	mov    %eax,(%esp)
  800fc5:	e8 c6 46 00 00       	call   805690 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800fca:	8b 1d 00 53 81 00    	mov    0x815300,%ebx
  800fd0:	eb 36                	jmp    801008 <event_callback+0x13b>
      if (scb->sem_signalled == 0) {
  800fd2:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800fd6:	75 2e                	jne    801006 <event_callback+0x139>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800fd8:	8b 43 04             	mov    0x4(%ebx),%eax
  800fdb:	85 c0                	test   %eax,%eax
  800fdd:	74 10                	je     800fef <event_callback+0x122>
  800fdf:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800fe3:	85 45 e4             	test   %eax,-0x1c(%ebp)
  800fe6:	74 07                	je     800fef <event_callback+0x122>
          if (sock->rcvevent)
  800fe8:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  800fed:	75 1f                	jne    80100e <event_callback+0x141>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800fef:	8b 43 08             	mov    0x8(%ebx),%eax
  800ff2:	85 c0                	test   %eax,%eax
  800ff4:	74 10                	je     801006 <event_callback+0x139>
  800ff6:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800ffa:	85 45 e4             	test   %eax,-0x1c(%ebp)
  800ffd:	74 07                	je     801006 <event_callback+0x139>
          if (sock->sendevent)
  800fff:	66 83 7f 0c 00       	cmpw   $0x0,0xc(%edi)
  801004:	75 08                	jne    80100e <event_callback+0x141>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  801006:	8b 1b                	mov    (%ebx),%ebx
  801008:	85 db                	test   %ebx,%ebx
  80100a:	75 c6                	jne    800fd2 <event_callback+0x105>
  80100c:	eb 21                	jmp    80102f <event_callback+0x162>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  80100e:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  801015:	a1 64 50 81 00       	mov    0x815064,%eax
  80101a:	89 04 24             	mov    %eax,(%esp)
  80101d:	e8 c3 97 00 00       	call   80a7e5 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  801022:	8b 43 14             	mov    0x14(%ebx),%eax
  801025:	89 04 24             	mov    %eax,(%esp)
  801028:	e8 b8 97 00 00       	call   80a7e5 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  80102d:	eb 8e                	jmp    800fbd <event_callback+0xf0>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  80102f:	a1 64 50 81 00       	mov    0x815064,%eax
  801034:	89 04 24             	mov    %eax,(%esp)
  801037:	e8 a9 97 00 00       	call   80a7e5 <sys_sem_signal>
      break;
    }
  }
}
  80103c:	83 c4 2c             	add    $0x2c,%esp
  80103f:	5b                   	pop    %ebx
  801040:	5e                   	pop    %esi
  801041:	5f                   	pop    %edi
  801042:	5d                   	pop    %ebp
  801043:	c3                   	ret    

00801044 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801044:	55                   	push   %ebp
  801045:	89 e5                	mov    %esp,%ebp
  801047:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  80104a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801051:	e8 81 94 00 00       	call   80a4d7 <sys_sem_new>
  801056:	a3 60 50 81 00       	mov    %eax,0x815060
  selectsem = sys_sem_new(1);
  80105b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801062:	e8 70 94 00 00       	call   80a4d7 <sys_sem_new>
  801067:	a3 64 50 81 00       	mov    %eax,0x815064
}
  80106c:	c9                   	leave  
  80106d:	c3                   	ret    

0080106e <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80106e:	55                   	push   %ebp
  80106f:	89 e5                	mov    %esp,%ebp
  801071:	57                   	push   %edi
  801072:	56                   	push   %esi
  801073:	53                   	push   %ebx
  801074:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  801077:	8b 45 08             	mov    0x8(%ebp),%eax
  80107a:	e8 e5 f8 ff ff       	call   800964 <get_socket>
  80107f:	89 c7                	mov    %eax,%edi
  if (!sock)
  801081:	85 c0                	test   %eax,%eax
  801083:	0f 84 91 01 00 00    	je     80121a <lwip_accept+0x1ac>
    return -1;

  newconn = netconn_accept(sock->conn);
  801089:	8b 00                	mov    (%eax),%eax
  80108b:	89 04 24             	mov    %eax,(%esp)
  80108e:	e8 f8 a6 00 00       	call   80b78b <netconn_accept>
  801093:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  801095:	85 c0                	test   %eax,%eax
  801097:	75 2d                	jne    8010c6 <lwip_accept+0x58>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801099:	8b 07                	mov    (%edi),%eax
  80109b:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  80109f:	f7 d8                	neg    %eax
  8010a1:	83 f8 0e             	cmp    $0xe,%eax
  8010a4:	77 09                	ja     8010af <lwip_accept+0x41>
  8010a6:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  8010ad:	eb 05                	jmp    8010b4 <lwip_accept+0x46>
  8010af:	b8 05 00 00 00       	mov    $0x5,%eax
  8010b4:	89 47 10             	mov    %eax,0x10(%edi)
  8010b7:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  8010bc:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8010c1:	e9 59 01 00 00       	jmp    80121f <lwip_accept+0x1b1>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8010c6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010cd:	00 
  8010ce:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  8010d1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010d5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010dc:	89 1c 24             	mov    %ebx,(%esp)
  8010df:	e8 d3 a4 00 00       	call   80b5b7 <netconn_getaddr>
  8010e4:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  8010e6:	84 c0                	test   %al,%al
  8010e8:	74 34                	je     80111e <lwip_accept+0xb0>
    netconn_delete(newconn);
  8010ea:	89 1c 24             	mov    %ebx,(%esp)
  8010ed:	e8 5e a4 00 00       	call   80b550 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8010f2:	89 f0                	mov    %esi,%eax
  8010f4:	0f be f0             	movsbl %al,%esi
  8010f7:	f7 de                	neg    %esi
  8010f9:	83 fe 0e             	cmp    $0xe,%esi
  8010fc:	77 09                	ja     801107 <lwip_accept+0x99>
  8010fe:	8b 04 b5 60 0d 81 00 	mov    0x810d60(,%esi,4),%eax
  801105:	eb 05                	jmp    80110c <lwip_accept+0x9e>
  801107:	b8 05 00 00 00       	mov    $0x5,%eax
  80110c:	89 47 10             	mov    %eax,0x10(%edi)
  80110f:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  801114:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801119:	e9 01 01 00 00       	jmp    80121f <lwip_accept+0x1b1>
  }

  memset(&sin, 0, sizeof(sin));
  80111e:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801125:	00 
  801126:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80112d:	00 
  80112e:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801131:	89 04 24             	mov    %eax,(%esp)
  801134:	e8 11 e5 00 00       	call   80f64a <memset>
  sin.sin_len = sizeof(sin);
  801139:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  80113d:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  801141:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801145:	89 04 24             	mov    %eax,(%esp)
  801148:	e8 30 6b 00 00       	call   807c7d <htons>
  80114d:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  801151:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801154:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  801157:	8b 55 10             	mov    0x10(%ebp),%edx
  80115a:	83 3a 10             	cmpl   $0x10,(%edx)
  80115d:	76 06                	jbe    801165 <lwip_accept+0xf7>
    *addrlen = sizeof(sin);
  80115f:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  801165:	8b 55 10             	mov    0x10(%ebp),%edx
  801168:	8b 02                	mov    (%edx),%eax
  80116a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80116e:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801171:	89 44 24 04          	mov    %eax,0x4(%esp)
  801175:	8b 45 0c             	mov    0xc(%ebp),%eax
  801178:	89 04 24             	mov    %eax,(%esp)
  80117b:	e8 7e e5 00 00       	call   80f6fe <memcpy>

  newsock = alloc_socket(newconn);
  801180:	89 d8                	mov    %ebx,%eax
  801182:	e8 9f fc ff ff       	call   800e26 <alloc_socket>
  801187:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  801189:	83 f8 ff             	cmp    $0xffffffff,%eax
  80118c:	75 1b                	jne    8011a9 <lwip_accept+0x13b>
    netconn_delete(newconn);
  80118e:	89 1c 24             	mov    %ebx,(%esp)
  801191:	e8 ba a3 00 00       	call   80b550 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801196:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  80119d:	c7 05 20 b2 b3 00 17 	movl   $0x17,0xb3b220
  8011a4:	00 00 00 
    return -1;
  8011a7:	eb 76                	jmp    80121f <lwip_accept+0x1b1>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8011a9:	83 f8 1f             	cmp    $0x1f,%eax
  8011ac:	76 1c                	jbe    8011ca <lwip_accept+0x15c>
  8011ae:	c7 44 24 08 c7 0c 81 	movl   $0x810cc7,0x8(%esp)
  8011b5:	00 
  8011b6:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8011bd:	00 
  8011be:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  8011c5:	e8 ae dc 00 00       	call   80ee78 <_panic>
  newconn->callback = event_callback;
  8011ca:	c7 43 2c cd 0e 80 00 	movl   $0x800ecd,0x2c(%ebx)
  nsock = &sockets[newsock];
  8011d1:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8011d4:	8d 04 85 80 50 81 00 	lea    0x815080(,%eax,4),%eax
  8011db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  8011de:	a1 60 50 81 00       	mov    0x815060,%eax
  8011e3:	89 04 24             	mov    %eax,(%esp)
  8011e6:	e8 a5 44 00 00       	call   805690 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8011eb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8011ee:	f7 d0                	not    %eax
  8011f0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8011f3:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  8011f7:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  8011fa:	a1 60 50 81 00       	mov    0x815060,%eax
  8011ff:	89 04 24             	mov    %eax,(%esp)
  801202:	e8 de 95 00 00       	call   80a7e5 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  801207:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  80120e:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801215:	00 00 00 
  return newsock;
  801218:	eb 05                	jmp    80121f <lwip_accept+0x1b1>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80121a:	be ff ff ff ff       	mov    $0xffffffff,%esi
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  80121f:	89 f0                	mov    %esi,%eax
  801221:	83 c4 4c             	add    $0x4c,%esp
  801224:	5b                   	pop    %ebx
  801225:	5e                   	pop    %esi
  801226:	5f                   	pop    %edi
  801227:	5d                   	pop    %ebp
  801228:	c3                   	ret    

00801229 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801229:	55                   	push   %ebp
  80122a:	89 e5                	mov    %esp,%ebp
  80122c:	56                   	push   %esi
  80122d:	53                   	push   %ebx
  80122e:	83 ec 20             	sub    $0x20,%esp
  801231:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801234:	8b 45 08             	mov    0x8(%ebp),%eax
  801237:	e8 28 f7 ff ff       	call   800964 <get_socket>
  80123c:	89 c6                	mov    %eax,%esi
  if (!sock)
  80123e:	85 c0                	test   %eax,%eax
  801240:	0f 84 95 00 00 00    	je     8012db <lwip_bind+0xb2>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801246:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80124a:	75 06                	jne    801252 <lwip_bind+0x29>
  80124c:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  801250:	74 1c                	je     80126e <lwip_bind+0x45>
  801252:	c7 44 24 08 dc 0c 81 	movl   $0x810cdc,0x8(%esp)
  801259:	00 
  80125a:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  801261:	00 
  801262:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  801269:	e8 0a dc 00 00       	call   80ee78 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80126e:	8b 43 04             	mov    0x4(%ebx),%eax
  801271:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801274:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  801278:	89 04 24             	mov    %eax,(%esp)
  80127b:	e8 09 6a 00 00       	call   807c89 <ntohs>
  801280:	0f b7 c0             	movzwl %ax,%eax
  801283:	89 44 24 08          	mov    %eax,0x8(%esp)
  801287:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80128a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80128e:	8b 06                	mov    (%esi),%eax
  801290:	89 04 24             	mov    %eax,(%esp)
  801293:	e8 b9 a3 00 00       	call   80b651 <netconn_bind>

  if (err != ERR_OK) {
  801298:	84 c0                	test   %al,%al
  80129a:	74 27                	je     8012c3 <lwip_bind+0x9a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80129c:	0f be c0             	movsbl %al,%eax
  80129f:	f7 d8                	neg    %eax
  8012a1:	83 f8 0e             	cmp    $0xe,%eax
  8012a4:	77 09                	ja     8012af <lwip_bind+0x86>
  8012a6:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  8012ad:	eb 05                	jmp    8012b4 <lwip_bind+0x8b>
  8012af:	b8 05 00 00 00       	mov    $0x5,%eax
  8012b4:	89 46 10             	mov    %eax,0x10(%esi)
  8012b7:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  8012bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012c1:	eb 1d                	jmp    8012e0 <lwip_bind+0xb7>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8012c3:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012ca:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  8012d1:	00 00 00 
  return 0;
  8012d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8012d9:	eb 05                	jmp    8012e0 <lwip_bind+0xb7>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8012db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8012e0:	83 c4 20             	add    $0x20,%esp
  8012e3:	5b                   	pop    %ebx
  8012e4:	5e                   	pop    %esi
  8012e5:	5d                   	pop    %ebp
  8012e6:	c3                   	ret    

008012e7 <lwip_close>:

int
lwip_close(int s)
{
  8012e7:	55                   	push   %ebp
  8012e8:	89 e5                	mov    %esp,%ebp
  8012ea:	53                   	push   %ebx
  8012eb:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8012ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8012f1:	e8 6e f6 ff ff       	call   800964 <get_socket>
  8012f6:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  8012f8:	85 c0                	test   %eax,%eax
  8012fa:	74 5e                	je     80135a <lwip_close+0x73>
    return -1;
  }

  netconn_delete(sock->conn);
  8012fc:	8b 00                	mov    (%eax),%eax
  8012fe:	89 04 24             	mov    %eax,(%esp)
  801301:	e8 4a a2 00 00       	call   80b550 <netconn_delete>

  sys_sem_wait(socksem);
  801306:	a1 60 50 81 00       	mov    0x815060,%eax
  80130b:	89 04 24             	mov    %eax,(%esp)
  80130e:	e8 7d 43 00 00       	call   805690 <sys_sem_wait>
  if (sock->lastdata) {
  801313:	8b 43 04             	mov    0x4(%ebx),%eax
  801316:	85 c0                	test   %eax,%eax
  801318:	74 08                	je     801322 <lwip_close+0x3b>
    netbuf_delete(sock->lastdata);
  80131a:	89 04 24             	mov    %eax,(%esp)
  80131d:	e8 e6 14 00 00       	call   802808 <netbuf_delete>
  }
  sock->lastdata   = NULL;
  801322:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801329:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80132f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801335:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80133c:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801343:	00 00 00 
  sys_sem_signal(socksem);
  801346:	a1 60 50 81 00       	mov    0x815060,%eax
  80134b:	89 04 24             	mov    %eax,(%esp)
  80134e:	e8 92 94 00 00       	call   80a7e5 <sys_sem_signal>
  return 0;
  801353:	b8 00 00 00 00       	mov    $0x0,%eax
  801358:	eb 05                	jmp    80135f <lwip_close+0x78>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  80135a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80135f:	83 c4 14             	add    $0x14,%esp
  801362:	5b                   	pop    %ebx
  801363:	5d                   	pop    %ebp
  801364:	c3                   	ret    

00801365 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801365:	55                   	push   %ebp
  801366:	89 e5                	mov    %esp,%ebp
  801368:	56                   	push   %esi
  801369:	53                   	push   %ebx
  80136a:	83 ec 20             	sub    $0x20,%esp
  80136d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  801370:	8b 45 08             	mov    0x8(%ebp),%eax
  801373:	e8 ec f5 ff ff       	call   800964 <get_socket>
  801378:	89 c6                	mov    %eax,%esi
  if (!sock)
  80137a:	85 c0                	test   %eax,%eax
  80137c:	0f 84 95 00 00 00    	je     801417 <lwip_connect+0xb2>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801382:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801386:	75 06                	jne    80138e <lwip_connect+0x29>
  801388:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  80138c:	74 1c                	je     8013aa <lwip_connect+0x45>
  80138e:	c7 44 24 08 f7 0c 81 	movl   $0x810cf7,0x8(%esp)
  801395:	00 
  801396:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  80139d:	00 
  80139e:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  8013a5:	e8 ce da 00 00       	call   80ee78 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8013aa:	8b 43 04             	mov    0x4(%ebx),%eax
  8013ad:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8013b0:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8013b4:	89 04 24             	mov    %eax,(%esp)
  8013b7:	e8 cd 68 00 00       	call   807c89 <ntohs>
  8013bc:	0f b7 c0             	movzwl %ax,%eax
  8013bf:	89 44 24 08          	mov    %eax,0x8(%esp)
  8013c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8013c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013ca:	8b 06                	mov    (%esi),%eax
  8013cc:	89 04 24             	mov    %eax,(%esp)
  8013cf:	e8 d2 a2 00 00       	call   80b6a6 <netconn_connect>
  }

  if (err != ERR_OK) {
  8013d4:	84 c0                	test   %al,%al
  8013d6:	74 27                	je     8013ff <lwip_connect+0x9a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8013d8:	0f be c0             	movsbl %al,%eax
  8013db:	f7 d8                	neg    %eax
  8013dd:	83 f8 0e             	cmp    $0xe,%eax
  8013e0:	77 09                	ja     8013eb <lwip_connect+0x86>
  8013e2:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  8013e9:	eb 05                	jmp    8013f0 <lwip_connect+0x8b>
  8013eb:	b8 05 00 00 00       	mov    $0x5,%eax
  8013f0:	89 46 10             	mov    %eax,0x10(%esi)
  8013f3:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  8013f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013fd:	eb 1d                	jmp    80141c <lwip_connect+0xb7>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8013ff:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801406:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  80140d:	00 00 00 
  return 0;
  801410:	b8 00 00 00 00       	mov    $0x0,%eax
  801415:	eb 05                	jmp    80141c <lwip_connect+0xb7>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801417:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80141c:	83 c4 20             	add    $0x20,%esp
  80141f:	5b                   	pop    %ebx
  801420:	5e                   	pop    %esi
  801421:	5d                   	pop    %ebp
  801422:	c3                   	ret    

00801423 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801423:	55                   	push   %ebp
  801424:	89 e5                	mov    %esp,%ebp
  801426:	56                   	push   %esi
  801427:	53                   	push   %ebx
  801428:	83 ec 10             	sub    $0x10,%esp
  80142b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80142e:	8b 45 08             	mov    0x8(%ebp),%eax
  801431:	e8 2e f5 ff ff       	call   800964 <get_socket>
  801436:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801438:	85 c0                	test   %eax,%eax
  80143a:	74 6d                	je     8014a9 <lwip_listen+0x86>
  80143c:	89 f0                	mov    %esi,%eax
  80143e:	85 f6                	test   %esi,%esi
  801440:	79 05                	jns    801447 <lwip_listen+0x24>
  801442:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  801447:	89 c2                	mov    %eax,%edx
  801449:	3d ff 00 00 00       	cmp    $0xff,%eax
  80144e:	7e 05                	jle    801455 <lwip_listen+0x32>
  801450:	ba ff 00 00 00       	mov    $0xff,%edx
  801455:	0f b6 d2             	movzbl %dl,%edx
  801458:	89 54 24 04          	mov    %edx,0x4(%esp)
  80145c:	8b 03                	mov    (%ebx),%eax
  80145e:	89 04 24             	mov    %eax,(%esp)
  801461:	e8 dd a2 00 00       	call   80b743 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  801466:	84 c0                	test   %al,%al
  801468:	74 27                	je     801491 <lwip_listen+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80146a:	0f be c0             	movsbl %al,%eax
  80146d:	f7 d8                	neg    %eax
  80146f:	83 f8 0e             	cmp    $0xe,%eax
  801472:	77 09                	ja     80147d <lwip_listen+0x5a>
  801474:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  80147b:	eb 05                	jmp    801482 <lwip_listen+0x5f>
  80147d:	b8 05 00 00 00       	mov    $0x5,%eax
  801482:	89 43 10             	mov    %eax,0x10(%ebx)
  801485:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  80148a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80148f:	eb 1d                	jmp    8014ae <lwip_listen+0x8b>
  }

  sock_set_errno(sock, 0);
  801491:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801498:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  80149f:	00 00 00 
  return 0;
  8014a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8014a7:	eb 05                	jmp    8014ae <lwip_listen+0x8b>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  8014a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  8014ae:	83 c4 10             	add    $0x10,%esp
  8014b1:	5b                   	pop    %ebx
  8014b2:	5e                   	pop    %esi
  8014b3:	5d                   	pop    %ebp
  8014b4:	c3                   	ret    

008014b5 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8014b5:	55                   	push   %ebp
  8014b6:	89 e5                	mov    %esp,%ebp
  8014b8:	57                   	push   %edi
  8014b9:	56                   	push   %esi
  8014ba:	53                   	push   %ebx
  8014bb:	83 ec 5c             	sub    $0x5c,%esp
  8014be:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8014c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8014c4:	e8 9b f4 ff ff       	call   800964 <get_socket>
  8014c9:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8014cb:	85 c0                	test   %eax,%eax
  8014cd:	0f 84 36 02 00 00    	je     801709 <lwip_recvfrom+0x254>
  8014d3:	bf 00 00 00 00       	mov    $0x0,%edi
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014d8:	89 f0                	mov    %esi,%eax
  8014da:	83 e0 08             	and    $0x8,%eax
  8014dd:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8014e0:	83 e6 01             	and    $0x1,%esi
  8014e3:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8014e6:	8b 43 04             	mov    0x4(%ebx),%eax
  8014e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  8014ec:	85 c0                	test   %eax,%eax
  8014ee:	0f 85 82 00 00 00    	jne    801576 <lwip_recvfrom+0xc1>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014f4:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8014f8:	75 06                	jne    801500 <lwip_recvfrom+0x4b>
  8014fa:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8014fe:	74 22                	je     801522 <lwip_recvfrom+0x6d>
  801500:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  801505:	75 1b                	jne    801522 <lwip_recvfrom+0x6d>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801507:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  80150e:	c7 05 20 b2 b3 00 0b 	movl   $0xb,0xb3b220
  801515:	00 00 00 
        return -1;
  801518:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80151d:	e9 ec 01 00 00       	jmp    80170e <lwip_recvfrom+0x259>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801522:	8b 03                	mov    (%ebx),%eax
  801524:	89 04 24             	mov    %eax,(%esp)
  801527:	e8 e9 a2 00 00       	call   80b815 <netconn_recv>
  80152c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80152f:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801532:	85 c0                	test   %eax,%eax
  801534:	75 40                	jne    801576 <lwip_recvfrom+0xc1>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801536:	8b 03                	mov    (%ebx),%eax
  801538:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80153c:	74 06                	je     801544 <lwip_recvfrom+0x8f>
  80153e:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  801542:	74 14                	je     801558 <lwip_recvfrom+0xa3>
  801544:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  801548:	f7 d8                	neg    %eax
  80154a:	83 f8 0e             	cmp    $0xe,%eax
  80154d:	77 10                	ja     80155f <lwip_recvfrom+0xaa>
  80154f:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  801556:	eb 0c                	jmp    801564 <lwip_recvfrom+0xaf>
  801558:	b8 6e 00 00 00       	mov    $0x6e,%eax
  80155d:	eb 05                	jmp    801564 <lwip_recvfrom+0xaf>
  80155f:	b8 05 00 00 00       	mov    $0x5,%eax
  801564:	89 43 10             	mov    %eax,0x10(%ebx)
  801567:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
        return 0;
  80156c:	b8 00 00 00 00       	mov    $0x0,%eax
  801571:	e9 98 01 00 00       	jmp    80170e <lwip_recvfrom+0x259>
      }
    }

    buflen = netbuf_len(buf);
  801576:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801579:	8b 02                	mov    (%edx),%eax
  80157b:	8b 70 08             	mov    0x8(%eax),%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80157e:	8b 53 08             	mov    0x8(%ebx),%edx
  801581:	66 29 d6             	sub    %dx,%si

    if (len > buflen) {
  801584:	0f b7 ce             	movzwl %si,%ecx
  801587:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  80158a:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  80158d:	7f 03                	jg     801592 <lwip_recvfrom+0xdd>
      copylen = buflen;
    } else {
      copylen = len;
  80158f:	8b 75 10             	mov    0x10(%ebp),%esi
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  801592:	0f b7 ce             	movzwl %si,%ecx
  801595:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801598:	0f b7 d2             	movzwl %dx,%edx
  80159b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80159f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8015a3:	0f b7 d7             	movzwl %di,%edx
  8015a6:	03 55 0c             	add    0xc(%ebp),%edx
  8015a9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8015ad:	89 04 24             	mov    %eax,(%esp)
  8015b0:	e8 56 3f 00 00       	call   80550b <pbuf_copy_partial>

    off += copylen;
  8015b5:	01 f7                	add    %esi,%edi

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015b7:	8b 03                	mov    (%ebx),%eax
  8015b9:	89 04 24             	mov    %eax,(%esp)
  8015bc:	e8 c9 9f 00 00       	call   80b58a <netconn_type>
  8015c1:	83 f8 10             	cmp    $0x10,%eax
  8015c4:	75 22                	jne    8015e8 <lwip_recvfrom+0x133>
      len -= copylen;
  8015c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8015c9:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8015cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8015d0:	7e 1c                	jle    8015ee <lwip_recvfrom+0x139>
  8015d2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8015d5:	8b 02                	mov    (%edx),%eax
  8015d7:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8015db:	75 17                	jne    8015f4 <lwip_recvfrom+0x13f>
  8015dd:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8015e2:	0f 94 45 bb          	sete   -0x45(%ebp)
  8015e6:	eb 10                	jmp    8015f8 <lwip_recvfrom+0x143>
        done = 1;
      }
    } else {
      done = 1;
  8015e8:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
  8015ec:	eb 0a                	jmp    8015f8 <lwip_recvfrom+0x143>
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
  8015ee:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
  8015f2:	eb 04                	jmp    8015f8 <lwip_recvfrom+0x143>
  8015f4:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8015f8:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8015fc:	75 3f                	jne    80163d <lwip_recvfrom+0x188>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8015fe:	8b 03                	mov    (%ebx),%eax
  801600:	83 38 10             	cmpl   $0x10,(%eax)
  801603:	75 16                	jne    80161b <lwip_recvfrom+0x166>
  801605:	8b 45 bc             	mov    -0x44(%ebp),%eax
  801608:	2b 45 c0             	sub    -0x40(%ebp),%eax
  80160b:	85 c0                	test   %eax,%eax
  80160d:	7e 0c                	jle    80161b <lwip_recvfrom+0x166>
        sock->lastdata = buf;
  80160f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801612:	89 43 04             	mov    %eax,0x4(%ebx)
        sock->lastoffset += copylen;
  801615:	66 01 73 08          	add    %si,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  801619:	eb 18                	jmp    801633 <lwip_recvfrom+0x17e>
      } else {
        sock->lastdata = NULL;
  80161b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  801622:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801628:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80162b:	89 04 24             	mov    %eax,(%esp)
  80162e:	e8 d5 11 00 00       	call   802808 <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  801633:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  801637:	0f 84 a9 fe ff ff    	je     8014e6 <lwip_recvfrom+0x31>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80163d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801641:	0f 84 ac 00 00 00    	je     8016f3 <lwip_recvfrom+0x23e>
  801647:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80164b:	0f 84 a2 00 00 00    	je     8016f3 <lwip_recvfrom+0x23e>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801651:	8b 03                	mov    (%ebx),%eax
  801653:	89 04 24             	mov    %eax,(%esp)
  801656:	e8 2f 9f 00 00       	call   80b58a <netconn_type>
  80165b:	83 f8 10             	cmp    $0x10,%eax
  80165e:	75 25                	jne    801685 <lwip_recvfrom+0x1d0>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  801660:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801667:	00 
  801668:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80166b:	89 44 24 08          	mov    %eax,0x8(%esp)
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80166f:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801672:	89 44 24 04          	mov    %eax,0x4(%esp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  801676:	8b 03                	mov    (%ebx),%eax
  801678:	89 04 24             	mov    %eax,(%esp)
  80167b:	e8 37 9f 00 00       	call   80b5b7 <netconn_getaddr>
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801680:	8d 75 d8             	lea    -0x28(%ebp),%esi
  801683:	eb 0d                	jmp    801692 <lwip_recvfrom+0x1dd>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  801685:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801688:	8b 70 08             	mov    0x8(%eax),%esi
      port = netbuf_fromport(buf);
  80168b:	8b 40 0c             	mov    0xc(%eax),%eax
  80168e:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801692:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801699:	00 
  80169a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016a1:	00 
  8016a2:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016a5:	89 04 24             	mov    %eax,(%esp)
  8016a8:	e8 9d df 00 00       	call   80f64a <memset>
    sin.sin_len = sizeof(sin);
  8016ad:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8016b1:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8016b5:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8016b9:	89 04 24             	mov    %eax,(%esp)
  8016bc:	e8 bc 65 00 00       	call   807c7d <htons>
  8016c1:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8016c5:	8b 06                	mov    (%esi),%eax
  8016c7:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8016ca:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8016cd:	83 39 10             	cmpl   $0x10,(%ecx)
  8016d0:	76 06                	jbe    8016d8 <lwip_recvfrom+0x223>
      *fromlen = sizeof(sin);
  8016d2:	c7 01 10 00 00 00    	movl   $0x10,(%ecx)

    SMEMCPY(from, &sin, *fromlen);
  8016d8:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8016db:	8b 02                	mov    (%edx),%eax
  8016dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8016e1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8016e8:	8b 4d 18             	mov    0x18(%ebp),%ecx
  8016eb:	89 0c 24             	mov    %ecx,(%esp)
  8016ee:	e8 0b e0 00 00       	call   80f6fe <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8016f3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8016fa:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801701:	00 00 00 
  return off;
  801704:	0f b7 c7             	movzwl %di,%eax
  801707:	eb 05                	jmp    80170e <lwip_recvfrom+0x259>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801709:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  80170e:	83 c4 5c             	add    $0x5c,%esp
  801711:	5b                   	pop    %ebx
  801712:	5e                   	pop    %esi
  801713:	5f                   	pop    %edi
  801714:	5d                   	pop    %ebp
  801715:	c3                   	ret    

00801716 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  801716:	55                   	push   %ebp
  801717:	89 e5                	mov    %esp,%ebp
  801719:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  80171c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801723:	00 
  801724:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80172b:	00 
  80172c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801733:	00 
  801734:	8b 45 10             	mov    0x10(%ebp),%eax
  801737:	89 44 24 08          	mov    %eax,0x8(%esp)
  80173b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80173e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801742:	8b 45 08             	mov    0x8(%ebp),%eax
  801745:	89 04 24             	mov    %eax,(%esp)
  801748:	e8 68 fd ff ff       	call   8014b5 <lwip_recvfrom>
}
  80174d:	c9                   	leave  
  80174e:	c3                   	ret    

0080174f <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  80174f:	55                   	push   %ebp
  801750:	89 e5                	mov    %esp,%ebp
  801752:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801755:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80175c:	00 
  80175d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801764:	00 
  801765:	8b 45 14             	mov    0x14(%ebp),%eax
  801768:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80176c:	8b 45 10             	mov    0x10(%ebp),%eax
  80176f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801773:	8b 45 0c             	mov    0xc(%ebp),%eax
  801776:	89 44 24 04          	mov    %eax,0x4(%esp)
  80177a:	8b 45 08             	mov    0x8(%ebp),%eax
  80177d:	89 04 24             	mov    %eax,(%esp)
  801780:	e8 30 fd ff ff       	call   8014b5 <lwip_recvfrom>
}
  801785:	c9                   	leave  
  801786:	c3                   	ret    

00801787 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801787:	55                   	push   %ebp
  801788:	89 e5                	mov    %esp,%ebp
  80178a:	57                   	push   %edi
  80178b:	56                   	push   %esi
  80178c:	53                   	push   %ebx
  80178d:	83 ec 3c             	sub    $0x3c,%esp
  801790:	8b 7d 10             	mov    0x10(%ebp),%edi
  801793:	8b 5d 18             	mov    0x18(%ebp),%ebx
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  801796:	8b 45 08             	mov    0x8(%ebp),%eax
  801799:	e8 c6 f1 ff ff       	call   800964 <get_socket>
  80179e:	89 c6                	mov    %eax,%esi
  if (!sock)
  8017a0:	85 c0                	test   %eax,%eax
  8017a2:	0f 84 36 01 00 00    	je     8018de <lwip_sendto+0x157>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  8017a8:	8b 00                	mov    (%eax),%eax
  8017aa:	83 38 10             	cmpl   $0x10,(%eax)
  8017ad:	75 24                	jne    8017d3 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8017af:	8b 45 14             	mov    0x14(%ebp),%eax
  8017b2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8017b6:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8017ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  8017bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8017c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8017c4:	89 04 24             	mov    %eax,(%esp)
  8017c7:	e8 34 01 00 00       	call   801900 <lwip_send>
  8017cc:	89 c7                	mov    %eax,%edi
  8017ce:	e9 10 01 00 00       	jmp    8018e3 <lwip_sendto+0x15c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8017d3:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  8017d9:	76 1c                	jbe    8017f7 <lwip_sendto+0x70>
  8017db:	c7 44 24 08 34 0d 81 	movl   $0x810d34,0x8(%esp)
  8017e2:	00 
  8017e3:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8017ea:	00 
  8017eb:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  8017f2:	e8 81 d6 00 00       	call   80ee78 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017f7:	85 db                	test   %ebx,%ebx
  8017f9:	75 0a                	jne    801805 <lwip_sendto+0x7e>
  8017fb:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8017ff:	0f 84 e8 00 00 00    	je     8018ed <lwip_sendto+0x166>
  801805:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801809:	75 06                	jne    801811 <lwip_sendto+0x8a>
  80180b:	80 7b 01 02          	cmpb   $0x2,0x1(%ebx)
  80180f:	74 1c                	je     80182d <lwip_sendto+0xa6>
  801811:	c7 44 24 08 15 0d 81 	movl   $0x810d15,0x8(%esp)
  801818:	00 
  801819:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  801820:	00 
  801821:	c7 04 24 a2 0c 81 00 	movl   $0x810ca2,(%esp)
  801828:	e8 4b d6 00 00       	call   80ee78 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  80182d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801834:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  80183b:	85 db                	test   %ebx,%ebx
  80183d:	74 1e                	je     80185d <lwip_sendto+0xd6>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80183f:	8b 43 04             	mov    0x4(%ebx),%eax
  801842:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801845:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  801849:	89 04 24             	mov    %eax,(%esp)
  80184c:	e8 38 64 00 00       	call   807c89 <ntohs>
    buf.addr         = &remote_addr;
  801851:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801854:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801857:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80185b:	eb 14                	jmp    801871 <lwip_sendto+0xea>
  } else {
    remote_addr.addr = 0;
  80185d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801864:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80186b:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801871:	0f b7 c7             	movzwl %di,%eax
  801874:	89 44 24 08          	mov    %eax,0x8(%esp)
  801878:	8b 45 0c             	mov    0xc(%ebp),%eax
  80187b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80187f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801882:	89 04 24             	mov    %eax,(%esp)
  801885:	e8 9b 10 00 00       	call   802925 <netbuf_ref>
  80188a:	0f be d8             	movsbl %al,%ebx
  80188d:	85 db                	test   %ebx,%ebx
  80188f:	75 14                	jne    8018a5 <lwip_sendto+0x11e>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801891:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801894:	89 44 24 04          	mov    %eax,0x4(%esp)
  801898:	8b 06                	mov    (%esi),%eax
  80189a:	89 04 24             	mov    %eax,(%esp)
  80189d:	e8 1c a1 00 00       	call   80b9be <netconn_send>
  8018a2:	0f be d8             	movsbl %al,%ebx
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8018a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8018a8:	85 c0                	test   %eax,%eax
  8018aa:	74 08                	je     8018b4 <lwip_sendto+0x12d>
    pbuf_free(buf.p);
  8018ac:	89 04 24             	mov    %eax,(%esp)
  8018af:	e8 c1 34 00 00       	call   804d75 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8018b4:	89 d8                	mov    %ebx,%eax
  8018b6:	f7 d8                	neg    %eax
  8018b8:	83 f8 0e             	cmp    $0xe,%eax
  8018bb:	77 09                	ja     8018c6 <lwip_sendto+0x13f>
  8018bd:	8b 04 85 60 0d 81 00 	mov    0x810d60(,%eax,4),%eax
  8018c4:	eb 05                	jmp    8018cb <lwip_sendto+0x144>
  8018c6:	b8 05 00 00 00       	mov    $0x5,%eax
  8018cb:	89 46 10             	mov    %eax,0x10(%esi)
  8018ce:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
  return (err==ERR_OK?size:-1);
  8018d3:	85 db                	test   %ebx,%ebx
  8018d5:	74 0c                	je     8018e3 <lwip_sendto+0x15c>
  8018d7:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8018dc:	eb 05                	jmp    8018e3 <lwip_sendto+0x15c>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8018de:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8018e3:	89 f8                	mov    %edi,%eax
  8018e5:	83 c4 3c             	add    $0x3c,%esp
  8018e8:	5b                   	pop    %ebx
  8018e9:	5e                   	pop    %esi
  8018ea:	5f                   	pop    %edi
  8018eb:	5d                   	pop    %ebp
  8018ec:	c3                   	ret    
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8018ed:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8018f4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  8018fb:	e9 5d ff ff ff       	jmp    80185d <lwip_sendto+0xd6>

00801900 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  801900:	55                   	push   %ebp
  801901:	89 e5                	mov    %esp,%ebp
  801903:	57                   	push   %edi
  801904:	56                   	push   %esi
  801905:	53                   	push   %ebx
  801906:	83 ec 2c             	sub    $0x2c,%esp
  801909:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80190c:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80190f:	8b 45 08             	mov    0x8(%ebp),%eax
  801912:	e8 4d f0 ff ff       	call   800964 <get_socket>
  801917:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801919:	85 c0                	test   %eax,%eax
  80191b:	0f 84 86 00 00 00    	je     8019a7 <lwip_send+0xa7>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  801921:	8b 00                	mov    (%eax),%eax
  801923:	83 38 10             	cmpl   $0x10,(%eax)
  801926:	74 2e                	je     801956 <lwip_send+0x56>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801928:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80192f:	00 
  801930:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801937:	00 
  801938:	8b 45 14             	mov    0x14(%ebp),%eax
  80193b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80193f:	89 74 24 08          	mov    %esi,0x8(%esp)
  801943:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801947:	8b 45 08             	mov    0x8(%ebp),%eax
  80194a:	89 04 24             	mov    %eax,(%esp)
  80194d:	e8 35 fe ff ff       	call   801787 <lwip_sendto>
  801952:	89 c6                	mov    %eax,%esi
  801954:	eb 56                	jmp    8019ac <lwip_send+0xac>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801956:	8b 55 14             	mov    0x14(%ebp),%edx
  801959:	83 e2 10             	and    $0x10,%edx
  80195c:	83 fa 01             	cmp    $0x1,%edx
  80195f:	19 d2                	sbb    %edx,%edx
  801961:	83 e2 fe             	and    $0xfffffffe,%edx
  801964:	83 c2 03             	add    $0x3,%edx
  801967:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80196b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80196f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801973:	89 04 24             	mov    %eax,(%esp)
  801976:	e8 c0 a0 00 00       	call   80ba3b <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  80197b:	0f be d0             	movsbl %al,%edx
  80197e:	f7 da                	neg    %edx
  801980:	83 fa 0e             	cmp    $0xe,%edx
  801983:	77 09                	ja     80198e <lwip_send+0x8e>
  801985:	8b 14 95 60 0d 81 00 	mov    0x810d60(,%edx,4),%edx
  80198c:	eb 05                	jmp    801993 <lwip_send+0x93>
  80198e:	ba 05 00 00 00       	mov    $0x5,%edx
  801993:	89 53 10             	mov    %edx,0x10(%ebx)
  801996:	89 15 20 b2 b3 00    	mov    %edx,0xb3b220
  return (err==ERR_OK?size:-1);
  80199c:	84 c0                	test   %al,%al
  80199e:	74 0c                	je     8019ac <lwip_send+0xac>
  8019a0:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8019a5:	eb 05                	jmp    8019ac <lwip_send+0xac>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  8019a7:	be ff ff ff ff       	mov    $0xffffffff,%esi
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8019ac:	89 f0                	mov    %esi,%eax
  8019ae:	83 c4 2c             	add    $0x2c,%esp
  8019b1:	5b                   	pop    %ebx
  8019b2:	5e                   	pop    %esi
  8019b3:	5f                   	pop    %edi
  8019b4:	5d                   	pop    %ebp
  8019b5:	c3                   	ret    

008019b6 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  8019b6:	55                   	push   %ebp
  8019b7:	89 e5                	mov    %esp,%ebp
  8019b9:	56                   	push   %esi
  8019ba:	53                   	push   %ebx
  8019bb:	83 ec 10             	sub    $0x10,%esp
  8019be:	8b 45 0c             	mov    0xc(%ebp),%eax
  8019c1:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8019c4:	83 f8 02             	cmp    $0x2,%eax
  8019c7:	74 2b                	je     8019f4 <lwip_socket+0x3e>
  8019c9:	83 f8 03             	cmp    $0x3,%eax
  8019cc:	74 07                	je     8019d5 <lwip_socket+0x1f>
  8019ce:	83 f8 01             	cmp    $0x1,%eax
  8019d1:	75 6c                	jne    801a3f <lwip_socket+0x89>
  8019d3:	eb 4a                	jmp    801a1f <lwip_socket+0x69>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8019d5:	c7 44 24 08 cd 0e 80 	movl   $0x800ecd,0x8(%esp)
  8019dc:	00 
  8019dd:	0f b6 d2             	movzbl %dl,%edx
  8019e0:	89 54 24 04          	mov    %edx,0x4(%esp)
  8019e4:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8019eb:	e8 58 9a 00 00       	call   80b448 <netconn_new_with_proto_and_callback>
  8019f0:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019f2:	eb 5c                	jmp    801a50 <lwip_socket+0x9a>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8019f4:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  8019fa:	0f 94 c0             	sete   %al
  8019fd:	0f b6 c0             	movzbl %al,%eax
  801a00:	83 c0 20             	add    $0x20,%eax
  801a03:	c7 44 24 08 cd 0e 80 	movl   $0x800ecd,0x8(%esp)
  801a0a:	00 
  801a0b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801a12:	00 
  801a13:	89 04 24             	mov    %eax,(%esp)
  801a16:	e8 2d 9a 00 00       	call   80b448 <netconn_new_with_proto_and_callback>
  801a1b:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801a1d:	eb 31                	jmp    801a50 <lwip_socket+0x9a>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  801a1f:	c7 44 24 08 cd 0e 80 	movl   $0x800ecd,0x8(%esp)
  801a26:	00 
  801a27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801a2e:	00 
  801a2f:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  801a36:	e8 0d 9a 00 00       	call   80b448 <netconn_new_with_proto_and_callback>
  801a3b:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801a3d:	eb 11                	jmp    801a50 <lwip_socket+0x9a>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801a3f:	c7 05 20 b2 b3 00 16 	movl   $0x16,0xb3b220
  801a46:	00 00 00 
    return -1;
  801a49:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801a4e:	eb 44                	jmp    801a94 <lwip_socket+0xde>
  }

  if (!conn) {
  801a50:	85 db                	test   %ebx,%ebx
  801a52:	75 11                	jne    801a65 <lwip_socket+0xaf>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801a54:	c7 05 20 b2 b3 00 69 	movl   $0x69,0xb3b220
  801a5b:	00 00 00 
    return -1;
  801a5e:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801a63:	eb 2f                	jmp    801a94 <lwip_socket+0xde>
  }

  i = alloc_socket(conn);
  801a65:	89 d8                	mov    %ebx,%eax
  801a67:	e8 ba f3 ff ff       	call   800e26 <alloc_socket>
  801a6c:	89 c6                	mov    %eax,%esi

  if (i == -1) {
  801a6e:	83 f8 ff             	cmp    $0xffffffff,%eax
  801a71:	75 14                	jne    801a87 <lwip_socket+0xd1>
    netconn_delete(conn);
  801a73:	89 1c 24             	mov    %ebx,(%esp)
  801a76:	e8 d5 9a 00 00       	call   80b550 <netconn_delete>
    set_errno(ENFILE);
  801a7b:	c7 05 20 b2 b3 00 17 	movl   $0x17,0xb3b220
  801a82:	00 00 00 
    return -1;
  801a85:	eb 0d                	jmp    801a94 <lwip_socket+0xde>
  }
  conn->socket = i;
  801a87:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801a8a:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801a91:	00 00 00 
  return i;
}
  801a94:	89 f0                	mov    %esi,%eax
  801a96:	83 c4 10             	add    $0x10,%esp
  801a99:	5b                   	pop    %ebx
  801a9a:	5e                   	pop    %esi
  801a9b:	5d                   	pop    %ebp
  801a9c:	c3                   	ret    

00801a9d <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801a9d:	55                   	push   %ebp
  801a9e:	89 e5                	mov    %esp,%ebp
  801aa0:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801aa3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801aaa:	00 
  801aab:	8b 45 10             	mov    0x10(%ebp),%eax
  801aae:	89 44 24 08          	mov    %eax,0x8(%esp)
  801ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
  801ab5:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ab9:	8b 45 08             	mov    0x8(%ebp),%eax
  801abc:	89 04 24             	mov    %eax,(%esp)
  801abf:	e8 3c fe ff ff       	call   801900 <lwip_send>
}
  801ac4:	c9                   	leave  
  801ac5:	c3                   	ret    

00801ac6 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801ac6:	55                   	push   %ebp
  801ac7:	89 e5                	mov    %esp,%ebp
  801ac9:	57                   	push   %edi
  801aca:	56                   	push   %esi
  801acb:	53                   	push   %ebx
  801acc:	83 ec 5c             	sub    $0x5c,%esp
  801acf:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801ad2:	8b 75 10             	mov    0x10(%ebp),%esi
  801ad5:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801ad8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801adf:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801ae2:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801ae5:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801ae8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801aef:	a1 64 50 81 00       	mov    0x815064,%eax
  801af4:	89 04 24             	mov    %eax,(%esp)
  801af7:	e8 94 3b 00 00       	call   805690 <sys_sem_wait>

  if (readset)
  801afc:	85 ff                	test   %edi,%edi
  801afe:	74 07                	je     801b07 <lwip_select+0x41>
    lreadset = *readset;
  801b00:	8b 07                	mov    (%edi),%eax
  801b02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801b05:	eb 1b                	jmp    801b22 <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  801b07:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b0e:	00 
  801b0f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b16:	00 
  801b17:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801b1a:	89 04 24             	mov    %eax,(%esp)
  801b1d:	e8 28 db 00 00       	call   80f64a <memset>
  if (writeset)
  801b22:	85 f6                	test   %esi,%esi
  801b24:	74 07                	je     801b2d <lwip_select+0x67>
    lwriteset = *writeset;
  801b26:	8b 06                	mov    (%esi),%eax
  801b28:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801b2b:	eb 1b                	jmp    801b48 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  801b2d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b34:	00 
  801b35:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b3c:	00 
  801b3d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b40:	89 04 24             	mov    %eax,(%esp)
  801b43:	e8 02 db 00 00       	call   80f64a <memset>
  if (exceptset)
  801b48:	85 db                	test   %ebx,%ebx
  801b4a:	74 07                	je     801b53 <lwip_select+0x8d>
    lexceptset = *exceptset;
  801b4c:	8b 03                	mov    (%ebx),%eax
  801b4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801b51:	eb 1b                	jmp    801b6e <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  801b53:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b5a:	00 
  801b5b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b62:	00 
  801b63:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b66:	89 04 24             	mov    %eax,(%esp)
  801b69:	e8 dc da 00 00       	call   80f64a <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b6e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b71:	89 04 24             	mov    %eax,(%esp)
  801b74:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b77:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b7a:	8b 45 08             	mov    0x8(%ebp),%eax
  801b7d:	e8 b1 f0 ff ff       	call   800c33 <lwip_selscan>
  801b82:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801b85:	85 c0                	test   %eax,%eax
  801b87:	0f 85 21 02 00 00    	jne    801dae <lwip_select+0x2e8>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801b8d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b91:	0f 84 86 00 00 00    	je     801c1d <lwip_select+0x157>
  801b97:	8b 45 18             	mov    0x18(%ebp),%eax
  801b9a:	83 38 00             	cmpl   $0x0,(%eax)
  801b9d:	0f 85 48 02 00 00    	jne    801deb <lwip_select+0x325>
  801ba3:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801ba7:	0f 85 3e 02 00 00    	jne    801deb <lwip_select+0x325>
      sys_sem_signal(selectsem);
  801bad:	a1 64 50 81 00       	mov    0x815064,%eax
  801bb2:	89 04 24             	mov    %eax,(%esp)
  801bb5:	e8 2b 8c 00 00       	call   80a7e5 <sys_sem_signal>
      if (readset)
  801bba:	85 ff                	test   %edi,%edi
  801bbc:	74 18                	je     801bd6 <lwip_select+0x110>
        FD_ZERO(readset);
  801bbe:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bc5:	00 
  801bc6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bcd:	00 
  801bce:	89 3c 24             	mov    %edi,(%esp)
  801bd1:	e8 74 da 00 00       	call   80f64a <memset>
      if (writeset)
  801bd6:	85 f6                	test   %esi,%esi
  801bd8:	74 18                	je     801bf2 <lwip_select+0x12c>
        FD_ZERO(writeset);
  801bda:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801be1:	00 
  801be2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801be9:	00 
  801bea:	89 34 24             	mov    %esi,(%esp)
  801bed:	e8 58 da 00 00       	call   80f64a <memset>
      if (exceptset)
  801bf2:	85 db                	test   %ebx,%ebx
  801bf4:	74 18                	je     801c0e <lwip_select+0x148>
        FD_ZERO(exceptset);
  801bf6:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bfd:	00 
  801bfe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c05:	00 
  801c06:	89 1c 24             	mov    %ebx,(%esp)
  801c09:	e8 3c da 00 00       	call   80f64a <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801c0e:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801c15:	00 00 00 
  
      return 0;
  801c18:	e9 c3 01 00 00       	jmp    801de0 <lwip_select+0x31a>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801c1d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c24:	e8 ae 88 00 00       	call   80a4d7 <sys_sem_new>
  801c29:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801c2c:	a1 00 53 81 00       	mov    0x815300,%eax
  801c31:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801c34:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801c37:	a3 00 53 81 00       	mov    %eax,0x815300
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801c3c:	a1 64 50 81 00       	mov    0x815064,%eax
  801c41:	89 04 24             	mov    %eax,(%esp)
  801c44:	e8 9c 8b 00 00       	call   80a7e5 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801c49:	b8 00 00 00 00       	mov    $0x0,%eax
  801c4e:	eb 05                	jmp    801c55 <lwip_select+0x18f>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
  801c50:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801c55:	89 44 24 04          	mov    %eax,0x4(%esp)
  801c59:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c5c:	89 04 24             	mov    %eax,(%esp)
  801c5f:	e8 ff 3b 00 00       	call   805863 <sys_sem_wait_timeout>
  801c64:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801c67:	a1 64 50 81 00       	mov    0x815064,%eax
  801c6c:	89 04 24             	mov    %eax,(%esp)
  801c6f:	e8 1c 3a 00 00       	call   805690 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801c74:	a1 00 53 81 00       	mov    0x815300,%eax
  801c79:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801c7c:	39 d0                	cmp    %edx,%eax
  801c7e:	75 1b                	jne    801c9b <lwip_select+0x1d5>
      select_cb_list = select_cb.next;
  801c80:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801c83:	a3 00 53 81 00       	mov    %eax,0x815300
  801c88:	eb 18                	jmp    801ca2 <lwip_select+0x1dc>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c8a:	8b 10                	mov    (%eax),%edx
  801c8c:	39 ca                	cmp    %ecx,%edx
  801c8e:	75 07                	jne    801c97 <lwip_select+0x1d1>
          p_selcb->next = select_cb.next;
  801c90:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801c93:	89 10                	mov    %edx,(%eax)
          break;
  801c95:	eb 0b                	jmp    801ca2 <lwip_select+0x1dc>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c97:	89 d0                	mov    %edx,%eax
  801c99:	eb 03                	jmp    801c9e <lwip_select+0x1d8>
        if (p_selcb->next == &select_cb) {
  801c9b:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c9e:	85 c0                	test   %eax,%eax
  801ca0:	75 e8                	jne    801c8a <lwip_select+0x1c4>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801ca2:	a1 64 50 81 00       	mov    0x815064,%eax
  801ca7:	89 04 24             	mov    %eax,(%esp)
  801caa:	e8 36 8b 00 00       	call   80a7e5 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801caf:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801cb2:	89 04 24             	mov    %eax,(%esp)
  801cb5:	e8 b9 88 00 00       	call   80a573 <sys_sem_free>
    if (i == 0)  {
  801cba:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801cbe:	75 63                	jne    801d23 <lwip_select+0x25d>
      /* Timeout */
      if (readset)
  801cc0:	85 ff                	test   %edi,%edi
  801cc2:	74 18                	je     801cdc <lwip_select+0x216>
        FD_ZERO(readset);
  801cc4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ccb:	00 
  801ccc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cd3:	00 
  801cd4:	89 3c 24             	mov    %edi,(%esp)
  801cd7:	e8 6e d9 00 00       	call   80f64a <memset>
      if (writeset)
  801cdc:	85 f6                	test   %esi,%esi
  801cde:	74 18                	je     801cf8 <lwip_select+0x232>
        FD_ZERO(writeset);
  801ce0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ce7:	00 
  801ce8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cef:	00 
  801cf0:	89 34 24             	mov    %esi,(%esp)
  801cf3:	e8 52 d9 00 00       	call   80f64a <memset>
      if (exceptset)
  801cf8:	85 db                	test   %ebx,%ebx
  801cfa:	74 18                	je     801d14 <lwip_select+0x24e>
        FD_ZERO(exceptset);
  801cfc:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d03:	00 
  801d04:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d0b:	00 
  801d0c:	89 1c 24             	mov    %ebx,(%esp)
  801d0f:	e8 36 d9 00 00       	call   80f64a <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801d14:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801d1b:	00 00 00 
  
      return 0;
  801d1e:	e9 bd 00 00 00       	jmp    801de0 <lwip_select+0x31a>
    }
    
    if (readset)
  801d23:	85 ff                	test   %edi,%edi
  801d25:	74 07                	je     801d2e <lwip_select+0x268>
      lreadset = *readset;
  801d27:	8b 07                	mov    (%edi),%eax
  801d29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801d2c:	eb 1b                	jmp    801d49 <lwip_select+0x283>
    else
      FD_ZERO(&lreadset);
  801d2e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d35:	00 
  801d36:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d3d:	00 
  801d3e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801d41:	89 04 24             	mov    %eax,(%esp)
  801d44:	e8 01 d9 00 00       	call   80f64a <memset>
    if (writeset)
  801d49:	85 f6                	test   %esi,%esi
  801d4b:	74 07                	je     801d54 <lwip_select+0x28e>
      lwriteset = *writeset;
  801d4d:	8b 06                	mov    (%esi),%eax
  801d4f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801d52:	eb 1b                	jmp    801d6f <lwip_select+0x2a9>
    else
      FD_ZERO(&lwriteset);
  801d54:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d5b:	00 
  801d5c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d63:	00 
  801d64:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801d67:	89 04 24             	mov    %eax,(%esp)
  801d6a:	e8 db d8 00 00       	call   80f64a <memset>
    if (exceptset)
  801d6f:	85 db                	test   %ebx,%ebx
  801d71:	74 07                	je     801d7a <lwip_select+0x2b4>
      lexceptset = *exceptset;
  801d73:	8b 03                	mov    (%ebx),%eax
  801d75:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801d78:	eb 1b                	jmp    801d95 <lwip_select+0x2cf>
    else
      FD_ZERO(&lexceptset);
  801d7a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d81:	00 
  801d82:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d89:	00 
  801d8a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d8d:	89 04 24             	mov    %eax,(%esp)
  801d90:	e8 b5 d8 00 00       	call   80f64a <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801d95:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d98:	89 04 24             	mov    %eax,(%esp)
  801d9b:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801d9e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801da1:	8b 45 08             	mov    0x8(%ebp),%eax
  801da4:	e8 8a ee ff ff       	call   800c33 <lwip_selscan>
  801da9:	89 45 b0             	mov    %eax,-0x50(%ebp)
  801dac:	eb 0d                	jmp    801dbb <lwip_select+0x2f5>
  } else
    sys_sem_signal(selectsem);
  801dae:	a1 64 50 81 00       	mov    0x815064,%eax
  801db3:	89 04 24             	mov    %eax,(%esp)
  801db6:	e8 2a 8a 00 00       	call   80a7e5 <sys_sem_signal>
  
  if (readset)
  801dbb:	85 ff                	test   %edi,%edi
  801dbd:	74 05                	je     801dc4 <lwip_select+0x2fe>
    *readset = lreadset;
  801dbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801dc2:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801dc4:	85 f6                	test   %esi,%esi
  801dc6:	74 05                	je     801dcd <lwip_select+0x307>
    *writeset = lwriteset;
  801dc8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801dcb:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801dcd:	85 db                	test   %ebx,%ebx
  801dcf:	74 05                	je     801dd6 <lwip_select+0x310>
    *exceptset = lexceptset;
  801dd1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801dd4:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801dd6:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  801ddd:	00 00 00 
  
  return nready;
}
  801de0:	8b 45 b0             	mov    -0x50(%ebp),%eax
  801de3:	83 c4 5c             	add    $0x5c,%esp
  801de6:	5b                   	pop    %ebx
  801de7:	5e                   	pop    %esi
  801de8:	5f                   	pop    %edi
  801de9:	5d                   	pop    %ebp
  801dea:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801deb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801df2:	e8 e0 86 00 00       	call   80a4d7 <sys_sem_new>
  801df7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801dfa:	a1 00 53 81 00       	mov    0x815300,%eax
  801dff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801e02:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801e05:	a3 00 53 81 00       	mov    %eax,0x815300
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801e0a:	a1 64 50 81 00       	mov    0x815064,%eax
  801e0f:	89 04 24             	mov    %eax,(%esp)
  801e12:	e8 ce 89 00 00       	call   80a7e5 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801e17:	8b 55 18             	mov    0x18(%ebp),%edx
  801e1a:	8b 02                	mov    (%edx),%eax
  801e1c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801e1f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801e22:	8d 04 80             	lea    (%eax,%eax,4),%eax
  801e25:	89 45 a8             	mov    %eax,-0x58(%ebp)
  801e28:	8b 52 04             	mov    0x4(%edx),%edx
  801e2b:	81 c2 f4 01 00 00    	add    $0x1f4,%edx
  801e31:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  801e34:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  801e39:	f7 ea                	imul   %edx
  801e3b:	89 d1                	mov    %edx,%ecx
  801e3d:	c1 f9 06             	sar    $0x6,%ecx
  801e40:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801e43:	99                   	cltd   
  801e44:	89 c8                	mov    %ecx,%eax
  801e46:	29 d0                	sub    %edx,%eax
  801e48:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  801e4b:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
      if(msectimeout == 0)
  801e4e:	85 c0                	test   %eax,%eax
  801e50:	0f 84 fa fd ff ff    	je     801c50 <lwip_select+0x18a>
  801e56:	e9 fa fd ff ff       	jmp    801c55 <lwip_select+0x18f>

00801e5b <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801e5b:	55                   	push   %ebp
  801e5c:	89 e5                	mov    %esp,%ebp
  801e5e:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801e61:	8b 45 08             	mov    0x8(%ebp),%eax
  801e64:	89 04 24             	mov    %eax,(%esp)
  801e67:	e8 7b f4 ff ff       	call   8012e7 <lwip_close>
}
  801e6c:	c9                   	leave  
  801e6d:	c3                   	ret    

00801e6e <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e6e:	55                   	push   %ebp
  801e6f:	89 e5                	mov    %esp,%ebp
  801e71:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801e74:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e7b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e7e:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e81:	8b 45 08             	mov    0x8(%ebp),%eax
  801e84:	e8 dd ee ff ff       	call   800d66 <lwip_getaddrname>
}
  801e89:	c9                   	leave  
  801e8a:	c3                   	ret    

00801e8b <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e8b:	55                   	push   %ebp
  801e8c:	89 e5                	mov    %esp,%ebp
  801e8e:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801e91:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801e98:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e9b:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e9e:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea1:	e8 c0 ee ff ff       	call   800d66 <lwip_getaddrname>
}
  801ea6:	c9                   	leave  
  801ea7:	c3                   	ret    

00801ea8 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801ea8:	55                   	push   %ebp
  801ea9:	89 e5                	mov    %esp,%ebp
  801eab:	57                   	push   %edi
  801eac:	56                   	push   %esi
  801ead:	53                   	push   %ebx
  801eae:	83 ec 3c             	sub    $0x3c,%esp
  801eb1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801eb4:	8b 75 18             	mov    0x18(%ebp),%esi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801eb7:	8b 45 08             	mov    0x8(%ebp),%eax
  801eba:	e8 a5 ea ff ff       	call   800964 <get_socket>
  801ebf:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801ec1:	85 c0                	test   %eax,%eax
  801ec3:	0f 84 62 01 00 00    	je     80202b <lwip_getsockopt+0x183>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801ec9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801ecd:	74 04                	je     801ed3 <lwip_getsockopt+0x2b>
  801ecf:	85 f6                	test   %esi,%esi
  801ed1:	75 1b                	jne    801eee <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801ed3:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801eda:	c7 05 20 b2 b3 00 0e 	movl   $0xe,0xb3b220
  801ee1:	00 00 00 
    return -1;
  801ee4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ee9:	e9 49 01 00 00       	jmp    802037 <lwip_getsockopt+0x18f>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801eee:	83 ff 06             	cmp    $0x6,%edi
  801ef1:	0f 84 8d 00 00 00    	je     801f84 <lwip_getsockopt+0xdc>
  801ef7:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  801efd:	74 09                	je     801f08 <lwip_getsockopt+0x60>
  801eff:	85 ff                	test   %edi,%edi
  801f01:	74 6d                	je     801f70 <lwip_getsockopt+0xc8>
  801f03:	e9 9f 00 00 00       	jmp    801fa7 <lwip_getsockopt+0xff>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801f08:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f0c:	74 35                	je     801f43 <lwip_getsockopt+0x9b>
  801f0e:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f12:	7f 12                	jg     801f26 <lwip_getsockopt+0x7e>
  801f14:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801f18:	74 29                	je     801f43 <lwip_getsockopt+0x9b>
  801f1a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801f1e:	0f 85 87 00 00 00    	jne    801fab <lwip_getsockopt+0x103>
  801f24:	eb 1d                	jmp    801f43 <lwip_getsockopt+0x9b>
  801f26:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801f2d:	7c 7c                	jl     801fab <lwip_getsockopt+0x103>
  801f2f:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801f36:	7e 0b                	jle    801f43 <lwip_getsockopt+0x9b>
  801f38:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f3f:	75 6a                	jne    801fab <lwip_getsockopt+0x103>
  801f41:	eb 0b                	jmp    801f4e <lwip_getsockopt+0xa6>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801f43:	83 3e 03             	cmpl   $0x3,(%esi)
  801f46:	0f 86 f3 00 00 00    	jbe    80203f <lwip_getsockopt+0x197>
  801f4c:	eb 7d                	jmp    801fcb <lwip_getsockopt+0x123>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f4e:	83 3e 04             	cmpl   $0x4,(%esi)
  801f51:	19 c0                	sbb    %eax,%eax
  801f53:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f56:	8b 13                	mov    (%ebx),%edx
  801f58:	83 3a 20             	cmpl   $0x20,(%edx)
  801f5b:	0f 85 e5 00 00 00    	jne    802046 <lwip_getsockopt+0x19e>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f61:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f64:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f68:	0f 85 df 00 00 00    	jne    80204d <lwip_getsockopt+0x1a5>
  801f6e:	eb 45                	jmp    801fb5 <lwip_getsockopt+0x10d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801f70:	8b 45 10             	mov    0x10(%ebp),%eax
  801f73:	48                   	dec    %eax
  801f74:	83 f8 01             	cmp    $0x1,%eax
  801f77:	77 36                	ja     801faf <lwip_getsockopt+0x107>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801f79:	83 3e 03             	cmpl   $0x3,(%esi)
  801f7c:	0f 86 d2 00 00 00    	jbe    802054 <lwip_getsockopt+0x1ac>
  801f82:	eb 47                	jmp    801fcb <lwip_getsockopt+0x123>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801f84:	83 3e 03             	cmpl   $0x3,(%esi)
  801f87:	0f 86 ce 00 00 00    	jbe    80205b <lwip_getsockopt+0x1b3>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f8d:	8b 00                	mov    (%eax),%eax
  801f8f:	83 38 10             	cmpl   $0x10,(%eax)
  801f92:	0f 85 9a 00 00 00    	jne    802032 <lwip_getsockopt+0x18a>
      return 0;

    switch (optname) {
  801f98:	8b 45 10             	mov    0x10(%ebp),%eax
  801f9b:	48                   	dec    %eax
  801f9c:	83 f8 01             	cmp    $0x1,%eax
  801f9f:	0f 87 bd 00 00 00    	ja     802062 <lwip_getsockopt+0x1ba>
  801fa5:	eb 0c                	jmp    801fb3 <lwip_getsockopt+0x10b>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801fa7:	b0 5c                	mov    $0x5c,%al
  801fa9:	eb 0a                	jmp    801fb5 <lwip_getsockopt+0x10d>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801fab:	b0 5c                	mov    $0x5c,%al
  801fad:	eb 06                	jmp    801fb5 <lwip_getsockopt+0x10d>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801faf:	b0 5c                	mov    $0x5c,%al
  801fb1:	eb 02                	jmp    801fb5 <lwip_getsockopt+0x10d>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801fb3:	b0 00                	mov    $0x0,%al
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801fb5:	84 c0                	test   %al,%al
  801fb7:	74 12                	je     801fcb <lwip_getsockopt+0x123>
    sock_set_errno(sock, err);
  801fb9:	0f be c0             	movsbl %al,%eax
  801fbc:	89 43 10             	mov    %eax,0x10(%ebx)
  801fbf:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  801fc4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fc9:	eb 6c                	jmp    802037 <lwip_getsockopt+0x18f>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801fcb:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801fce:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  data.optname = optname;
  801fd1:	8b 45 10             	mov    0x10(%ebp),%eax
  801fd4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801fd7:	8b 45 14             	mov    0x14(%ebp),%eax
  801fda:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801fdd:	89 75 e0             	mov    %esi,-0x20(%ebp)
  data.err = err;
  801fe0:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801fe4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  801feb:	00 
  801fec:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801fef:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ff3:	c7 04 24 a8 0a 80 00 	movl   $0x800aa8,(%esp)
  801ffa:	e8 09 06 00 00       	call   802608 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801fff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802006:	00 
  802007:	8b 03                	mov    (%ebx),%eax
  802009:	8b 40 10             	mov    0x10(%eax),%eax
  80200c:	89 04 24             	mov    %eax,(%esp)
  80200f:	e8 35 88 00 00       	call   80a849 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  802014:	8a 45 e4             	mov    -0x1c(%ebp),%al

  sock_set_errno(sock, err);
  802017:	0f be d0             	movsbl %al,%edx
  80201a:	89 53 10             	mov    %edx,0x10(%ebx)
  80201d:	89 15 20 b2 b3 00    	mov    %edx,0xb3b220
  return err ? -1 : 0;
  802023:	3c 01                	cmp    $0x1,%al
  802025:	19 c0                	sbb    %eax,%eax
  802027:	f7 d0                	not    %eax
  802029:	eb 0c                	jmp    802037 <lwip_getsockopt+0x18f>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  80202b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802030:	eb 05                	jmp    802037 <lwip_getsockopt+0x18f>
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;
  802032:	b8 00 00 00 00       	mov    $0x0,%eax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  802037:	83 c4 3c             	add    $0x3c,%esp
  80203a:	5b                   	pop    %ebx
  80203b:	5e                   	pop    %esi
  80203c:	5f                   	pop    %edi
  80203d:	5d                   	pop    %ebp
  80203e:	c3                   	ret    
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80203f:	b0 16                	mov    $0x16,%al
  802041:	e9 73 ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802046:	b0 61                	mov    $0x61,%al
  802048:	e9 6c ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>
  80204d:	b0 61                	mov    $0x61,%al
  80204f:	e9 65 ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  802054:	b0 16                	mov    $0x16,%al
  802056:	e9 5e ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  80205b:	b0 16                	mov    $0x16,%al
  80205d:	e9 57 ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  802062:	b0 5c                	mov    $0x5c,%al
  802064:	e9 50 ff ff ff       	jmp    801fb9 <lwip_getsockopt+0x111>

00802069 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  802069:	55                   	push   %ebp
  80206a:	89 e5                	mov    %esp,%ebp
  80206c:	57                   	push   %edi
  80206d:	56                   	push   %esi
  80206e:	53                   	push   %ebx
  80206f:	83 ec 3c             	sub    $0x3c,%esp
  802072:	8b 75 0c             	mov    0xc(%ebp),%esi
  802075:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  802078:	8b 45 08             	mov    0x8(%ebp),%eax
  80207b:	e8 e4 e8 ff ff       	call   800964 <get_socket>
  802080:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  802082:	85 c0                	test   %eax,%eax
  802084:	0f 84 40 01 00 00    	je     8021ca <lwip_setsockopt+0x161>
    return -1;

  if (NULL == optval) {
  80208a:	85 ff                	test   %edi,%edi
  80208c:	75 1b                	jne    8020a9 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  80208e:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  802095:	c7 05 20 b2 b3 00 0e 	movl   $0xe,0xb3b220
  80209c:	00 00 00 
    return -1;
  80209f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020a4:	e9 2d 01 00 00       	jmp    8021d6 <lwip_setsockopt+0x16d>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8020a9:	83 fe 06             	cmp    $0x6,%esi
  8020ac:	74 6d                	je     80211b <lwip_setsockopt+0xb2>
  8020ae:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8020b4:	74 09                	je     8020bf <lwip_setsockopt+0x56>
  8020b6:	85 f6                	test   %esi,%esi
  8020b8:	74 4c                	je     802106 <lwip_setsockopt+0x9d>
  8020ba:	e9 80 00 00 00       	jmp    80213f <lwip_setsockopt+0xd6>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8020bf:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8020c3:	74 0f                	je     8020d4 <lwip_setsockopt+0x6b>
  8020c5:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8020cc:	74 15                	je     8020e3 <lwip_setsockopt+0x7a>
  8020ce:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8020d2:	75 72                	jne    802146 <lwip_setsockopt+0xdd>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8020d4:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020d8:	0f 86 00 01 00 00    	jbe    8021de <lwip_setsockopt+0x175>
  8020de:	e9 89 00 00 00       	jmp    80216c <lwip_setsockopt+0x103>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  8020e3:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8020e7:	19 c0                	sbb    %eax,%eax
  8020e9:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020ec:	8b 13                	mov    (%ebx),%edx
  8020ee:	83 3a 20             	cmpl   $0x20,(%edx)
  8020f1:	0f 85 f1 00 00 00    	jne    8021e8 <lwip_setsockopt+0x17f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8020f7:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020fa:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8020fe:	0f 85 ee 00 00 00    	jne    8021f2 <lwip_setsockopt+0x189>
  802104:	eb 53                	jmp    802159 <lwip_setsockopt+0xf0>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  802106:	8b 45 10             	mov    0x10(%ebp),%eax
  802109:	48                   	dec    %eax
  80210a:	83 f8 01             	cmp    $0x1,%eax
  80210d:	77 3e                	ja     80214d <lwip_setsockopt+0xe4>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  80210f:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  802113:	0f 86 e3 00 00 00    	jbe    8021fc <lwip_setsockopt+0x193>
  802119:	eb 51                	jmp    80216c <lwip_setsockopt+0x103>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  80211b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80211f:	0f 86 e1 00 00 00    	jbe    802206 <lwip_setsockopt+0x19d>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802125:	8b 00                	mov    (%eax),%eax
  802127:	83 38 10             	cmpl   $0x10,(%eax)
  80212a:	0f 85 a1 00 00 00    	jne    8021d1 <lwip_setsockopt+0x168>
      return 0;

    switch (optname) {
  802130:	8b 45 10             	mov    0x10(%ebp),%eax
  802133:	48                   	dec    %eax
  802134:	83 f8 01             	cmp    $0x1,%eax
  802137:	0f 87 d3 00 00 00    	ja     802210 <lwip_setsockopt+0x1a7>
  80213d:	eb 15                	jmp    802154 <lwip_setsockopt+0xeb>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  80213f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802144:	eb 13                	jmp    802159 <lwip_setsockopt+0xf0>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  802146:	b8 5c 00 00 00       	mov    $0x5c,%eax
  80214b:	eb 0c                	jmp    802159 <lwip_setsockopt+0xf0>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  80214d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802152:	eb 05                	jmp    802159 <lwip_setsockopt+0xf0>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  802154:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  802159:	85 c0                	test   %eax,%eax
  80215b:	74 0f                	je     80216c <lwip_setsockopt+0x103>
    sock_set_errno(sock, err);
  80215d:	89 43 10             	mov    %eax,0x10(%ebx)
  802160:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
    return -1;
  802165:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80216a:	eb 6a                	jmp    8021d6 <lwip_setsockopt+0x16d>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  80216c:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  80216f:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  802172:	8b 45 10             	mov    0x10(%ebp),%eax
  802175:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  802178:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  80217b:	8d 45 18             	lea    0x18(%ebp),%eax
  80217e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  802181:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  802185:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80218c:	00 
  80218d:	8d 45 cc             	lea    -0x34(%ebp),%eax
  802190:	89 44 24 04          	mov    %eax,0x4(%esp)
  802194:	c7 04 24 a3 09 80 00 	movl   $0x8009a3,(%esp)
  80219b:	e8 68 04 00 00       	call   802608 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8021a0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8021a7:	00 
  8021a8:	8b 03                	mov    (%ebx),%eax
  8021aa:	8b 40 10             	mov    0x10(%eax),%eax
  8021ad:	89 04 24             	mov    %eax,(%esp)
  8021b0:	e8 94 86 00 00       	call   80a849 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8021b5:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8021b9:	89 43 10             	mov    %eax,0x10(%ebx)
  8021bc:	a3 20 b2 b3 00       	mov    %eax,0xb3b220
  return err ? -1 : 0;
  8021c1:	83 f8 01             	cmp    $0x1,%eax
  8021c4:	19 c0                	sbb    %eax,%eax
  8021c6:	f7 d0                	not    %eax
  8021c8:	eb 0c                	jmp    8021d6 <lwip_setsockopt+0x16d>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  8021ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8021cf:	eb 05                	jmp    8021d6 <lwip_setsockopt+0x16d>
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;
  8021d1:	b8 00 00 00 00       	mov    $0x0,%eax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  8021d6:	83 c4 3c             	add    $0x3c,%esp
  8021d9:	5b                   	pop    %ebx
  8021da:	5e                   	pop    %esi
  8021db:	5f                   	pop    %edi
  8021dc:	5d                   	pop    %ebp
  8021dd:	c3                   	ret    
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021de:	b8 16 00 00 00       	mov    $0x16,%eax
  8021e3:	e9 75 ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8021e8:	b8 61 00 00 00       	mov    $0x61,%eax
  8021ed:	e9 6b ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>
  8021f2:	b8 61 00 00 00       	mov    $0x61,%eax
  8021f7:	e9 61 ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021fc:	b8 16 00 00 00       	mov    $0x16,%eax
  802201:	e9 57 ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  802206:	b8 16 00 00 00       	mov    $0x16,%eax
  80220b:	e9 4d ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  802210:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802215:	e9 43 ff ff ff       	jmp    80215d <lwip_setsockopt+0xf4>

0080221a <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  80221a:	55                   	push   %ebp
  80221b:	89 e5                	mov    %esp,%ebp
  80221d:	56                   	push   %esi
  80221e:	53                   	push   %ebx
  80221f:	8b 75 0c             	mov    0xc(%ebp),%esi
  802222:	8b 5d 10             	mov    0x10(%ebp),%ebx
  struct lwip_socket *sock = get_socket(s);
  802225:	8b 45 08             	mov    0x8(%ebp),%eax
  802228:	e8 37 e7 ff ff       	call   800964 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80222d:	85 c0                	test   %eax,%eax
  80222f:	0f 84 a6 00 00 00    	je     8022db <lwip_ioctl+0xc1>
    return -1;

  switch (cmd) {
  802235:	81 fe 7e 66 04 80    	cmp    $0x8004667e,%esi
  80223b:	74 57                	je     802294 <lwip_ioctl+0x7a>
  80223d:	81 fe 7f 66 04 40    	cmp    $0x4004667f,%esi
  802243:	75 7e                	jne    8022c3 <lwip_ioctl+0xa9>
  case FIONREAD:
    if (!argp) {
  802245:	85 db                	test   %ebx,%ebx
  802247:	75 18                	jne    802261 <lwip_ioctl+0x47>
      sock_set_errno(sock, EINVAL);
  802249:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  802250:	c7 05 20 b2 b3 00 16 	movl   $0x16,0xb3b220
  802257:	00 00 00 
      return -1;
  80225a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80225f:	eb 7f                	jmp    8022e0 <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  802261:	8b 10                	mov    (%eax),%edx
  802263:	8b 52 20             	mov    0x20(%edx),%edx
  802266:	66 89 13             	mov    %dx,(%ebx)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802269:	8b 48 04             	mov    0x4(%eax),%ecx
  80226c:	85 c9                	test   %ecx,%ecx
  80226e:	74 0c                	je     80227c <lwip_ioctl+0x62>
      buflen = netbuf_len(sock->lastdata);
  802270:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  802272:	03 51 08             	add    0x8(%ecx),%edx

      *((u16_t*)argp) += buflen;
  802275:	66 2b 50 08          	sub    0x8(%eax),%dx
  802279:	66 89 13             	mov    %dx,(%ebx)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80227c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802283:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  80228a:	00 00 00 
    return 0;
  80228d:	b8 00 00 00 00       	mov    $0x0,%eax
  802292:	eb 4c                	jmp    8022e0 <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  802294:	85 db                	test   %ebx,%ebx
  802296:	74 0d                	je     8022a5 <lwip_ioctl+0x8b>
  802298:	83 3b 00             	cmpl   $0x0,(%ebx)
  80229b:	74 08                	je     8022a5 <lwip_ioctl+0x8b>
      sock->flags |= O_NONBLOCK;
  80229d:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  8022a3:	eb 06                	jmp    8022ab <lwip_ioctl+0x91>
    else
      sock->flags &= ~O_NONBLOCK;
  8022a5:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8022ab:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8022b2:	c7 05 20 b2 b3 00 00 	movl   $0x0,0xb3b220
  8022b9:	00 00 00 
    return 0;
  8022bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8022c1:	eb 1d                	jmp    8022e0 <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8022c3:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8022ca:	c7 05 20 b2 b3 00 26 	movl   $0x26,0xb3b220
  8022d1:	00 00 00 
    return -1;
  8022d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022d9:	eb 05                	jmp    8022e0 <lwip_ioctl+0xc6>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  8022db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8022e0:	5b                   	pop    %ebx
  8022e1:	5e                   	pop    %esi
  8022e2:	5d                   	pop    %ebp
  8022e3:	c3                   	ret    

008022e4 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8022e4:	55                   	push   %ebp
  8022e5:	89 e5                	mov    %esp,%ebp
  8022e7:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8022ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8022ed:	89 04 24             	mov    %eax,(%esp)
  8022f0:	e8 80 2a 00 00       	call   804d75 <pbuf_free>
}
  8022f5:	c9                   	leave  
  8022f6:	c3                   	ret    

008022f7 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8022f7:	55                   	push   %ebp
  8022f8:	89 e5                	mov    %esp,%ebp
  8022fa:	53                   	push   %ebx
  8022fb:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8022fe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802305:	00 
  802306:	c7 44 24 04 e2 24 80 	movl   $0x8024e2,0x4(%esp)
  80230d:	00 
  80230e:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802315:	e8 03 34 00 00       	call   80571d <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80231a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802321:	00 
  802322:	c7 44 24 04 b9 24 80 	movl   $0x8024b9,0x4(%esp)
  802329:	00 
  80232a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  802331:	e8 e7 33 00 00       	call   80571d <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802336:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80233d:	00 
  80233e:	c7 44 24 04 90 24 80 	movl   $0x802490,0x4(%esp)
  802345:	00 
  802346:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80234d:	e8 cb 33 00 00       	call   80571d <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802352:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802359:	00 
  80235a:	c7 44 24 04 67 24 80 	movl   $0x802467,0x4(%esp)
  802361:	00 
  802362:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802369:	e8 af 33 00 00       	call   80571d <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80236e:	a1 08 53 81 00       	mov    0x815308,%eax
  802373:	85 c0                	test   %eax,%eax
  802375:	74 0b                	je     802382 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  802377:	8b 15 0c 53 81 00    	mov    0x81530c,%edx
  80237d:	89 14 24             	mov    %edx,(%esp)
  802380:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802382:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802385:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802389:	a1 00 40 81 00       	mov    0x814000,%eax
  80238e:	89 04 24             	mov    %eax,(%esp)
  802391:	e8 5f 32 00 00       	call   8055f5 <sys_mbox_fetch>
    switch (msg->type) {
  802396:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802399:	8b 10                	mov    (%eax),%edx
  80239b:	83 fa 01             	cmp    $0x1,%edx
  80239e:	74 1e                	je     8023be <tcpip_thread+0xc7>
  8023a0:	83 fa 01             	cmp    $0x1,%edx
  8023a3:	72 0c                	jb     8023b1 <tcpip_thread+0xba>
  8023a5:	83 fa 02             	cmp    $0x2,%edx
  8023a8:	74 52                	je     8023fc <tcpip_thread+0x105>
  8023aa:	83 fa 03             	cmp    $0x3,%edx
  8023ad:	75 d6                	jne    802385 <tcpip_thread+0x8e>
  8023af:	eb 6c                	jmp    80241d <tcpip_thread+0x126>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8023b1:	8b 40 08             	mov    0x8(%eax),%eax
  8023b4:	8d 50 04             	lea    0x4(%eax),%edx
  8023b7:	89 14 24             	mov    %edx,(%esp)
  8023ba:	ff 10                	call   *(%eax)
      break;
  8023bc:	eb c7                	jmp    802385 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8023be:	8b 50 0c             	mov    0xc(%eax),%edx
  8023c1:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  8023c5:	74 11                	je     8023d8 <tcpip_thread+0xe1>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8023c7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8023cb:	8b 40 08             	mov    0x8(%eax),%eax
  8023ce:	89 04 24             	mov    %eax,(%esp)
  8023d1:	e8 44 7f 00 00       	call   80a31a <ethernet_input>
  8023d6:	eb 0f                	jmp    8023e7 <tcpip_thread+0xf0>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8023d8:	89 54 24 04          	mov    %edx,0x4(%esp)
  8023dc:	8b 40 08             	mov    0x8(%eax),%eax
  8023df:	89 04 24             	mov    %eax,(%esp)
  8023e2:	e8 70 46 00 00       	call   806a57 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8023e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8023ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023ee:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8023f5:	e8 f0 25 00 00       	call   8049ea <memp_free>
      break;
  8023fa:	eb 89                	jmp    802385 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8023fc:	8b 50 0c             	mov    0xc(%eax),%edx
  8023ff:	89 14 24             	mov    %edx,(%esp)
  802402:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802405:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802408:	89 44 24 04          	mov    %eax,0x4(%esp)
  80240c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802413:	e8 d2 25 00 00       	call   8049ea <memp_free>
      break;
  802418:	e9 68 ff ff ff       	jmp    802385 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80241d:	8b 50 08             	mov    0x8(%eax),%edx
  802420:	83 fa ff             	cmp    $0xffffffff,%edx
  802423:	74 18                	je     80243d <tcpip_thread+0x146>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802425:	8b 48 10             	mov    0x10(%eax),%ecx
  802428:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80242c:	8b 40 0c             	mov    0xc(%eax),%eax
  80242f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802433:	89 14 24             	mov    %edx,(%esp)
  802436:	e8 e2 32 00 00       	call   80571d <sys_timeout>
  80243b:	eb 12                	jmp    80244f <tcpip_thread+0x158>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80243d:	8b 50 10             	mov    0x10(%eax),%edx
  802440:	89 54 24 04          	mov    %edx,0x4(%esp)
  802444:	8b 40 0c             	mov    0xc(%eax),%eax
  802447:	89 04 24             	mov    %eax,(%esp)
  80244a:	e8 8b 33 00 00       	call   8057da <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80244f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802452:	89 44 24 04          	mov    %eax,0x4(%esp)
  802456:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80245d:	e8 88 25 00 00       	call   8049ea <memp_free>
      break;
  802462:	e9 1e ff ff ff       	jmp    802385 <tcpip_thread+0x8e>

00802467 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  802467:	55                   	push   %ebp
  802468:	89 e5                	mov    %esp,%ebp
  80246a:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  80246d:	e8 41 1d 00 00       	call   8041b3 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802472:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802479:	00 
  80247a:	c7 44 24 04 67 24 80 	movl   $0x802467,0x4(%esp)
  802481:	00 
  802482:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  802489:	e8 8f 32 00 00       	call   80571d <sys_timeout>
}
  80248e:	c9                   	leave  
  80248f:	c3                   	ret    

00802490 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  802490:	55                   	push   %ebp
  802491:	89 e5                	mov    %esp,%ebp
  802493:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  802496:	e8 31 1b 00 00       	call   803fcc <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80249b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024a2:	00 
  8024a3:	c7 44 24 04 90 24 80 	movl   $0x802490,0x4(%esp)
  8024aa:	00 
  8024ab:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  8024b2:	e8 66 32 00 00       	call   80571d <sys_timeout>
}
  8024b7:	c9                   	leave  
  8024b8:	c3                   	ret    

008024b9 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  8024b9:	55                   	push   %ebp
  8024ba:	89 e5                	mov    %esp,%ebp
  8024bc:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8024bf:	e8 f1 76 00 00       	call   809bb5 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8024c4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024cb:	00 
  8024cc:	c7 44 24 04 b9 24 80 	movl   $0x8024b9,0x4(%esp)
  8024d3:	00 
  8024d4:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8024db:	e8 3d 32 00 00       	call   80571d <sys_timeout>
}
  8024e0:	c9                   	leave  
  8024e1:	c3                   	ret    

008024e2 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8024e2:	55                   	push   %ebp
  8024e3:	89 e5                	mov    %esp,%ebp
  8024e5:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  8024e8:	e8 12 4c 00 00       	call   8070ff <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8024ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024f4:	00 
  8024f5:	c7 44 24 04 e2 24 80 	movl   $0x8024e2,0x4(%esp)
  8024fc:	00 
  8024fd:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802504:	e8 14 32 00 00       	call   80571d <sys_timeout>
}
  802509:	c9                   	leave  
  80250a:	c3                   	ret    

0080250b <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  80250b:	55                   	push   %ebp
  80250c:	89 e5                	mov    %esp,%ebp
  80250e:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802511:	e8 bd 3f 00 00       	call   8064d3 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802516:	83 3d 7c b2 b3 00 00 	cmpl   $0x0,0xb3b27c
  80251d:	75 09                	jne    802528 <tcpip_tcp_timer+0x1d>
  80251f:	83 3d 90 b2 b3 00 00 	cmpl   $0x0,0xb3b290
  802526:	74 1e                	je     802546 <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802528:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80252f:	00 
  802530:	c7 44 24 04 0b 25 80 	movl   $0x80250b,0x4(%esp)
  802537:	00 
  802538:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80253f:	e8 d9 31 00 00       	call   80571d <sys_timeout>
  802544:	eb 0a                	jmp    802550 <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  802546:	c7 05 04 53 81 00 00 	movl   $0x0,0x815304
  80254d:	00 00 00 
  }
}
  802550:	c9                   	leave  
  802551:	c3                   	ret    

00802552 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802552:	55                   	push   %ebp
  802553:	89 e5                	mov    %esp,%ebp
  802555:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802558:	83 3d 04 53 81 00 00 	cmpl   $0x0,0x815304
  80255f:	75 38                	jne    802599 <tcp_timer_needed+0x47>
  802561:	83 3d 7c b2 b3 00 00 	cmpl   $0x0,0xb3b27c
  802568:	75 09                	jne    802573 <tcp_timer_needed+0x21>
  80256a:	83 3d 90 b2 b3 00 00 	cmpl   $0x0,0xb3b290
  802571:	74 26                	je     802599 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  802573:	c7 05 04 53 81 00 01 	movl   $0x1,0x815304
  80257a:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80257d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802584:	00 
  802585:	c7 44 24 04 0b 25 80 	movl   $0x80250b,0x4(%esp)
  80258c:	00 
  80258d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802594:	e8 84 31 00 00       	call   80571d <sys_timeout>
  }
}
  802599:	c9                   	leave  
  80259a:	c3                   	ret    

0080259b <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  80259b:	55                   	push   %ebp
  80259c:	89 e5                	mov    %esp,%ebp
  80259e:	53                   	push   %ebx
  80259f:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8025a2:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8025a9:	74 4d                	je     8025f8 <tcpip_input+0x5d>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8025ab:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025b2:	e8 d3 23 00 00       	call   80498a <memp_malloc>
  8025b7:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8025b9:	85 c0                	test   %eax,%eax
  8025bb:	74 3f                	je     8025fc <tcpip_input+0x61>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8025bd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8025c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8025c6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8025c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025cc:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8025cf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025d3:	a1 00 40 81 00       	mov    0x814000,%eax
  8025d8:	89 04 24             	mov    %eax,(%esp)
  8025db:	e8 7e 83 00 00       	call   80a95e <sys_mbox_trypost>
  8025e0:	84 c0                	test   %al,%al
  8025e2:	74 1c                	je     802600 <tcpip_input+0x65>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8025e4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025e8:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025ef:	e8 f6 23 00 00       	call   8049ea <memp_free>
      return ERR_MEM;
  8025f4:	b0 ff                	mov    $0xff,%al
  8025f6:	eb 0a                	jmp    802602 <tcpip_input+0x67>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8025f8:	b0 f7                	mov    $0xf7,%al
  8025fa:	eb 06                	jmp    802602 <tcpip_input+0x67>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  8025fc:	b0 ff                	mov    $0xff,%al
  8025fe:	eb 02                	jmp    802602 <tcpip_input+0x67>
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  802600:	b0 00                	mov    $0x0,%al
  }
  return ERR_VAL;
}
  802602:	83 c4 14             	add    $0x14,%esp
  802605:	5b                   	pop    %ebx
  802606:	5d                   	pop    %ebp
  802607:	c3                   	ret    

00802608 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802608:	55                   	push   %ebp
  802609:	89 e5                	mov    %esp,%ebp
  80260b:	53                   	push   %ebx
  80260c:	83 ec 24             	sub    $0x24,%esp
  80260f:	8a 45 10             	mov    0x10(%ebp),%al
  802612:	88 45 f7             	mov    %al,-0x9(%ebp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  802615:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  80261c:	74 68                	je     802686 <tcpip_callback_with_block+0x7e>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80261e:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802625:	e8 60 23 00 00       	call   80498a <memp_malloc>
  80262a:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80262c:	85 c0                	test   %eax,%eax
  80262e:	74 5a                	je     80268a <tcpip_callback_with_block+0x82>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802630:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802636:	8b 45 08             	mov    0x8(%ebp),%eax
  802639:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  80263c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80263f:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802642:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  802646:	74 15                	je     80265d <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802648:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80264c:	a1 00 40 81 00       	mov    0x814000,%eax
  802651:	89 04 24             	mov    %eax,(%esp)
  802654:	e8 f6 83 00 00       	call   80aa4f <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802659:	b0 00                	mov    $0x0,%al
  80265b:	eb 33                	jmp    802690 <tcpip_callback_with_block+0x88>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80265d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802661:	a1 00 40 81 00       	mov    0x814000,%eax
  802666:	89 04 24             	mov    %eax,(%esp)
  802669:	e8 f0 82 00 00       	call   80a95e <sys_mbox_trypost>
  80266e:	84 c0                	test   %al,%al
  802670:	74 1c                	je     80268e <tcpip_callback_with_block+0x86>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802672:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802676:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80267d:	e8 68 23 00 00       	call   8049ea <memp_free>
        return ERR_MEM;
  802682:	b0 ff                	mov    $0xff,%al
  802684:	eb 0a                	jmp    802690 <tcpip_callback_with_block+0x88>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802686:	b0 f7                	mov    $0xf7,%al
  802688:	eb 06                	jmp    802690 <tcpip_callback_with_block+0x88>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  80268a:	b0 ff                	mov    $0xff,%al
  80268c:	eb 02                	jmp    802690 <tcpip_callback_with_block+0x88>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  80268e:	b0 00                	mov    $0x0,%al
  }
  return ERR_VAL;
}
  802690:	83 c4 24             	add    $0x24,%esp
  802693:	5b                   	pop    %ebx
  802694:	5d                   	pop    %ebp
  802695:	c3                   	ret    

00802696 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  802696:	55                   	push   %ebp
  802697:	89 e5                	mov    %esp,%ebp
  802699:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80269c:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8026a3:	74 3d                	je     8026e2 <tcpip_timeout+0x4c>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8026a5:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026ac:	e8 d9 22 00 00       	call   80498a <memp_malloc>
    if (msg == NULL) {
  8026b1:	85 c0                	test   %eax,%eax
  8026b3:	74 31                	je     8026e6 <tcpip_timeout+0x50>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8026b5:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8026bb:	8b 55 08             	mov    0x8(%ebp),%edx
  8026be:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8026c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8026c4:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8026c7:	8b 55 10             	mov    0x10(%ebp),%edx
  8026ca:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8026cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026d1:	a1 00 40 81 00       	mov    0x814000,%eax
  8026d6:	89 04 24             	mov    %eax,(%esp)
  8026d9:	e8 71 83 00 00       	call   80aa4f <sys_mbox_post>
    return ERR_OK;
  8026de:	b0 00                	mov    $0x0,%al
  8026e0:	eb 06                	jmp    8026e8 <tcpip_timeout+0x52>
  }
  return ERR_VAL;
  8026e2:	b0 f7                	mov    $0xf7,%al
  8026e4:	eb 02                	jmp    8026e8 <tcpip_timeout+0x52>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8026e6:	b0 ff                	mov    $0xff,%al
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  8026e8:	c9                   	leave  
  8026e9:	c3                   	ret    

008026ea <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8026ea:	55                   	push   %ebp
  8026eb:	89 e5                	mov    %esp,%ebp
  8026ed:	53                   	push   %ebx
  8026ee:	83 ec 34             	sub    $0x34,%esp
  8026f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8026f4:	a1 00 40 81 00       	mov    0x814000,%eax
  8026f9:	83 f8 ff             	cmp    $0xffffffff,%eax
  8026fc:	74 33                	je     802731 <tcpip_apimsg+0x47>
    msg.type = TCPIP_MSG_API;
  8026fe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802705:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802708:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80270b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80270f:	89 04 24             	mov    %eax,(%esp)
  802712:	e8 38 83 00 00       	call   80aa4f <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802717:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80271e:	00 
  80271f:	8b 43 04             	mov    0x4(%ebx),%eax
  802722:	8b 40 10             	mov    0x10(%eax),%eax
  802725:	89 04 24             	mov    %eax,(%esp)
  802728:	e8 1c 81 00 00       	call   80a849 <sys_arch_sem_wait>
    return ERR_OK;
  80272d:	b0 00                	mov    $0x0,%al
  80272f:	eb 02                	jmp    802733 <tcpip_apimsg+0x49>
  }
  return ERR_VAL;
  802731:	b0 f7                	mov    $0xf7,%al
}
  802733:	83 c4 34             	add    $0x34,%esp
  802736:	5b                   	pop    %ebx
  802737:	5d                   	pop    %ebp
  802738:	c3                   	ret    

00802739 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802739:	55                   	push   %ebp
  80273a:	89 e5                	mov    %esp,%ebp
  80273c:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  80273f:	e8 e8 03 00 00       	call   802b2c <lwip_init>

  tcpip_init_done = initfunc;
  802744:	8b 45 08             	mov    0x8(%ebp),%eax
  802747:	a3 08 53 81 00       	mov    %eax,0x815308
  tcpip_init_done_arg = arg;
  80274c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80274f:	a3 0c 53 81 00       	mov    %eax,0x81530c
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802754:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80275b:	e8 50 7f 00 00       	call   80a6b0 <sys_mbox_new>
  802760:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802765:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80276c:	00 
  80276d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802774:	00 
  802775:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80277c:	00 
  80277d:	c7 44 24 04 f7 22 80 	movl   $0x8022f7,0x4(%esp)
  802784:	00 
  802785:	c7 04 24 9c 0d 81 00 	movl   $0x810d9c,(%esp)
  80278c:	e8 2d 84 00 00       	call   80abbe <sys_thread_new>
}
  802791:	c9                   	leave  
  802792:	c3                   	ret    

00802793 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802793:	55                   	push   %ebp
  802794:	89 e5                	mov    %esp,%ebp
  802796:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802799:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027a0:	00 
  8027a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8027a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027a8:	c7 04 24 e4 22 80 00 	movl   $0x8022e4,(%esp)
  8027af:	e8 54 fe ff ff       	call   802608 <tcpip_callback_with_block>
}
  8027b4:	c9                   	leave  
  8027b5:	c3                   	ret    

008027b6 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8027b6:	55                   	push   %ebp
  8027b7:	89 e5                	mov    %esp,%ebp
  8027b9:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8027bc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027c3:	00 
  8027c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8027c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027cb:	c7 04 24 68 44 80 00 	movl   $0x804468,(%esp)
  8027d2:	e8 31 fe ff ff       	call   802608 <tcpip_callback_with_block>
}
  8027d7:	c9                   	leave  
  8027d8:	c3                   	ret    
  8027d9:	00 00                	add    %al,(%eax)
	...

008027dc <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8027dc:	55                   	push   %ebp
  8027dd:	89 e5                	mov    %esp,%ebp
  8027df:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8027e2:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8027e9:	e8 9c 21 00 00       	call   80498a <memp_malloc>
  if (buf != NULL) {
  8027ee:	85 c0                	test   %eax,%eax
  8027f0:	74 14                	je     802806 <netbuf_new+0x2a>
    buf->p = NULL;
  8027f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8027f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8027ff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802806:	c9                   	leave  
  802807:	c3                   	ret    

00802808 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802808:	55                   	push   %ebp
  802809:	89 e5                	mov    %esp,%ebp
  80280b:	53                   	push   %ebx
  80280c:	83 ec 14             	sub    $0x14,%esp
  80280f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802812:	85 db                	test   %ebx,%ebx
  802814:	74 2b                	je     802841 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  802816:	8b 03                	mov    (%ebx),%eax
  802818:	85 c0                	test   %eax,%eax
  80281a:	74 15                	je     802831 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  80281c:	89 04 24             	mov    %eax,(%esp)
  80281f:	e8 51 25 00 00       	call   804d75 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802824:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80282b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  802831:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802835:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80283c:	e8 a9 21 00 00       	call   8049ea <memp_free>
  }
}
  802841:	83 c4 14             	add    $0x14,%esp
  802844:	5b                   	pop    %ebx
  802845:	5d                   	pop    %ebp
  802846:	c3                   	ret    

00802847 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802847:	55                   	push   %ebp
  802848:	89 e5                	mov    %esp,%ebp
  80284a:	56                   	push   %esi
  80284b:	53                   	push   %ebx
  80284c:	83 ec 10             	sub    $0x10,%esp
  80284f:	8b 75 08             	mov    0x8(%ebp),%esi
  802852:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802855:	85 f6                	test   %esi,%esi
  802857:	75 1c                	jne    802875 <netbuf_alloc+0x2e>
  802859:	c7 44 24 08 a9 0d 81 	movl   $0x810da9,0x8(%esp)
  802860:	00 
  802861:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  802868:	00 
  802869:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802870:	e8 03 c6 00 00       	call   80ee78 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802875:	8b 06                	mov    (%esi),%eax
  802877:	85 c0                	test   %eax,%eax
  802879:	74 08                	je     802883 <netbuf_alloc+0x3c>
    pbuf_free(buf->p);
  80287b:	89 04 24             	mov    %eax,(%esp)
  80287e:	e8 f2 24 00 00       	call   804d75 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802883:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80288a:	00 
  80288b:	0f b7 c3             	movzwl %bx,%eax
  80288e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802892:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802899:	e8 d8 26 00 00       	call   804f76 <pbuf_alloc>
  80289e:	89 06                	mov    %eax,(%esi)
  if (buf->p == NULL) {
  8028a0:	85 c0                	test   %eax,%eax
  8028a2:	74 2a                	je     8028ce <netbuf_alloc+0x87>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8028a4:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  8028a8:	76 1c                	jbe    8028c6 <netbuf_alloc+0x7f>
  8028aa:	c7 44 24 08 90 0e 81 	movl   $0x810e90,0x8(%esp)
  8028b1:	00 
  8028b2:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8028b9:	00 
  8028ba:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  8028c1:	e8 b2 c5 00 00       	call   80ee78 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8028c6:	89 46 04             	mov    %eax,0x4(%esi)
  return buf->p->payload;
  8028c9:	8b 40 04             	mov    0x4(%eax),%eax
  8028cc:	eb 05                	jmp    8028d3 <netbuf_alloc+0x8c>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8028ce:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8028d3:	83 c4 10             	add    $0x10,%esp
  8028d6:	5b                   	pop    %ebx
  8028d7:	5e                   	pop    %esi
  8028d8:	5d                   	pop    %ebp
  8028d9:	c3                   	ret    

008028da <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8028da:	55                   	push   %ebp
  8028db:	89 e5                	mov    %esp,%ebp
  8028dd:	53                   	push   %ebx
  8028de:	83 ec 14             	sub    $0x14,%esp
  8028e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028e4:	85 db                	test   %ebx,%ebx
  8028e6:	75 1c                	jne    802904 <netbuf_free+0x2a>
  8028e8:	c7 44 24 08 d9 0d 81 	movl   $0x810dd9,0x8(%esp)
  8028ef:	00 
  8028f0:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8028f7:	00 
  8028f8:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  8028ff:	e8 74 c5 00 00       	call   80ee78 <_panic>
  if (buf->p != NULL) {
  802904:	8b 03                	mov    (%ebx),%eax
  802906:	85 c0                	test   %eax,%eax
  802908:	74 08                	je     802912 <netbuf_free+0x38>
    pbuf_free(buf->p);
  80290a:	89 04 24             	mov    %eax,(%esp)
  80290d:	e8 63 24 00 00       	call   804d75 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  802912:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802919:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  80291f:	83 c4 14             	add    $0x14,%esp
  802922:	5b                   	pop    %ebx
  802923:	5d                   	pop    %ebp
  802924:	c3                   	ret    

00802925 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802925:	55                   	push   %ebp
  802926:	89 e5                	mov    %esp,%ebp
  802928:	56                   	push   %esi
  802929:	53                   	push   %ebx
  80292a:	83 ec 10             	sub    $0x10,%esp
  80292d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802930:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802933:	85 db                	test   %ebx,%ebx
  802935:	75 1c                	jne    802953 <netbuf_ref+0x2e>
  802937:	c7 44 24 08 f2 0d 81 	movl   $0x810df2,0x8(%esp)
  80293e:	00 
  80293f:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  802946:	00 
  802947:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  80294e:	e8 25 c5 00 00       	call   80ee78 <_panic>
  if (buf->p != NULL) {
  802953:	8b 03                	mov    (%ebx),%eax
  802955:	85 c0                	test   %eax,%eax
  802957:	74 08                	je     802961 <netbuf_ref+0x3c>
    pbuf_free(buf->p);
  802959:	89 04 24             	mov    %eax,(%esp)
  80295c:	e8 14 24 00 00       	call   804d75 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802961:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  802968:	00 
  802969:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802970:	00 
  802971:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802978:	e8 f9 25 00 00       	call   804f76 <pbuf_alloc>
  80297d:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80297f:	85 c0                	test   %eax,%eax
  802981:	75 0b                	jne    80298e <netbuf_ref+0x69>
    buf->ptr = NULL;
  802983:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80298a:	b0 ff                	mov    $0xff,%al
  80298c:	eb 17                	jmp    8029a5 <netbuf_ref+0x80>
  }
  buf->p->payload = (void*)dataptr;
  80298e:	8b 55 0c             	mov    0xc(%ebp),%edx
  802991:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802994:	8b 03                	mov    (%ebx),%eax
  802996:	66 89 70 08          	mov    %si,0x8(%eax)
  80299a:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80299e:	8b 03                	mov    (%ebx),%eax
  8029a0:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8029a3:	b0 00                	mov    $0x0,%al
}
  8029a5:	83 c4 10             	add    $0x10,%esp
  8029a8:	5b                   	pop    %ebx
  8029a9:	5e                   	pop    %esi
  8029aa:	5d                   	pop    %ebp
  8029ab:	c3                   	ret    

008029ac <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8029ac:	55                   	push   %ebp
  8029ad:	89 e5                	mov    %esp,%ebp
  8029af:	56                   	push   %esi
  8029b0:	53                   	push   %ebx
  8029b1:	83 ec 10             	sub    $0x10,%esp
  8029b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8029b7:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8029ba:	85 db                	test   %ebx,%ebx
  8029bc:	75 1c                	jne    8029da <netbuf_chain+0x2e>
  8029be:	c7 44 24 08 0a 0e 81 	movl   $0x810e0a,0x8(%esp)
  8029c5:	00 
  8029c6:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  8029cd:	00 
  8029ce:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  8029d5:	e8 9e c4 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8029da:	85 f6                	test   %esi,%esi
  8029dc:	75 1c                	jne    8029fa <netbuf_chain+0x4e>
  8029de:	c7 44 24 08 23 0e 81 	movl   $0x810e23,0x8(%esp)
  8029e5:	00 
  8029e6:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  8029ed:	00 
  8029ee:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  8029f5:	e8 7e c4 00 00       	call   80ee78 <_panic>
  pbuf_chain(head->p, tail->p);
  8029fa:	8b 06                	mov    (%esi),%eax
  8029fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a00:	8b 03                	mov    (%ebx),%eax
  802a02:	89 04 24             	mov    %eax,(%esp)
  802a05:	e8 89 28 00 00       	call   805293 <pbuf_chain>
  head->ptr = head->p;
  802a0a:	8b 03                	mov    (%ebx),%eax
  802a0c:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802a0f:	89 74 24 04          	mov    %esi,0x4(%esp)
  802a13:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802a1a:	e8 cb 1f 00 00       	call   8049ea <memp_free>
}
  802a1f:	83 c4 10             	add    $0x10,%esp
  802a22:	5b                   	pop    %ebx
  802a23:	5e                   	pop    %esi
  802a24:	5d                   	pop    %ebp
  802a25:	c3                   	ret    

00802a26 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802a26:	55                   	push   %ebp
  802a27:	89 e5                	mov    %esp,%ebp
  802a29:	53                   	push   %ebx
  802a2a:	83 ec 14             	sub    $0x14,%esp
  802a2d:	8b 45 08             	mov    0x8(%ebp),%eax
  802a30:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802a33:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802a36:	85 c0                	test   %eax,%eax
  802a38:	75 1c                	jne    802a56 <netbuf_data+0x30>
  802a3a:	c7 44 24 08 3e 0e 81 	movl   $0x810e3e,0x8(%esp)
  802a41:	00 
  802a42:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  802a49:	00 
  802a4a:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802a51:	e8 22 c4 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802a56:	85 c9                	test   %ecx,%ecx
  802a58:	75 1c                	jne    802a76 <netbuf_data+0x50>
  802a5a:	c7 44 24 08 57 0e 81 	movl   $0x810e57,0x8(%esp)
  802a61:	00 
  802a62:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  802a69:	00 
  802a6a:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802a71:	e8 02 c4 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802a76:	85 d2                	test   %edx,%edx
  802a78:	75 1c                	jne    802a96 <netbuf_data+0x70>
  802a7a:	c7 44 24 08 74 0e 81 	movl   $0x810e74,0x8(%esp)
  802a81:	00 
  802a82:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  802a89:	00 
  802a8a:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802a91:	e8 e2 c3 00 00       	call   80ee78 <_panic>

  if (buf->ptr == NULL) {
  802a96:	8b 58 04             	mov    0x4(%eax),%ebx
  802a99:	85 db                	test   %ebx,%ebx
  802a9b:	74 13                	je     802ab0 <netbuf_data+0x8a>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802a9d:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802aa0:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802aa2:	8b 40 04             	mov    0x4(%eax),%eax
  802aa5:	66 8b 40 0a          	mov    0xa(%eax),%ax
  802aa9:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802aac:	b0 00                	mov    $0x0,%al
  802aae:	eb 02                	jmp    802ab2 <netbuf_data+0x8c>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802ab0:	b0 fe                	mov    $0xfe,%al
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802ab2:	83 c4 14             	add    $0x14,%esp
  802ab5:	5b                   	pop    %ebx
  802ab6:	5d                   	pop    %ebp
  802ab7:	c3                   	ret    

00802ab8 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802ab8:	55                   	push   %ebp
  802ab9:	89 e5                	mov    %esp,%ebp
  802abb:	83 ec 18             	sub    $0x18,%esp
  802abe:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802ac1:	85 c0                	test   %eax,%eax
  802ac3:	75 1c                	jne    802ae1 <netbuf_next+0x29>
  802ac5:	c7 44 24 08 d9 0d 81 	movl   $0x810dd9,0x8(%esp)
  802acc:	00 
  802acd:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  802ad4:	00 
  802ad5:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802adc:	e8 97 c3 00 00       	call   80ee78 <_panic>
  if (buf->ptr->next == NULL) {
  802ae1:	8b 50 04             	mov    0x4(%eax),%edx
  802ae4:	8b 12                	mov    (%edx),%edx
  802ae6:	85 d2                	test   %edx,%edx
  802ae8:	74 0b                	je     802af5 <netbuf_next+0x3d>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802aea:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  802aed:	83 3a 00             	cmpl   $0x0,(%edx)
  802af0:	0f 94 c0             	sete   %al
  802af3:	eb 02                	jmp    802af7 <netbuf_next+0x3f>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802af5:	b0 ff                	mov    $0xff,%al
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802af7:	c9                   	leave  
  802af8:	c3                   	ret    

00802af9 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802af9:	55                   	push   %ebp
  802afa:	89 e5                	mov    %esp,%ebp
  802afc:	83 ec 18             	sub    $0x18,%esp
  802aff:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802b02:	85 c0                	test   %eax,%eax
  802b04:	75 1c                	jne    802b22 <netbuf_first+0x29>
  802b06:	c7 44 24 08 d9 0d 81 	movl   $0x810dd9,0x8(%esp)
  802b0d:	00 
  802b0e:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  802b15:	00 
  802b16:	c7 04 24 c3 0d 81 00 	movl   $0x810dc3,(%esp)
  802b1d:	e8 56 c3 00 00       	call   80ee78 <_panic>
  buf->ptr = buf->p;
  802b22:	8b 10                	mov    (%eax),%edx
  802b24:	89 50 04             	mov    %edx,0x4(%eax)
}
  802b27:	c9                   	leave  
  802b28:	c3                   	ret    
  802b29:	00 00                	add    %al,(%eax)
	...

00802b2c <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802b2c:	55                   	push   %ebp
  802b2d:	89 e5                	mov    %esp,%ebp
  802b2f:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802b32:	e8 f2 78 00 00       	call   80a429 <sys_init>
  mem_init();
  802b37:	e8 c4 18 00 00       	call   804400 <mem_init>
  memp_init();
  802b3c:	e8 f3 1d 00 00       	call   804934 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802b41:	e8 fe e4 ff ff       	call   801044 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802b46:	c9                   	leave  
  802b47:	c3                   	ret    

00802b48 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802b48:	55                   	push   %ebp
  802b49:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802b4b:	38 10                	cmp    %dl,(%eax)
  802b4d:	74 06                	je     802b55 <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802b4f:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802b51:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802b55:	5d                   	pop    %ebp
  802b56:	c3                   	ret    

00802b57 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802b57:	55                   	push   %ebp
  802b58:	89 e5                	mov    %esp,%ebp
  802b5a:	57                   	push   %edi
  802b5b:	56                   	push   %esi
  802b5c:	53                   	push   %ebx
  802b5d:	83 ec 08             	sub    $0x8,%esp
  802b60:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802b63:	8b 70 14             	mov    0x14(%eax),%esi
  802b66:	85 f6                	test   %esi,%esi
  802b68:	0f 84 c5 00 00 00    	je     802c33 <dhcp_get_option_ptr+0xdc>
  802b6e:	8b 78 18             	mov    0x18(%eax),%edi
  802b71:	66 85 ff             	test   %di,%di
  802b74:	0f 84 c0 00 00 00    	je     802c3a <dhcp_get_option_ptr+0xe3>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802b7a:	b9 00 00 00 00       	mov    $0x0,%ecx
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;
  802b7f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  802b83:	eb 2c                	jmp    802bb1 <dhcp_get_option_ptr+0x5a>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802b85:	80 fb 34             	cmp    $0x34,%bl
  802b88:	75 11                	jne    802b9b <dhcp_get_option_ptr+0x44>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802b8a:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802b8d:	0f b7 c0             	movzwl %ax,%eax
  802b90:	8a 04 06             	mov    (%esi,%eax,1),%al
  802b93:	88 45 f3             	mov    %al,-0xd(%ebp)
  802b96:	83 c1 03             	add    $0x3,%ecx
  802b99:	eb 16                	jmp    802bb1 <dhcp_get_option_ptr+0x5a>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802b9b:	38 d3                	cmp    %dl,%bl
  802b9d:	0f 84 aa 00 00 00    	je     802c4d <dhcp_get_option_ptr+0xf6>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802ba3:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802ba6:	0f b7 c0             	movzwl %ax,%eax
  802ba9:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802bad:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802bb1:	66 39 f9             	cmp    %di,%cx
  802bb4:	73 0c                	jae    802bc2 <dhcp_get_option_ptr+0x6b>
  802bb6:	0f b7 c1             	movzwl %cx,%eax
  802bb9:	01 f0                	add    %esi,%eax
  802bbb:	8a 18                	mov    (%eax),%bl
  802bbd:	80 fb ff             	cmp    $0xff,%bl
  802bc0:	75 c3                	jne    802b85 <dhcp_get_option_ptr+0x2e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802bc2:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  802bc6:	74 79                	je     802c41 <dhcp_get_option_ptr+0xea>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802bc8:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  802bcc:	75 10                	jne    802bde <dhcp_get_option_ptr+0x87>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802bce:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802bd1:	8b 70 10             	mov    0x10(%eax),%esi
  802bd4:	83 c6 6c             	add    $0x6c,%esi
        field_len = DHCP_FILE_LEN;
  802bd7:	bf 80 00 00 00       	mov    $0x80,%edi
  802bdc:	eb 24                	jmp    802c02 <dhcp_get_option_ptr+0xab>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802bde:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  802be2:	75 10                	jne    802bf4 <dhcp_get_option_ptr+0x9d>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802be4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802be7:	8b 70 10             	mov    0x10(%eax),%esi
  802bea:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_SNAME_LEN;
  802bed:	bf 40 00 00 00       	mov    $0x40,%edi
  802bf2:	eb 0e                	jmp    802c02 <dhcp_get_option_ptr+0xab>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802bf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802bf7:	8b 70 10             	mov    0x10(%eax),%esi
  802bfa:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802bfd:	bf c0 00 00 00       	mov    $0xc0,%edi
      }
      offset = 0;
  802c02:	b9 00 00 00 00       	mov    $0x0,%ecx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c07:	eb 12                	jmp    802c1b <dhcp_get_option_ptr+0xc4>
        if (options[offset] == option_type) {
  802c09:	38 da                	cmp    %bl,%dl
  802c0b:	74 40                	je     802c4d <dhcp_get_option_ptr+0xf6>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802c0d:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802c10:	0f b7 c0             	movzwl %ax,%eax
  802c13:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c17:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c1b:	66 39 f9             	cmp    %di,%cx
  802c1e:	73 28                	jae    802c48 <dhcp_get_option_ptr+0xf1>
  802c20:	0f b7 c1             	movzwl %cx,%eax
  802c23:	01 f0                	add    %esi,%eax
  802c25:	8a 18                	mov    (%eax),%bl
  802c27:	80 fb ff             	cmp    $0xff,%bl
  802c2a:	75 dd                	jne    802c09 <dhcp_get_option_ptr+0xb2>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802c2c:	b8 00 00 00 00       	mov    $0x0,%eax
  802c31:	eb 1a                	jmp    802c4d <dhcp_get_option_ptr+0xf6>
  802c33:	b8 00 00 00 00       	mov    $0x0,%eax
  802c38:	eb 13                	jmp    802c4d <dhcp_get_option_ptr+0xf6>
  802c3a:	b8 00 00 00 00       	mov    $0x0,%eax
  802c3f:	eb 0c                	jmp    802c4d <dhcp_get_option_ptr+0xf6>
  802c41:	b8 00 00 00 00       	mov    $0x0,%eax
  802c46:	eb 05                	jmp    802c4d <dhcp_get_option_ptr+0xf6>
  802c48:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802c4d:	83 c4 08             	add    $0x8,%esp
  802c50:	5b                   	pop    %ebx
  802c51:	5e                   	pop    %esi
  802c52:	5f                   	pop    %edi
  802c53:	5d                   	pop    %ebp
  802c54:	c3                   	ret    

00802c55 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  802c55:	55                   	push   %ebp
  802c56:	89 e5                	mov    %esp,%ebp
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  802c58:	8a 00                	mov    (%eax),%al
}
  802c5a:	5d                   	pop    %ebp
  802c5b:	c3                   	ret    

00802c5c <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802c5c:	55                   	push   %ebp
  802c5d:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802c5f:	0f b6 08             	movzbl (%eax),%ecx
  802c62:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802c65:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802c69:	c1 e2 10             	shl    $0x10,%edx
  802c6c:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802c6e:	0f b6 50 03          	movzbl 0x3(%eax),%edx
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  802c72:	09 d1                	or     %edx,%ecx
  802c74:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  802c78:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802c7b:	89 c8                	mov    %ecx,%eax
  802c7d:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802c7f:	5d                   	pop    %ebp
  802c80:	c3                   	ret    

00802c81 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802c81:	55                   	push   %ebp
  802c82:	89 e5                	mov    %esp,%ebp
  802c84:	57                   	push   %edi
  802c85:	56                   	push   %esi
  802c86:	53                   	push   %ebx
  802c87:	83 ec 2c             	sub    $0x2c,%esp
  802c8a:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802c8c:	8b 58 24             	mov    0x24(%eax),%ebx
  802c8f:	0f b7 fb             	movzwl %bx,%edi
  802c92:	88 4d e3             	mov    %cl,-0x1d(%ebp)
  802c95:	8d 4c 39 02          	lea    0x2(%ecx,%edi,1),%ecx
  802c99:	83 f9 44             	cmp    $0x44,%ecx
  802c9c:	76 1c                	jbe    802cba <dhcp_option+0x39>
  802c9e:	c7 44 24 08 b4 0e 81 	movl   $0x810eb4,0x8(%esp)
  802ca5:	00 
  802ca6:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802cad:	00 
  802cae:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802cb5:	e8 be c1 00 00       	call   80ee78 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802cba:	0f b7 d3             	movzwl %bx,%edx
  802cbd:	89 f1                	mov    %esi,%ecx
  802cbf:	8b 78 20             	mov    0x20(%eax),%edi
  802cc2:	88 8c 17 f0 00 00 00 	mov    %cl,0xf0(%edi,%edx,1)
  802cc9:	8d 4b 01             	lea    0x1(%ebx),%ecx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802ccc:	8b 70 20             	mov    0x20(%eax),%esi
  802ccf:	0f b7 c9             	movzwl %cx,%ecx
  802cd2:	8a 55 e3             	mov    -0x1d(%ebp),%dl
  802cd5:	88 94 0e f0 00 00 00 	mov    %dl,0xf0(%esi,%ecx,1)
  802cdc:	83 c3 02             	add    $0x2,%ebx
  802cdf:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  802ce3:	83 c4 2c             	add    $0x2c,%esp
  802ce6:	5b                   	pop    %ebx
  802ce7:	5e                   	pop    %esi
  802ce8:	5f                   	pop    %edi
  802ce9:	5d                   	pop    %ebp
  802cea:	c3                   	ret    

00802ceb <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802ceb:	55                   	push   %ebp
  802cec:	89 e5                	mov    %esp,%ebp
  802cee:	56                   	push   %esi
  802cef:	53                   	push   %ebx
  802cf0:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802cf3:	8b 48 24             	mov    0x24(%eax),%ecx
  802cf6:	66 83 f9 43          	cmp    $0x43,%cx
  802cfa:	76 1c                	jbe    802d18 <dhcp_option_byte+0x2d>
  802cfc:	c7 44 24 08 fc 0e 81 	movl   $0x810efc,0x8(%esp)
  802d03:	00 
  802d04:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802d0b:	00 
  802d0c:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802d13:	e8 60 c1 00 00       	call   80ee78 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802d18:	8b 70 20             	mov    0x20(%eax),%esi
  802d1b:	0f b7 d9             	movzwl %cx,%ebx
  802d1e:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802d25:	41                   	inc    %ecx
  802d26:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802d2a:	83 c4 10             	add    $0x10,%esp
  802d2d:	5b                   	pop    %ebx
  802d2e:	5e                   	pop    %esi
  802d2f:	5d                   	pop    %ebp
  802d30:	c3                   	ret    

00802d31 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802d31:	55                   	push   %ebp
  802d32:	89 e5                	mov    %esp,%ebp
  802d34:	53                   	push   %ebx
  802d35:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802d38:	85 c0                	test   %eax,%eax
  802d3a:	75 1c                	jne    802d58 <dhcp_option_trailer+0x27>
  802d3c:	c7 44 24 08 38 0f 81 	movl   $0x810f38,0x8(%esp)
  802d43:	00 
  802d44:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802d4b:	00 
  802d4c:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802d53:	e8 20 c1 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802d58:	8b 48 20             	mov    0x20(%eax),%ecx
  802d5b:	85 c9                	test   %ecx,%ecx
  802d5d:	75 1c                	jne    802d7b <dhcp_option_trailer+0x4a>
  802d5f:	c7 44 24 08 5c 0f 81 	movl   $0x810f5c,0x8(%esp)
  802d66:	00 
  802d67:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802d6e:	00 
  802d6f:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802d76:	e8 fd c0 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802d7b:	8b 50 24             	mov    0x24(%eax),%edx
  802d7e:	66 83 fa 43          	cmp    $0x43,%dx
  802d82:	76 1c                	jbe    802da0 <dhcp_option_trailer+0x6f>
  802d84:	c7 44 24 08 88 0f 81 	movl   $0x810f88,0x8(%esp)
  802d8b:	00 
  802d8c:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802d93:	00 
  802d94:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802d9b:	e8 d8 c0 00 00       	call   80ee78 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802da0:	0f b7 da             	movzwl %dx,%ebx
  802da3:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  802daa:	ff 
  802dab:	42                   	inc    %edx
  802dac:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802db0:	eb 2f                	jmp    802de1 <dhcp_option_trailer+0xb0>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802db2:	c7 44 24 08 88 0f 81 	movl   $0x810f88,0x8(%esp)
  802db9:	00 
  802dba:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802dc1:	00 
  802dc2:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802dc9:	e8 aa c0 00 00       	call   80ee78 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802dce:	8b 58 20             	mov    0x20(%eax),%ebx
  802dd1:	0f b7 ca             	movzwl %dx,%ecx
  802dd4:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  802ddb:	00 
  802ddc:	42                   	inc    %edx
  802ddd:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802de1:	8b 50 24             	mov    0x24(%eax),%edx
  802de4:	66 83 fa 43          	cmp    $0x43,%dx
  802de8:	76 e4                	jbe    802dce <dhcp_option_trailer+0x9d>
  802dea:	f6 c2 03             	test   $0x3,%dl
  802ded:	75 c3                	jne    802db2 <dhcp_option_trailer+0x81>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802def:	83 c4 14             	add    $0x14,%esp
  802df2:	5b                   	pop    %ebx
  802df3:	5d                   	pop    %ebp
  802df4:	c3                   	ret    

00802df5 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802df5:	55                   	push   %ebp
  802df6:	89 e5                	mov    %esp,%ebp
  802df8:	57                   	push   %edi
  802df9:	56                   	push   %esi
  802dfa:	53                   	push   %ebx
  802dfb:	83 ec 2c             	sub    $0x2c,%esp
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802dfe:	8b 48 24             	mov    0x24(%eax),%ecx
  802e01:	0f b7 d9             	movzwl %cx,%ebx
  802e04:	83 c3 02             	add    $0x2,%ebx
  802e07:	83 fb 44             	cmp    $0x44,%ebx
  802e0a:	76 1c                	jbe    802e28 <dhcp_option_short+0x33>
  802e0c:	c7 44 24 08 c8 0f 81 	movl   $0x810fc8,0x8(%esp)
  802e13:	00 
  802e14:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802e1b:	00 
  802e1c:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802e23:	e8 50 c0 00 00       	call   80ee78 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802e28:	0f b7 d9             	movzwl %cx,%ebx
  802e2b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802e2e:	89 d6                	mov    %edx,%esi
  802e30:	66 c1 ee 08          	shr    $0x8,%si
  802e34:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  802e38:	8a 5d e2             	mov    -0x1e(%ebp),%bl
  802e3b:	8b 78 20             	mov    0x20(%eax),%edi
  802e3e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e41:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802e48:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802e4b:	8b 70 20             	mov    0x20(%eax),%esi
  802e4e:	0f b7 db             	movzwl %bx,%ebx
  802e51:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802e58:	83 c1 02             	add    $0x2,%ecx
  802e5b:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802e5f:	83 c4 2c             	add    $0x2c,%esp
  802e62:	5b                   	pop    %ebx
  802e63:	5e                   	pop    %esi
  802e64:	5f                   	pop    %edi
  802e65:	5d                   	pop    %ebp
  802e66:	c3                   	ret    

00802e67 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802e67:	55                   	push   %ebp
  802e68:	89 e5                	mov    %esp,%ebp
  802e6a:	57                   	push   %edi
  802e6b:	56                   	push   %esi
  802e6c:	53                   	push   %ebx
  802e6d:	83 ec 2c             	sub    $0x2c,%esp
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802e70:	8b 48 24             	mov    0x24(%eax),%ecx
  802e73:	0f b7 d9             	movzwl %cx,%ebx
  802e76:	83 c3 04             	add    $0x4,%ebx
  802e79:	83 fb 44             	cmp    $0x44,%ebx
  802e7c:	76 1c                	jbe    802e9a <dhcp_option_long+0x33>
  802e7e:	c7 44 24 08 0c 10 81 	movl   $0x81100c,0x8(%esp)
  802e85:	00 
  802e86:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802e8d:	00 
  802e8e:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802e95:	e8 de bf 00 00       	call   80ee78 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802e9a:	0f b7 d9             	movzwl %cx,%ebx
  802e9d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802ea0:	89 d6                	mov    %edx,%esi
  802ea2:	c1 ee 18             	shr    $0x18,%esi
  802ea5:	89 75 e0             	mov    %esi,-0x20(%ebp)
  802ea8:	8a 5d e0             	mov    -0x20(%ebp),%bl
  802eab:	8b 78 20             	mov    0x20(%eax),%edi
  802eae:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802eb1:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802eb8:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802ebb:	0f b7 db             	movzwl %bx,%ebx
  802ebe:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802ec1:	89 d3                	mov    %edx,%ebx
  802ec3:	c1 eb 10             	shr    $0x10,%ebx
  802ec6:	8b 78 20             	mov    0x20(%eax),%edi
  802ec9:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802ecc:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802ed3:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802ed6:	0f b7 db             	movzwl %bx,%ebx
  802ed9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  802edc:	0f b6 de             	movzbl %dh,%ebx
  802edf:	8b 78 20             	mov    0x20(%eax),%edi
  802ee2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802ee5:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  802eec:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802eef:	8b 70 20             	mov    0x20(%eax),%esi
  802ef2:	0f b7 db             	movzwl %bx,%ebx
  802ef5:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  802efc:	83 c1 04             	add    $0x4,%ecx
  802eff:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  802f03:	83 c4 2c             	add    $0x2c,%esp
  802f06:	5b                   	pop    %ebx
  802f07:	5e                   	pop    %esi
  802f08:	5f                   	pop    %edi
  802f09:	5d                   	pop    %ebp
  802f0a:	c3                   	ret    

00802f0b <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802f0b:	55                   	push   %ebp
  802f0c:	89 e5                	mov    %esp,%ebp
  802f0e:	53                   	push   %ebx
  802f0f:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802f12:	85 c0                	test   %eax,%eax
  802f14:	75 1c                	jne    802f32 <dhcp_delete_request+0x27>
  802f16:	c7 44 24 08 4c 10 81 	movl   $0x81104c,0x8(%esp)
  802f1d:	00 
  802f1e:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  802f25:	00 
  802f26:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802f2d:	e8 46 bf 00 00       	call   80ee78 <_panic>
  dhcp = netif->dhcp;
  802f32:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802f35:	85 db                	test   %ebx,%ebx
  802f37:	75 1c                	jne    802f55 <dhcp_delete_request+0x4a>
  802f39:	c7 44 24 08 70 10 81 	movl   $0x811070,0x8(%esp)
  802f40:	00 
  802f41:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  802f48:	00 
  802f49:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802f50:	e8 23 bf 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802f55:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802f58:	85 c0                	test   %eax,%eax
  802f5a:	75 1c                	jne    802f78 <dhcp_delete_request+0x6d>
  802f5c:	c7 44 24 08 94 10 81 	movl   $0x811094,0x8(%esp)
  802f63:	00 
  802f64:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  802f6b:	00 
  802f6c:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802f73:	e8 00 bf 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802f78:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802f7c:	75 1c                	jne    802f9a <dhcp_delete_request+0x8f>
  802f7e:	c7 44 24 08 c0 10 81 	movl   $0x8110c0,0x8(%esp)
  802f85:	00 
  802f86:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  802f8d:	00 
  802f8e:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  802f95:	e8 de be 00 00       	call   80ee78 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802f9a:	89 04 24             	mov    %eax,(%esp)
  802f9d:	e8 d3 1d 00 00       	call   804d75 <pbuf_free>
  }
  dhcp->p_out = NULL;
  802fa2:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802fa9:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802fb0:	83 c4 14             	add    $0x14,%esp
  802fb3:	5b                   	pop    %ebx
  802fb4:	5d                   	pop    %ebp
  802fb5:	c3                   	ret    

00802fb6 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  802fb6:	55                   	push   %ebp
  802fb7:	89 e5                	mov    %esp,%ebp
  802fb9:	53                   	push   %ebx
  802fba:	83 ec 14             	sub    $0x14,%esp
  802fbd:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  802fbf:	8b 40 10             	mov    0x10(%eax),%eax
  802fc2:	85 c0                	test   %eax,%eax
  802fc4:	74 0f                	je     802fd5 <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  802fc6:	89 04 24             	mov    %eax,(%esp)
  802fc9:	e8 9a 14 00 00       	call   804468 <mem_free>
    dhcp->msg_in = NULL;
  802fce:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  802fd5:	8b 43 14             	mov    0x14(%ebx),%eax
  802fd8:	85 c0                	test   %eax,%eax
  802fda:	74 15                	je     802ff1 <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  802fdc:	89 04 24             	mov    %eax,(%esp)
  802fdf:	e8 84 14 00 00       	call   804468 <mem_free>
    dhcp->options_in = NULL;
  802fe4:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  802feb:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  802ff1:	83 c4 14             	add    $0x14,%esp
  802ff4:	5b                   	pop    %ebx
  802ff5:	5d                   	pop    %ebp
  802ff6:	c3                   	ret    

00802ff7 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802ff7:	55                   	push   %ebp
  802ff8:	89 e5                	mov    %esp,%ebp
  802ffa:	57                   	push   %edi
  802ffb:	56                   	push   %esi
  802ffc:	53                   	push   %ebx
  802ffd:	83 ec 2c             	sub    $0x2c,%esp
  803000:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  803003:	85 c0                	test   %eax,%eax
  803005:	75 1c                	jne    803023 <dhcp_create_request+0x2c>
  803007:	c7 44 24 08 ec 10 81 	movl   $0x8110ec,0x8(%esp)
  80300e:	00 
  80300f:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  803016:	00 
  803017:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  80301e:	e8 55 be 00 00       	call   80ee78 <_panic>
  dhcp = netif->dhcp;
  803023:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803026:	8b 70 20             	mov    0x20(%eax),%esi
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  803029:	85 f6                	test   %esi,%esi
  80302b:	75 1c                	jne    803049 <dhcp_create_request+0x52>
  80302d:	c7 44 24 08 10 11 81 	movl   $0x811110,0x8(%esp)
  803034:	00 
  803035:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  80303c:	00 
  80303d:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803044:	e8 2f be 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  803049:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  80304d:	74 1c                	je     80306b <dhcp_create_request+0x74>
  80304f:	c7 44 24 08 34 11 81 	movl   $0x811134,0x8(%esp)
  803056:	00 
  803057:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  80305e:	00 
  80305f:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803066:	e8 0d be 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80306b:	83 7e 20 00          	cmpl   $0x0,0x20(%esi)
  80306f:	74 1c                	je     80308d <dhcp_create_request+0x96>
  803071:	c7 44 24 08 60 11 81 	movl   $0x811160,0x8(%esp)
  803078:	00 
  803079:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  803080:	00 
  803081:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803088:	e8 eb bd 00 00       	call   80ee78 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80308d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803094:	00 
  803095:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  80309c:	00 
  80309d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8030a4:	e8 cd 1e 00 00       	call   804f76 <pbuf_alloc>
  8030a9:	89 46 1c             	mov    %eax,0x1c(%esi)
  if (dhcp->p_out == NULL) {
  8030ac:	85 c0                	test   %eax,%eax
  8030ae:	0f 84 23 01 00 00    	je     8031d7 <dhcp_create_request+0x1e0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  8030b4:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  8030ba:	77 1c                	ja     8030d8 <dhcp_create_request+0xe1>
  8030bc:	c7 44 24 08 8c 11 81 	movl   $0x81118c,0x8(%esp)
  8030c3:	00 
  8030c4:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8030cb:	00 
  8030cc:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  8030d3:	e8 a0 bd 00 00       	call   80ee78 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8030d8:	8b 15 04 40 81 00    	mov    0x814004,%edx
  8030de:	89 56 04             	mov    %edx,0x4(%esi)
  8030e1:	42                   	inc    %edx
  8030e2:	89 15 04 40 81 00    	mov    %edx,0x814004
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8030e8:	8b 40 04             	mov    0x4(%eax),%eax
  8030eb:	89 46 20             	mov    %eax,0x20(%esi)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8030ee:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8030f1:	8b 46 20             	mov    0x20(%esi),%eax
  8030f4:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8030f8:	8b 46 20             	mov    0x20(%esi),%eax
  8030fb:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  8030ff:	8b 46 20             	mov    0x20(%esi),%eax
  803102:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  803106:	8b 7e 20             	mov    0x20(%esi),%edi
  803109:	8b 46 04             	mov    0x4(%esi),%eax
  80310c:	89 04 24             	mov    %eax,(%esp)
  80310f:	e8 89 4b 00 00       	call   807c9d <htonl>
  803114:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  803117:	8b 46 20             	mov    0x20(%esi),%eax
  80311a:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  803120:	8b 46 20             	mov    0x20(%esi),%eax
  803123:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  803129:	8b 46 20             	mov    0x20(%esi),%eax
  80312c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80312f:	8b 51 04             	mov    0x4(%ecx),%edx
  803132:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  803135:	8b 46 20             	mov    0x20(%esi),%eax
  803138:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  80313f:	8b 46 20             	mov    0x20(%esi),%eax
  803142:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  803149:	8b 46 20             	mov    0x20(%esi),%eax
  80314c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  803153:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  803158:	8b 4e 20             	mov    0x20(%esi),%ecx
  80315b:	89 c2                	mov    %eax,%edx
  80315d:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  803160:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
  803164:	66 39 c7             	cmp    %ax,%di
  803167:	76 07                	jbe    803170 <dhcp_create_request+0x179>
  803169:	0f b6 7c 03 25       	movzbl 0x25(%ebx,%eax,1),%edi
  80316e:	eb 05                	jmp    803175 <dhcp_create_request+0x17e>
  803170:	bf 00 00 00 00       	mov    $0x0,%edi
  803175:	89 fb                	mov    %edi,%ebx
  803177:	88 5c 11 1c          	mov    %bl,0x1c(%ecx,%edx,1)
  80317b:	40                   	inc    %eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80317c:	83 f8 10             	cmp    $0x10,%eax
  80317f:	75 d7                	jne    803158 <dhcp_create_request+0x161>
  803181:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  803183:	8b 56 20             	mov    0x20(%esi),%edx
  803186:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  80318b:	40                   	inc    %eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80318c:	83 f8 40             	cmp    $0x40,%eax
  80318f:	75 f2                	jne    803183 <dhcp_create_request+0x18c>
  803191:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  803193:	8b 56 20             	mov    0x20(%esi),%edx
  803196:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  80319b:	40                   	inc    %eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80319c:	3d 80 00 00 00       	cmp    $0x80,%eax
  8031a1:	75 f0                	jne    803193 <dhcp_create_request+0x19c>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  8031a3:	8b 5e 20             	mov    0x20(%esi),%ebx
  8031a6:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  8031ad:	e8 eb 4a 00 00       	call   807c9d <htonl>
  8031b2:	89 83 ec 00 00 00    	mov    %eax,0xec(%ebx)
  dhcp->options_out_len = 0;
  8031b8:	66 c7 46 24 00 00    	movw   $0x0,0x24(%esi)
  8031be:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  8031c3:	8b 56 20             	mov    0x20(%esi),%edx
  8031c6:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  8031cd:	40                   	inc    %eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8031ce:	83 f8 44             	cmp    $0x44,%eax
  8031d1:	75 f0                	jne    8031c3 <dhcp_create_request+0x1cc>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  8031d3:	b0 00                	mov    $0x0,%al
  8031d5:	eb 02                	jmp    8031d9 <dhcp_create_request+0x1e2>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  8031d7:	b0 ff                	mov    $0xff,%al
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  8031d9:	83 c4 2c             	add    $0x2c,%esp
  8031dc:	5b                   	pop    %ebx
  8031dd:	5e                   	pop    %esi
  8031de:	5f                   	pop    %edi
  8031df:	5d                   	pop    %ebp
  8031e0:	c3                   	ret    

008031e1 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  8031e1:	55                   	push   %ebp
  8031e2:	89 e5                	mov    %esp,%ebp
  8031e4:	57                   	push   %edi
  8031e5:	56                   	push   %esi
  8031e6:	53                   	push   %ebx
  8031e7:	83 ec 2c             	sub    $0x2c,%esp
  8031ea:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8031ec:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  8031ef:	a1 d8 1a 81 00       	mov    0x811ad8,%eax
  8031f4:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8031f7:	89 f8                	mov    %edi,%eax
  8031f9:	e8 f9 fd ff ff       	call   802ff7 <dhcp_create_request>
  8031fe:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803200:	84 c0                	test   %al,%al
  803202:	0f 85 f0 00 00 00    	jne    8032f8 <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803208:	b9 01 00 00 00       	mov    $0x1,%ecx
  80320d:	ba 35 00 00 00       	mov    $0x35,%edx
  803212:	89 d8                	mov    %ebx,%eax
  803214:	e8 68 fa ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  803219:	ba 01 00 00 00       	mov    $0x1,%edx
  80321e:	89 d8                	mov    %ebx,%eax
  803220:	e8 c6 fa ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803225:	b9 02 00 00 00       	mov    $0x2,%ecx
  80322a:	ba 39 00 00 00       	mov    $0x39,%edx
  80322f:	89 d8                	mov    %ebx,%eax
  803231:	e8 4b fa ff ff       	call   802c81 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803236:	ba 40 02 00 00       	mov    $0x240,%edx
  80323b:	89 d8                	mov    %ebx,%eax
  80323d:	e8 b3 fb ff ff       	call   802df5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803242:	b9 04 00 00 00       	mov    $0x4,%ecx
  803247:	ba 37 00 00 00       	mov    $0x37,%edx
  80324c:	89 d8                	mov    %ebx,%eax
  80324e:	e8 2e fa ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803253:	ba 01 00 00 00       	mov    $0x1,%edx
  803258:	89 d8                	mov    %ebx,%eax
  80325a:	e8 8c fa ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80325f:	ba 03 00 00 00       	mov    $0x3,%edx
  803264:	89 d8                	mov    %ebx,%eax
  803266:	e8 80 fa ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80326b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803270:	89 d8                	mov    %ebx,%eax
  803272:	e8 74 fa ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803277:	ba 06 00 00 00       	mov    $0x6,%edx
  80327c:	89 d8                	mov    %ebx,%eax
  80327e:	e8 68 fa ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803283:	89 d8                	mov    %ebx,%eax
  803285:	e8 a7 fa ff ff       	call   802d31 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80328a:	8b 43 24             	mov    0x24(%ebx),%eax
  80328d:	05 f0 00 00 00       	add    $0xf0,%eax
  803292:	0f b7 c0             	movzwl %ax,%eax
  803295:	89 44 24 04          	mov    %eax,0x4(%esp)
  803299:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80329c:	89 04 24             	mov    %eax,(%esp)
  80329f:	e8 a3 1b 00 00       	call   804e47 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8032a4:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8032ab:	00 
  8032ac:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  8032b3:	00 
  8032b4:	8b 43 08             	mov    0x8(%ebx),%eax
  8032b7:	89 04 24             	mov    %eax,(%esp)
  8032ba:	e8 43 63 00 00       	call   809602 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8032bf:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8032c3:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8032ca:	00 
  8032cb:	c7 44 24 08 d4 1a 81 	movl   $0x811ad4,0x8(%esp)
  8032d2:	00 
  8032d3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8032d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032da:	8b 43 08             	mov    0x8(%ebx),%eax
  8032dd:	89 04 24             	mov    %eax,(%esp)
  8032e0:	e8 f8 60 00 00       	call   8093dd <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  8032e5:	89 f8                	mov    %edi,%eax
  8032e7:	e8 1f fc ff ff       	call   802f0b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  8032ec:	ba 06 00 00 00       	mov    $0x6,%edx
  8032f1:	89 d8                	mov    %ebx,%eax
  8032f3:	e8 50 f8 ff ff       	call   802b48 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8032f8:	8a 43 01             	mov    0x1(%ebx),%al
  8032fb:	40                   	inc    %eax
  8032fc:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  8032ff:	3c 03                	cmp    $0x3,%al
  803301:	77 12                	ja     803315 <dhcp_discover+0x134>
  803303:	0f b6 d0             	movzbl %al,%edx
  803306:	8d 54 92 05          	lea    0x5(%edx,%edx,4),%edx
  80330a:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80330d:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803310:	c1 e2 03             	shl    $0x3,%edx
  803313:	eb 05                	jmp    80331a <dhcp_discover+0x139>
  803315:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80331a:	0f b7 d2             	movzwl %dx,%edx
  80331d:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803323:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803328:	f7 ea                	imul   %edx
  80332a:	89 d0                	mov    %edx,%eax
  80332c:	c1 f8 05             	sar    $0x5,%eax
  80332f:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803333:	89 f0                	mov    %esi,%eax
  803335:	83 c4 2c             	add    $0x2c,%esp
  803338:	5b                   	pop    %ebx
  803339:	5e                   	pop    %esi
  80333a:	5f                   	pop    %edi
  80333b:	5d                   	pop    %ebp
  80333c:	c3                   	ret    

0080333d <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80333d:	55                   	push   %ebp
  80333e:	89 e5                	mov    %esp,%ebp
  803340:	57                   	push   %edi
  803341:	56                   	push   %esi
  803342:	53                   	push   %ebx
  803343:	83 ec 2c             	sub    $0x2c,%esp
  803346:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803348:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80334b:	ba 04 00 00 00       	mov    $0x4,%edx
  803350:	89 d8                	mov    %ebx,%eax
  803352:	e8 f1 f7 ff ff       	call   802b48 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803357:	89 f8                	mov    %edi,%eax
  803359:	e8 99 fc ff ff       	call   802ff7 <dhcp_create_request>
  80335e:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803360:	84 c0                	test   %al,%al
  803362:	0f 85 a3 00 00 00    	jne    80340b <dhcp_rebind+0xce>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803368:	b9 01 00 00 00       	mov    $0x1,%ecx
  80336d:	ba 35 00 00 00       	mov    $0x35,%edx
  803372:	89 d8                	mov    %ebx,%eax
  803374:	e8 08 f9 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803379:	ba 03 00 00 00       	mov    $0x3,%edx
  80337e:	89 d8                	mov    %ebx,%eax
  803380:	e8 66 f9 ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803385:	b9 02 00 00 00       	mov    $0x2,%ecx
  80338a:	ba 39 00 00 00       	mov    $0x39,%edx
  80338f:	89 d8                	mov    %ebx,%eax
  803391:	e8 eb f8 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803396:	ba 40 02 00 00       	mov    $0x240,%edx
  80339b:	89 d8                	mov    %ebx,%eax
  80339d:	e8 53 fa ff ff       	call   802df5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  8033a2:	89 d8                	mov    %ebx,%eax
  8033a4:	e8 88 f9 ff ff       	call   802d31 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8033a9:	8b 43 24             	mov    0x24(%ebx),%eax
  8033ac:	05 f0 00 00 00       	add    $0xf0,%eax
  8033b1:	0f b7 c0             	movzwl %ax,%eax
  8033b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033b8:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033bb:	89 04 24             	mov    %eax,(%esp)
  8033be:	e8 84 1a 00 00       	call   804e47 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8033c3:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8033ca:	00 
  8033cb:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  8033d2:	00 
  8033d3:	8b 43 08             	mov    0x8(%ebx),%eax
  8033d6:	89 04 24             	mov    %eax,(%esp)
  8033d9:	e8 24 62 00 00       	call   809602 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8033de:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8033e2:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8033e9:	00 
  8033ea:	c7 44 24 08 d4 1a 81 	movl   $0x811ad4,0x8(%esp)
  8033f1:	00 
  8033f2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033f9:	8b 43 08             	mov    0x8(%ebx),%eax
  8033fc:	89 04 24             	mov    %eax,(%esp)
  8033ff:	e8 d9 5f 00 00       	call   8093dd <udp_sendto_if>
    dhcp_delete_request(netif);
  803404:	89 f8                	mov    %edi,%eax
  803406:	e8 00 fb ff ff       	call   802f0b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80340b:	8a 43 01             	mov    0x1(%ebx),%al
  80340e:	40                   	inc    %eax
  80340f:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803412:	3c 09                	cmp    $0x9,%al
  803414:	77 11                	ja     803427 <dhcp_rebind+0xea>
  803416:	0f b6 d0             	movzbl %al,%edx
  803419:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80341c:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80341f:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803422:	c1 e2 03             	shl    $0x3,%edx
  803425:	eb 05                	jmp    80342c <dhcp_rebind+0xef>
  803427:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80342c:	0f b7 d2             	movzwl %dx,%edx
  80342f:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803435:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80343a:	f7 ea                	imul   %edx
  80343c:	89 d0                	mov    %edx,%eax
  80343e:	c1 f8 05             	sar    $0x5,%eax
  803441:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803445:	89 f0                	mov    %esi,%eax
  803447:	83 c4 2c             	add    $0x2c,%esp
  80344a:	5b                   	pop    %ebx
  80344b:	5e                   	pop    %esi
  80344c:	5f                   	pop    %edi
  80344d:	5d                   	pop    %ebp
  80344e:	c3                   	ret    

0080344f <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80344f:	55                   	push   %ebp
  803450:	89 e5                	mov    %esp,%ebp
  803452:	57                   	push   %edi
  803453:	56                   	push   %esi
  803454:	53                   	push   %ebx
  803455:	83 ec 2c             	sub    $0x2c,%esp
  803458:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80345a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80345d:	e8 95 fb ff ff       	call   802ff7 <dhcp_create_request>
  803462:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803464:	84 c0                	test   %al,%al
  803466:	0f 85 3a 01 00 00    	jne    8035a6 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80346c:	b9 01 00 00 00       	mov    $0x1,%ecx
  803471:	ba 35 00 00 00       	mov    $0x35,%edx
  803476:	89 d8                	mov    %ebx,%eax
  803478:	e8 04 f8 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80347d:	ba 03 00 00 00       	mov    $0x3,%edx
  803482:	89 d8                	mov    %ebx,%eax
  803484:	e8 62 f8 ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803489:	b9 02 00 00 00       	mov    $0x2,%ecx
  80348e:	ba 39 00 00 00       	mov    $0x39,%edx
  803493:	89 d8                	mov    %ebx,%eax
  803495:	e8 e7 f7 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80349a:	ba 40 02 00 00       	mov    $0x240,%edx
  80349f:	89 d8                	mov    %ebx,%eax
  8034a1:	e8 4f f9 ff ff       	call   802df5 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8034a6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034ab:	ba 32 00 00 00       	mov    $0x32,%edx
  8034b0:	89 d8                	mov    %ebx,%eax
  8034b2:	e8 ca f7 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8034b7:	8b 43 30             	mov    0x30(%ebx),%eax
  8034ba:	89 04 24             	mov    %eax,(%esp)
  8034bd:	e8 31 4a 00 00       	call   807ef3 <ntohl>
  8034c2:	89 c2                	mov    %eax,%edx
  8034c4:	89 d8                	mov    %ebx,%eax
  8034c6:	e8 9c f9 ff ff       	call   802e67 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8034cb:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034d0:	ba 36 00 00 00       	mov    $0x36,%edx
  8034d5:	89 d8                	mov    %ebx,%eax
  8034d7:	e8 a5 f7 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8034dc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8034df:	89 04 24             	mov    %eax,(%esp)
  8034e2:	e8 0c 4a 00 00       	call   807ef3 <ntohl>
  8034e7:	89 c2                	mov    %eax,%edx
  8034e9:	89 d8                	mov    %ebx,%eax
  8034eb:	e8 77 f9 ff ff       	call   802e67 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8034f0:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034f5:	ba 37 00 00 00       	mov    $0x37,%edx
  8034fa:	89 d8                	mov    %ebx,%eax
  8034fc:	e8 80 f7 ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803501:	ba 01 00 00 00       	mov    $0x1,%edx
  803506:	89 d8                	mov    %ebx,%eax
  803508:	e8 de f7 ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80350d:	ba 03 00 00 00       	mov    $0x3,%edx
  803512:	89 d8                	mov    %ebx,%eax
  803514:	e8 d2 f7 ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803519:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80351e:	89 d8                	mov    %ebx,%eax
  803520:	e8 c6 f7 ff ff       	call   802ceb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803525:	ba 06 00 00 00       	mov    $0x6,%edx
  80352a:	89 d8                	mov    %ebx,%eax
  80352c:	e8 ba f7 ff ff       	call   802ceb <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  803531:	89 d8                	mov    %ebx,%eax
  803533:	e8 f9 f7 ff ff       	call   802d31 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803538:	8b 43 24             	mov    0x24(%ebx),%eax
  80353b:	05 f0 00 00 00       	add    $0xf0,%eax
  803540:	0f b7 c0             	movzwl %ax,%eax
  803543:	89 44 24 04          	mov    %eax,0x4(%esp)
  803547:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80354a:	89 04 24             	mov    %eax,(%esp)
  80354d:	e8 f5 18 00 00       	call   804e47 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803552:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803556:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80355d:	00 
  80355e:	c7 44 24 08 d4 1a 81 	movl   $0x811ad4,0x8(%esp)
  803565:	00 
  803566:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803569:	89 44 24 04          	mov    %eax,0x4(%esp)
  80356d:	8b 43 08             	mov    0x8(%ebx),%eax
  803570:	89 04 24             	mov    %eax,(%esp)
  803573:	e8 65 5e 00 00       	call   8093dd <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803578:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80357f:	00 
  803580:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803587:	00 
  803588:	8b 43 08             	mov    0x8(%ebx),%eax
  80358b:	89 04 24             	mov    %eax,(%esp)
  80358e:	e8 6f 60 00 00       	call   809602 <udp_connect>
    dhcp_delete_request(netif);
  803593:	89 f8                	mov    %edi,%eax
  803595:	e8 71 f9 ff ff       	call   802f0b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80359a:	ba 01 00 00 00       	mov    $0x1,%edx
  80359f:	89 d8                	mov    %ebx,%eax
  8035a1:	e8 a2 f5 ff ff       	call   802b48 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8035a6:	8a 43 01             	mov    0x1(%ebx),%al
  8035a9:	40                   	inc    %eax
  8035aa:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8035ad:	3c 03                	cmp    $0x3,%al
  8035af:	77 11                	ja     8035c2 <dhcp_select+0x173>
  8035b1:	0f b6 d0             	movzbl %al,%edx
  8035b4:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8035b7:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8035ba:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8035bd:	c1 e2 03             	shl    $0x3,%edx
  8035c0:	eb 05                	jmp    8035c7 <dhcp_select+0x178>
  8035c2:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8035c7:	0f b7 d2             	movzwl %dx,%edx
  8035ca:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8035d0:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8035d5:	f7 ea                	imul   %edx
  8035d7:	89 d0                	mov    %edx,%eax
  8035d9:	c1 f8 05             	sar    $0x5,%eax
  8035dc:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8035e0:	89 f0                	mov    %esi,%eax
  8035e2:	83 c4 2c             	add    $0x2c,%esp
  8035e5:	5b                   	pop    %ebx
  8035e6:	5e                   	pop    %esi
  8035e7:	5f                   	pop    %edi
  8035e8:	5d                   	pop    %ebp
  8035e9:	c3                   	ret    

008035ea <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8035ea:	55                   	push   %ebp
  8035eb:	89 e5                	mov    %esp,%ebp
  8035ed:	53                   	push   %ebx
  8035ee:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  8035f1:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8035f4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8035fb:	00 
  8035fc:	8d 53 30             	lea    0x30(%ebx),%edx
  8035ff:	89 54 24 04          	mov    %edx,0x4(%esp)
  803603:	89 04 24             	mov    %eax,(%esp)
  803606:	e8 c4 69 00 00       	call   809fcf <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80360b:	fe 43 01             	incb   0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80360e:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803614:	ba 08 00 00 00       	mov    $0x8,%edx
  803619:	89 d8                	mov    %ebx,%eax
  80361b:	e8 28 f5 ff ff       	call   802b48 <dhcp_set_state>
}
  803620:	83 c4 14             	add    $0x14,%esp
  803623:	5b                   	pop    %ebx
  803624:	5d                   	pop    %ebp
  803625:	c3                   	ret    

00803626 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  803626:	55                   	push   %ebp
  803627:	89 e5                	mov    %esp,%ebp
  803629:	57                   	push   %edi
  80362a:	56                   	push   %esi
  80362b:	53                   	push   %ebx
  80362c:	83 ec 2c             	sub    $0x2c,%esp
  80362f:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803631:	85 c0                	test   %eax,%eax
  803633:	75 1c                	jne    803651 <dhcp_bind+0x2b>
  803635:	c7 44 24 08 17 12 81 	movl   $0x811217,0x8(%esp)
  80363c:	00 
  80363d:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  803644:	00 
  803645:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  80364c:	e8 27 b8 00 00       	call   80ee78 <_panic>
  dhcp = netif->dhcp;
  803651:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803654:	85 db                	test   %ebx,%ebx
  803656:	75 1c                	jne    803674 <dhcp_bind+0x4e>
  803658:	c7 44 24 08 30 12 81 	movl   $0x811230,0x8(%esp)
  80365f:	00 
  803660:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  803667:	00 
  803668:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  80366f:	e8 04 b8 00 00       	call   80ee78 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803674:	8b 53 50             	mov    0x50(%ebx),%edx
  803677:	83 fa ff             	cmp    $0xffffffff,%edx
  80367a:	74 2d                	je     8036a9 <dhcp_bind+0x83>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80367c:	83 c2 1e             	add    $0x1e,%edx
  80367f:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803684:	89 d0                	mov    %edx,%eax
  803686:	f7 e1                	mul    %ecx
  803688:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80368b:	89 d0                	mov    %edx,%eax
  80368d:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803693:	76 05                	jbe    80369a <dhcp_bind+0x74>
  803695:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80369a:	66 89 43 28          	mov    %ax,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  80369e:	66 85 c0             	test   %ax,%ax
  8036a1:	75 06                	jne    8036a9 <dhcp_bind+0x83>
      dhcp->t1_timeout = 1;
  8036a3:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  8036a9:	8b 53 54             	mov    0x54(%ebx),%edx
  8036ac:	83 fa ff             	cmp    $0xffffffff,%edx
  8036af:	74 2d                	je     8036de <dhcp_bind+0xb8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8036b1:	83 c2 1e             	add    $0x1e,%edx
  8036b4:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8036b9:	89 d0                	mov    %edx,%eax
  8036bb:	f7 e1                	mul    %ecx
  8036bd:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  8036c0:	89 d0                	mov    %edx,%eax
  8036c2:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036c8:	76 05                	jbe    8036cf <dhcp_bind+0xa9>
  8036ca:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036cf:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  8036d3:	66 85 c0             	test   %ax,%ax
  8036d6:	75 06                	jne    8036de <dhcp_bind+0xb8>
      dhcp->t2_timeout = 1;
  8036d8:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8036de:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8036e1:	0f 84 c4 00 00 00    	je     8037ab <dhcp_bind+0x185>
  8036e7:	8b 43 34             	mov    0x34(%ebx),%eax
  8036ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  8036ed:	85 c0                	test   %eax,%eax
  8036ef:	75 48                	jne    803739 <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  8036f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8036f8:	e8 f6 47 00 00       	call   807ef3 <ntohl>
  8036fd:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803700:	84 c0                	test   %al,%al
  803702:	78 11                	js     803715 <dhcp_bind+0xef>
      sn_mask.addr = htonl(0xff000000);
  803704:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  80370b:	e8 8d 45 00 00       	call   807c9d <htonl>
  803710:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803713:	eb 24                	jmp    803739 <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  803715:	3c bf                	cmp    $0xbf,%al
  803717:	76 11                	jbe    80372a <dhcp_bind+0x104>
      sn_mask.addr = htonl(0xffffff00);
  803719:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  803720:	e8 78 45 00 00       	call   807c9d <htonl>
  803725:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803728:	eb 0f                	jmp    803739 <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80372a:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  803731:	e8 67 45 00 00       	call   807c9d <htonl>
  803736:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  803739:	83 fb c8             	cmp    $0xffffffc8,%ebx
  80373c:	74 0a                	je     803748 <dhcp_bind+0x122>
  80373e:	8b 43 38             	mov    0x38(%ebx),%eax
  803741:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803744:	85 c0                	test   %eax,%eax
  803746:	75 1a                	jne    803762 <dhcp_bind+0x13c>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  803748:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80374b:	23 7b 30             	and    0x30(%ebx),%edi
  80374e:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803751:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803758:	e8 40 45 00 00       	call   807c9d <htonl>
  80375d:	09 c7                	or     %eax,%edi
  80375f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803762:	8d 43 30             	lea    0x30(%ebx),%eax
  803765:	89 44 24 04          	mov    %eax,0x4(%esp)
  803769:	89 34 24             	mov    %esi,(%esp)
  80376c:	e8 f7 12 00 00       	call   804a68 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  803771:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803774:	89 44 24 04          	mov    %eax,0x4(%esp)
  803778:	89 34 24             	mov    %esi,(%esp)
  80377b:	e8 81 13 00 00       	call   804b01 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803780:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803783:	89 44 24 04          	mov    %eax,0x4(%esp)
  803787:	89 34 24             	mov    %esi,(%esp)
  80378a:	e8 57 13 00 00       	call   804ae6 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80378f:	89 34 24             	mov    %esi,(%esp)
  803792:	e8 9f 14 00 00       	call   804c36 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803797:	ba 0a 00 00 00       	mov    $0xa,%edx
  80379c:	89 d8                	mov    %ebx,%eax
  80379e:	e8 a5 f3 ff ff       	call   802b48 <dhcp_set_state>
}
  8037a3:	83 c4 2c             	add    $0x2c,%esp
  8037a6:	5b                   	pop    %ebx
  8037a7:	5e                   	pop    %esi
  8037a8:	5f                   	pop    %edi
  8037a9:	5d                   	pop    %ebp
  8037aa:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8037ab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8037b2:	e9 3a ff ff ff       	jmp    8036f1 <dhcp_bind+0xcb>

008037b7 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8037b7:	55                   	push   %ebp
  8037b8:	89 e5                	mov    %esp,%ebp
  8037ba:	57                   	push   %edi
  8037bb:	56                   	push   %esi
  8037bc:	53                   	push   %ebx
  8037bd:	83 ec 2c             	sub    $0x2c,%esp
  8037c0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8037c3:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8037c6:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8037c9:	8b 4f 04             	mov    0x4(%edi),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8037cc:	89 7e 0c             	mov    %edi,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8037cf:	80 39 02             	cmpb   $0x2,(%ecx)
  8037d2:	0f 85 09 04 00 00    	jne    803be1 <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8037d8:	8a 43 24             	mov    0x24(%ebx),%al
  8037db:	88 45 e4             	mov    %al,-0x1c(%ebp)
  8037de:	b8 00 00 00 00       	mov    $0x0,%eax
  8037e3:	eb 0f                	jmp    8037f4 <dhcp_recv+0x3d>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8037e5:	8a 54 03 25          	mov    0x25(%ebx,%eax,1),%dl
  8037e9:	40                   	inc    %eax
  8037ea:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  8037ee:	0f 85 ed 03 00 00    	jne    803be1 <dhcp_recv+0x42a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8037f4:	38 45 e4             	cmp    %al,-0x1c(%ebp)
  8037f7:	77 ec                	ja     8037e5 <dhcp_recv+0x2e>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8037f9:	8b 41 04             	mov    0x4(%ecx),%eax
  8037fc:	89 04 24             	mov    %eax,(%esp)
  8037ff:	e8 ef 46 00 00       	call   807ef3 <ntohl>
  803804:	3b 46 04             	cmp    0x4(%esi),%eax
  803807:	0f 85 d4 03 00 00    	jne    803be1 <dhcp_recv+0x42a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80380d:	85 f6                	test   %esi,%esi
  80380f:	75 1c                	jne    80382d <dhcp_recv+0x76>
  803811:	c7 44 24 08 3b 12 81 	movl   $0x81123b,0x8(%esp)
  803818:	00 
  803819:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  803820:	00 
  803821:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803828:	e8 4b b6 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80382d:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803831:	75 1c                	jne    80384f <dhcp_recv+0x98>
  803833:	c7 44 24 08 48 12 81 	movl   $0x811248,0x8(%esp)
  80383a:	00 
  80383b:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  803842:	00 
  803843:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  80384a:	e8 29 b6 00 00       	call   80ee78 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80384f:	89 f0                	mov    %esi,%eax
  803851:	e8 60 f7 ff ff       	call   802fb6 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  803856:	8b 46 0c             	mov    0xc(%esi),%eax
  803859:	8b 40 08             	mov    0x8(%eax),%eax
  80385c:	66 3d f0 00          	cmp    $0xf0,%ax
  803860:	76 1f                	jbe    803881 <dhcp_recv+0xca>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803862:	2d f0 00 00 00       	sub    $0xf0,%eax
  803867:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80386b:	0f b7 c0             	movzwl %ax,%eax
  80386e:	89 04 24             	mov    %eax,(%esp)
  803871:	e8 c6 0e 00 00       	call   80473c <mem_malloc>
  803876:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  803879:	85 c0                	test   %eax,%eax
  80387b:	0f 84 60 03 00 00    	je     803be1 <dhcp_recv+0x42a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803881:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  803888:	e8 af 0e 00 00       	call   80473c <mem_malloc>
  80388d:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  803890:	85 c0                	test   %eax,%eax
  803892:	75 17                	jne    8038ab <dhcp_recv+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803894:	8b 46 14             	mov    0x14(%esi),%eax
  803897:	89 04 24             	mov    %eax,(%esp)
  80389a:	e8 c9 0b 00 00       	call   804468 <mem_free>
    dhcp->options_in = NULL;
  80389f:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  8038a6:	e9 36 03 00 00       	jmp    803be1 <dhcp_recv+0x42a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8038ab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8038b2:	00 
  8038b3:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  8038ba:	00 
  8038bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8038bf:	8b 46 0c             	mov    0xc(%esi),%eax
  8038c2:	89 04 24             	mov    %eax,(%esp)
  8038c5:	e8 41 1c 00 00       	call   80550b <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038ca:	66 3d f0 00          	cmp    $0xf0,%ax
  8038ce:	74 1c                	je     8038ec <dhcp_recv+0x135>
  8038d0:	c7 44 24 08 d0 11 81 	movl   $0x8111d0,0x8(%esp)
  8038d7:	00 
  8038d8:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8038df:	00 
  8038e0:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  8038e7:	e8 8c b5 00 00       	call   80ee78 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8038ec:	8b 46 14             	mov    0x14(%esi),%eax
  8038ef:	85 c0                	test   %eax,%eax
  8038f1:	0f 84 01 03 00 00    	je     803bf8 <dhcp_recv+0x441>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038f7:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8038fe:	00 
  8038ff:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803903:	89 54 24 08          	mov    %edx,0x8(%esp)
  803907:	89 44 24 04          	mov    %eax,0x4(%esp)
  80390b:	8b 46 0c             	mov    0xc(%esi),%eax
  80390e:	89 04 24             	mov    %eax,(%esp)
  803911:	e8 f5 1b 00 00       	call   80550b <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803916:	66 3b 46 18          	cmp    0x18(%esi),%ax
  80391a:	0f 84 d8 02 00 00    	je     803bf8 <dhcp_recv+0x441>
  803920:	c7 44 24 08 58 12 81 	movl   $0x811258,0x8(%esp)
  803927:	00 
  803928:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  80392f:	00 
  803930:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803937:	e8 3c b5 00 00       	call   80ee78 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80393c:	83 c0 02             	add    $0x2,%eax
  80393f:	e8 11 f3 ff ff       	call   802c55 <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  803944:	3c 05                	cmp    $0x5,%al
  803946:	0f 85 c8 01 00 00    	jne    803b14 <dhcp_recv+0x35d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80394c:	8a 06                	mov    (%esi),%al
  80394e:	3c 01                	cmp    $0x1,%al
  803950:	0f 85 a1 01 00 00    	jne    803af7 <dhcp_recv+0x340>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803956:	8b 53 20             	mov    0x20(%ebx),%edx
  803959:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80395c:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
  dhcp->offered_gw_addr.addr = 0;
  803963:	c7 42 38 00 00 00 00 	movl   $0x0,0x38(%edx)
  dhcp->offered_bc_addr.addr = 0;
  80396a:	c7 42 3c 00 00 00 00 	movl   $0x0,0x3c(%edx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803971:	ba 33 00 00 00       	mov    $0x33,%edx
  803976:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803979:	e8 d9 f1 ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80397e:	85 c0                	test   %eax,%eax
  803980:	74 0e                	je     803990 <dhcp_recv+0x1d9>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803982:	83 c0 02             	add    $0x2,%eax
  803985:	e8 d2 f2 ff ff       	call   802c5c <dhcp_get_option_long>
  80398a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80398d:	89 41 4c             	mov    %eax,0x4c(%ecx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803990:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803995:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803998:	e8 ba f1 ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80399d:	85 c0                	test   %eax,%eax
  80399f:	74 10                	je     8039b1 <dhcp_recv+0x1fa>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8039a1:	83 c0 02             	add    $0x2,%eax
  8039a4:	e8 b3 f2 ff ff       	call   802c5c <dhcp_get_option_long>
  8039a9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8039ac:	89 42 50             	mov    %eax,0x50(%edx)
  8039af:	eb 0b                	jmp    8039bc <dhcp_recv+0x205>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8039b1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039b4:	8b 41 4c             	mov    0x4c(%ecx),%eax
  8039b7:	d1 e8                	shr    %eax
  8039b9:	89 41 50             	mov    %eax,0x50(%ecx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8039bc:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8039c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039c4:	e8 8e f1 ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039c9:	85 c0                	test   %eax,%eax
  8039cb:	74 10                	je     8039dd <dhcp_recv+0x226>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8039cd:	83 c0 02             	add    $0x2,%eax
  8039d0:	e8 87 f2 ff ff       	call   802c5c <dhcp_get_option_long>
  8039d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8039d8:	89 42 54             	mov    %eax,0x54(%edx)
  8039db:	eb 09                	jmp    8039e6 <dhcp_recv+0x22f>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8039dd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039e0:	8b 41 4c             	mov    0x4c(%ecx),%eax
  8039e3:	89 41 54             	mov    %eax,0x54(%ecx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8039e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039e9:	8b 50 10             	mov    0x10(%eax),%edx
  8039ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8039f1:	83 fa f0             	cmp    $0xfffffff0,%edx
  8039f4:	74 03                	je     8039f9 <dhcp_recv+0x242>
  8039f6:	8b 42 10             	mov    0x10(%edx),%eax
  8039f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8039fc:	89 42 30             	mov    %eax,0x30(%edx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8039ff:	ba 01 00 00 00       	mov    $0x1,%edx
  803a04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a07:	e8 4b f1 ff ff       	call   802b57 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  803a0c:	85 c0                	test   %eax,%eax
  803a0e:	74 16                	je     803a26 <dhcp_recv+0x26f>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a10:	83 c0 02             	add    $0x2,%eax
  803a13:	e8 44 f2 ff ff       	call   802c5c <dhcp_get_option_long>
  803a18:	89 04 24             	mov    %eax,(%esp)
  803a1b:	e8 7d 42 00 00       	call   807c9d <htonl>
  803a20:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a23:	89 41 34             	mov    %eax,0x34(%ecx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803a26:	ba 03 00 00 00       	mov    $0x3,%edx
  803a2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a2e:	e8 24 f1 ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a33:	85 c0                	test   %eax,%eax
  803a35:	74 16                	je     803a4d <dhcp_recv+0x296>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a37:	83 c0 02             	add    $0x2,%eax
  803a3a:	e8 1d f2 ff ff       	call   802c5c <dhcp_get_option_long>
  803a3f:	89 04 24             	mov    %eax,(%esp)
  803a42:	e8 56 42 00 00       	call   807c9d <htonl>
  803a47:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803a4a:	89 42 38             	mov    %eax,0x38(%edx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803a4d:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803a52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a55:	e8 fd f0 ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a5a:	85 c0                	test   %eax,%eax
  803a5c:	74 16                	je     803a74 <dhcp_recv+0x2bd>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a5e:	83 c0 02             	add    $0x2,%eax
  803a61:	e8 f6 f1 ff ff       	call   802c5c <dhcp_get_option_long>
  803a66:	89 04 24             	mov    %eax,(%esp)
  803a69:	e8 2f 42 00 00       	call   807c9d <htonl>
  803a6e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a71:	89 41 3c             	mov    %eax,0x3c(%ecx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803a74:	ba 06 00 00 00       	mov    $0x6,%edx
  803a79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a7c:	e8 d6 f0 ff ff       	call   802b57 <dhcp_get_option_ptr>
  803a81:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (option_ptr != NULL) {
  803a84:	85 c0                	test   %eax,%eax
  803a86:	74 5d                	je     803ae5 <dhcp_recv+0x32e>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803a88:	40                   	inc    %eax
  803a89:	e8 c7 f1 ff ff       	call   802c55 <dhcp_get_option_byte>
  803a8e:	c0 e8 02             	shr    $0x2,%al
  803a91:	0f b6 c0             	movzbl %al,%eax
  803a94:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803a97:	89 42 40             	mov    %eax,0x40(%edx)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  803a9a:	83 f8 02             	cmp    $0x2,%eax
  803a9d:	77 06                	ja     803aa5 <dhcp_recv+0x2ee>
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803a9f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  803aa3:	eb 34                	jmp    803ad9 <dhcp_recv+0x322>
  if (option_ptr != NULL) {
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803aa5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803aa8:	c7 41 40 02 00 00 00 	movl   $0x2,0x40(%ecx)
  803aaf:	eb ee                	jmp    803a9f <dhcp_recv+0x2e8>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803ab1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  803ab5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  803ab8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  803abb:	8d 44 82 02          	lea    0x2(%edx,%eax,4),%eax
  803abf:	e8 98 f1 ff ff       	call   802c5c <dhcp_get_option_long>
  803ac4:	89 04 24             	mov    %eax,(%esp)
  803ac7:	e8 d1 41 00 00       	call   807c9d <htonl>
  803acc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  803acf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803ad2:	89 44 8a 44          	mov    %eax,0x44(%edx,%ecx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803ad6:	fe 45 e3             	incb   -0x1d(%ebp)
  803ad9:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  803add:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803ae0:	3b 41 40             	cmp    0x40(%ecx),%eax
  803ae3:	72 cc                	jb     803ab1 <dhcp_recv+0x2fa>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803ae5:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803aeb:	89 d8                	mov    %ebx,%eax
  803aed:	e8 f8 fa ff ff       	call   8035ea <dhcp_check>
  803af2:	e9 ea 00 00 00       	jmp    803be1 <dhcp_recv+0x42a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803af7:	83 e8 03             	sub    $0x3,%eax
  803afa:	3c 02                	cmp    $0x2,%al
  803afc:	0f 87 df 00 00 00    	ja     803be1 <dhcp_recv+0x42a>
      dhcp->request_timeout = 0;
  803b02:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803b08:	89 d8                	mov    %ebx,%eax
  803b0a:	e8 17 fb ff ff       	call   803626 <dhcp_bind>
  803b0f:	e9 cd 00 00 00       	jmp    803be1 <dhcp_recv+0x42a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b14:	3c 06                	cmp    $0x6,%al
  803b16:	75 70                	jne    803b88 <dhcp_recv+0x3d1>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803b18:	8a 06                	mov    (%esi),%al
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b1a:	3c 03                	cmp    $0x3,%al
  803b1c:	74 10                	je     803b2e <dhcp_recv+0x377>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803b1e:	3c 01                	cmp    $0x1,%al
  803b20:	74 0c                	je     803b2e <dhcp_recv+0x377>
  803b22:	3c 04                	cmp    $0x4,%al
  803b24:	74 08                	je     803b2e <dhcp_recv+0x377>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  803b26:	3c 05                	cmp    $0x5,%al
  803b28:	0f 85 b3 00 00 00    	jne    803be1 <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  803b2e:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b34:	8b 43 20             	mov    0x20(%ebx),%eax
  803b37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803b3a:	89 1c 24             	mov    %ebx,(%esp)
  803b3d:	e8 29 11 00 00       	call   804c6b <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803b42:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803b49:	00 
  803b4a:	89 1c 24             	mov    %ebx,(%esp)
  803b4d:	e8 16 0f 00 00       	call   804a68 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803b52:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803b59:	00 
  803b5a:	89 1c 24             	mov    %ebx,(%esp)
  803b5d:	e8 84 0f 00 00       	call   804ae6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803b62:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803b69:	00 
  803b6a:	89 1c 24             	mov    %ebx,(%esp)
  803b6d:	e8 8f 0f 00 00       	call   804b01 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803b72:	ba 0c 00 00 00       	mov    $0xc,%edx
  803b77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b7a:	e8 c9 ef ff ff       	call   802b48 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803b7f:	89 d8                	mov    %ebx,%eax
  803b81:	e8 5b f6 ff ff       	call   8031e1 <dhcp_discover>
  803b86:	eb 59                	jmp    803be1 <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803b88:	3c 02                	cmp    $0x2,%al
  803b8a:	75 55                	jne    803be1 <dhcp_recv+0x42a>
  803b8c:	80 3e 06             	cmpb   $0x6,(%esi)
  803b8f:	75 50                	jne    803be1 <dhcp_recv+0x42a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803b91:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b97:	8b 53 20             	mov    0x20(%ebx),%edx
  803b9a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803b9d:	ba 36 00 00 00       	mov    $0x36,%edx
  803ba2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ba5:	e8 ad ef ff ff       	call   802b57 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803baa:	85 c0                	test   %eax,%eax
  803bac:	74 33                	je     803be1 <dhcp_recv+0x42a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803bae:	83 c0 02             	add    $0x2,%eax
  803bb1:	e8 a6 f0 ff ff       	call   802c5c <dhcp_get_option_long>
  803bb6:	89 04 24             	mov    %eax,(%esp)
  803bb9:	e8 df 40 00 00       	call   807c9d <htonl>
  803bbe:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803bc1:	89 41 2c             	mov    %eax,0x2c(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803bc4:	8b 51 10             	mov    0x10(%ecx),%edx
  803bc7:	b8 00 00 00 00       	mov    $0x0,%eax
  803bcc:	83 fa f0             	cmp    $0xfffffff0,%edx
  803bcf:	74 03                	je     803bd4 <dhcp_recv+0x41d>
  803bd1:	8b 42 10             	mov    0x10(%edx),%eax
  803bd4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803bd7:	89 42 30             	mov    %eax,0x30(%edx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803bda:	89 d8                	mov    %ebx,%eax
  803bdc:	e8 6e f8 ff ff       	call   80344f <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803be1:	89 3c 24             	mov    %edi,(%esp)
  803be4:	e8 8c 11 00 00       	call   804d75 <pbuf_free>
  dhcp->p = NULL;
  803be9:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803bf0:	83 c4 2c             	add    $0x2c,%esp
  803bf3:	5b                   	pop    %ebx
  803bf4:	5e                   	pop    %esi
  803bf5:	5f                   	pop    %edi
  803bf6:	5d                   	pop    %ebp
  803bf7:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803bf8:	ba 35 00 00 00       	mov    $0x35,%edx
  803bfd:	89 f0                	mov    %esi,%eax
  803bff:	e8 53 ef ff ff       	call   802b57 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803c04:	85 c0                	test   %eax,%eax
  803c06:	0f 85 30 fd ff ff    	jne    80393c <dhcp_recv+0x185>
  803c0c:	eb d3                	jmp    803be1 <dhcp_recv+0x42a>

00803c0e <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803c0e:	55                   	push   %ebp
  803c0f:	89 e5                	mov    %esp,%ebp
  803c11:	57                   	push   %edi
  803c12:	56                   	push   %esi
  803c13:	53                   	push   %ebx
  803c14:	83 ec 2c             	sub    $0x2c,%esp
  803c17:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803c1a:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803c1d:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803c24:	e8 13 0b 00 00       	call   80473c <mem_malloc>
  803c29:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803c2b:	85 c0                	test   %eax,%eax
  803c2d:	0f 84 3d 01 00 00    	je     803d70 <dhcp_inform+0x162>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803c33:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803c36:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803c3d:	00 
  803c3e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c45:	00 
  803c46:	89 04 24             	mov    %eax,(%esp)
  803c49:	e8 fc b9 00 00       	call   80f64a <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803c4e:	e8 97 5a 00 00       	call   8096ea <udp_new>
  803c53:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803c56:	85 c0                	test   %eax,%eax
  803c58:	75 0d                	jne    803c67 <dhcp_inform+0x59>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803c5a:	89 1c 24             	mov    %ebx,(%esp)
  803c5d:	e8 06 08 00 00       	call   804468 <mem_free>
    return;
  803c62:	e9 09 01 00 00       	jmp    803d70 <dhcp_inform+0x162>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803c67:	89 f0                	mov    %esi,%eax
  803c69:	e8 89 f3 ff ff       	call   802ff7 <dhcp_create_request>
  if (result == ERR_OK) {
  803c6e:	84 c0                	test   %al,%al
  803c70:	0f 85 d9 00 00 00    	jne    803d4f <dhcp_inform+0x141>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c76:	b9 01 00 00 00       	mov    $0x1,%ecx
  803c7b:	ba 35 00 00 00       	mov    $0x35,%edx
  803c80:	89 d8                	mov    %ebx,%eax
  803c82:	e8 fa ef ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803c87:	ba 08 00 00 00       	mov    $0x8,%edx
  803c8c:	89 d8                	mov    %ebx,%eax
  803c8e:	e8 58 f0 ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803c93:	b9 02 00 00 00       	mov    $0x2,%ecx
  803c98:	ba 39 00 00 00       	mov    $0x39,%edx
  803c9d:	89 d8                	mov    %ebx,%eax
  803c9f:	e8 dd ef ff ff       	call   802c81 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803ca4:	ba 40 02 00 00       	mov    $0x240,%edx
  803ca9:	89 d8                	mov    %ebx,%eax
  803cab:	e8 45 f1 ff ff       	call   802df5 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803cb0:	89 d8                	mov    %ebx,%eax
  803cb2:	e8 7a f0 ff ff       	call   802d31 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803cb7:	8b 43 24             	mov    0x24(%ebx),%eax
  803cba:	05 f0 00 00 00       	add    $0xf0,%eax
  803cbf:	0f b7 c0             	movzwl %ax,%eax
  803cc2:	89 44 24 04          	mov    %eax,0x4(%esp)
  803cc6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803cc9:	89 04 24             	mov    %eax,(%esp)
  803ccc:	e8 76 11 00 00       	call   804e47 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803cd1:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803cd8:	00 
  803cd9:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803ce0:	00 
  803ce1:	8b 43 08             	mov    0x8(%ebx),%eax
  803ce4:	89 04 24             	mov    %eax,(%esp)
  803ce7:	e8 36 56 00 00       	call   809322 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803cec:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803cf3:	00 
  803cf4:	c7 44 24 04 d4 1a 81 	movl   $0x811ad4,0x4(%esp)
  803cfb:	00 
  803cfc:	8b 43 08             	mov    0x8(%ebx),%eax
  803cff:	89 04 24             	mov    %eax,(%esp)
  803d02:	e8 fb 58 00 00       	call   809602 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803d07:	89 74 24 10          	mov    %esi,0x10(%esp)
  803d0b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803d12:	00 
  803d13:	c7 44 24 08 d4 1a 81 	movl   $0x811ad4,0x8(%esp)
  803d1a:	00 
  803d1b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d22:	8b 43 08             	mov    0x8(%ebx),%eax
  803d25:	89 04 24             	mov    %eax,(%esp)
  803d28:	e8 b0 56 00 00       	call   8093dd <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803d2d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d34:	00 
  803d35:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803d3c:	00 
  803d3d:	8b 43 08             	mov    0x8(%ebx),%eax
  803d40:	89 04 24             	mov    %eax,(%esp)
  803d43:	e8 ba 58 00 00       	call   809602 <udp_connect>
    dhcp_delete_request(netif);
  803d48:	89 f0                	mov    %esi,%eax
  803d4a:	e8 bc f1 ff ff       	call   802f0b <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803d4f:	8b 43 08             	mov    0x8(%ebx),%eax
  803d52:	85 c0                	test   %eax,%eax
  803d54:	74 08                	je     803d5e <dhcp_inform+0x150>
      udp_remove(dhcp->pcb);
  803d56:	89 04 24             	mov    %eax,(%esp)
  803d59:	e8 46 59 00 00       	call   8096a4 <udp_remove>
    }
    dhcp->pcb = NULL;
  803d5e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803d65:	89 1c 24             	mov    %ebx,(%esp)
  803d68:	e8 fb 06 00 00       	call   804468 <mem_free>
    netif->dhcp = old_dhcp;
  803d6d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  803d70:	83 c4 2c             	add    $0x2c,%esp
  803d73:	5b                   	pop    %ebx
  803d74:	5e                   	pop    %esi
  803d75:	5f                   	pop    %edi
  803d76:	5d                   	pop    %ebp
  803d77:	c3                   	ret    

00803d78 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803d78:	55                   	push   %ebp
  803d79:	89 e5                	mov    %esp,%ebp
  803d7b:	56                   	push   %esi
  803d7c:	53                   	push   %ebx
  803d7d:	83 ec 20             	sub    $0x20,%esp
  803d80:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803d83:	85 f6                	test   %esi,%esi
  803d85:	75 1c                	jne    803da3 <dhcp_arp_reply+0x2b>
  803d87:	c7 44 24 08 22 12 81 	movl   $0x811222,0x8(%esp)
  803d8e:	00 
  803d8f:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803d96:	00 
  803d97:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  803d9e:	e8 d5 b0 00 00       	call   80ee78 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803da3:	8b 5e 20             	mov    0x20(%esi),%ebx
  803da6:	85 db                	test   %ebx,%ebx
  803da8:	0f 84 03 01 00 00    	je     803eb1 <dhcp_arp_reply+0x139>
  803dae:	80 3b 08             	cmpb   $0x8,(%ebx)
  803db1:	0f 85 fa 00 00 00    	jne    803eb1 <dhcp_arp_reply+0x139>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803db7:	8b 45 0c             	mov    0xc(%ebp),%eax
  803dba:	8b 53 30             	mov    0x30(%ebx),%edx
  803dbd:	39 10                	cmp    %edx,(%eax)
  803dbf:	0f 85 ec 00 00 00    	jne    803eb1 <dhcp_arp_reply+0x139>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803dc5:	ba 0c 00 00 00       	mov    $0xc,%edx
  803dca:	89 d8                	mov    %ebx,%eax
  803dcc:	e8 77 ed ff ff       	call   802b48 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803dd1:	89 f0                	mov    %esi,%eax
  803dd3:	e8 1f f2 ff ff       	call   802ff7 <dhcp_create_request>
  if (result == ERR_OK) {
  803dd8:	84 c0                	test   %al,%al
  803dda:	0f 85 c8 00 00 00    	jne    803ea8 <dhcp_arp_reply+0x130>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803de0:	b9 01 00 00 00       	mov    $0x1,%ecx
  803de5:	ba 35 00 00 00       	mov    $0x35,%edx
  803dea:	89 d8                	mov    %ebx,%eax
  803dec:	e8 90 ee ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803df1:	ba 04 00 00 00       	mov    $0x4,%edx
  803df6:	89 d8                	mov    %ebx,%eax
  803df8:	e8 ee ee ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803dfd:	b9 02 00 00 00       	mov    $0x2,%ecx
  803e02:	ba 39 00 00 00       	mov    $0x39,%edx
  803e07:	89 d8                	mov    %ebx,%eax
  803e09:	e8 73 ee ff ff       	call   802c81 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803e0e:	ba 40 02 00 00       	mov    $0x240,%edx
  803e13:	89 d8                	mov    %ebx,%eax
  803e15:	e8 db ef ff ff       	call   802df5 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803e1a:	b9 04 00 00 00       	mov    $0x4,%ecx
  803e1f:	ba 32 00 00 00       	mov    $0x32,%edx
  803e24:	89 d8                	mov    %ebx,%eax
  803e26:	e8 56 ee ff ff       	call   802c81 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803e2b:	8b 43 30             	mov    0x30(%ebx),%eax
  803e2e:	89 04 24             	mov    %eax,(%esp)
  803e31:	e8 bd 40 00 00       	call   807ef3 <ntohl>
  803e36:	89 c2                	mov    %eax,%edx
  803e38:	89 d8                	mov    %ebx,%eax
  803e3a:	e8 28 f0 ff ff       	call   802e67 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803e3f:	89 d8                	mov    %ebx,%eax
  803e41:	e8 eb ee ff ff       	call   802d31 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803e46:	8b 43 24             	mov    0x24(%ebx),%eax
  803e49:	05 f0 00 00 00       	add    $0xf0,%eax
  803e4e:	0f b7 c0             	movzwl %ax,%eax
  803e51:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e55:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803e58:	89 04 24             	mov    %eax,(%esp)
  803e5b:	e8 e7 0f 00 00       	call   804e47 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e60:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803e67:	00 
  803e68:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  803e6f:	00 
  803e70:	8b 43 08             	mov    0x8(%ebx),%eax
  803e73:	89 04 24             	mov    %eax,(%esp)
  803e76:	e8 87 57 00 00       	call   809602 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803e7b:	89 74 24 10          	mov    %esi,0x10(%esp)
  803e7f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803e86:	00 
  803e87:	c7 44 24 08 d4 1a 81 	movl   $0x811ad4,0x8(%esp)
  803e8e:	00 
  803e8f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803e92:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e96:	8b 43 08             	mov    0x8(%ebx),%eax
  803e99:	89 04 24             	mov    %eax,(%esp)
  803e9c:	e8 3c 55 00 00       	call   8093dd <udp_sendto_if>
    dhcp_delete_request(netif);
  803ea1:	89 f0                	mov    %esi,%eax
  803ea3:	e8 63 f0 ff ff       	call   802f0b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803ea8:	fe 43 01             	incb   0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803eab:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803eb1:	83 c4 20             	add    $0x20,%esp
  803eb4:	5b                   	pop    %ebx
  803eb5:	5e                   	pop    %esi
  803eb6:	5d                   	pop    %ebp
  803eb7:	c3                   	ret    

00803eb8 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803eb8:	55                   	push   %ebp
  803eb9:	89 e5                	mov    %esp,%ebp
  803ebb:	57                   	push   %edi
  803ebc:	56                   	push   %esi
  803ebd:	53                   	push   %ebx
  803ebe:	83 ec 3c             	sub    $0x3c,%esp
  803ec1:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803ec4:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803ec7:	ba 05 00 00 00       	mov    $0x5,%edx
  803ecc:	89 d8                	mov    %ebx,%eax
  803ece:	e8 75 ec ff ff       	call   802b48 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803ed3:	89 f8                	mov    %edi,%eax
  803ed5:	e8 1d f1 ff ff       	call   802ff7 <dhcp_create_request>
  803eda:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803edc:	84 c0                	test   %al,%al
  803ede:	0f 85 a4 00 00 00    	jne    803f88 <dhcp_renew+0xd0>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803ee4:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ee9:	ba 35 00 00 00       	mov    $0x35,%edx
  803eee:	89 d8                	mov    %ebx,%eax
  803ef0:	e8 8c ed ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803ef5:	ba 03 00 00 00       	mov    $0x3,%edx
  803efa:	89 d8                	mov    %ebx,%eax
  803efc:	e8 ea ed ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803f01:	b9 02 00 00 00       	mov    $0x2,%ecx
  803f06:	ba 39 00 00 00       	mov    $0x39,%edx
  803f0b:	89 d8                	mov    %ebx,%eax
  803f0d:	e8 6f ed ff ff       	call   802c81 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803f12:	ba 40 02 00 00       	mov    $0x240,%edx
  803f17:	89 d8                	mov    %ebx,%eax
  803f19:	e8 d7 ee ff ff       	call   802df5 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803f1e:	89 d8                	mov    %ebx,%eax
  803f20:	e8 0c ee ff ff       	call   802d31 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803f25:	8b 43 24             	mov    0x24(%ebx),%eax
  803f28:	05 f0 00 00 00       	add    $0xf0,%eax
  803f2d:	0f b7 c0             	movzwl %ax,%eax
  803f30:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f34:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f37:	89 04 24             	mov    %eax,(%esp)
  803f3a:	e8 08 0f 00 00       	call   804e47 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803f3f:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803f42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803f45:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803f4c:	00 
  803f4d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f51:	8b 43 08             	mov    0x8(%ebx),%eax
  803f54:	89 04 24             	mov    %eax,(%esp)
  803f57:	e8 a6 56 00 00       	call   809602 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803f5c:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803f60:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803f67:	00 
  803f68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f6b:	89 44 24 08          	mov    %eax,0x8(%esp)
  803f6f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f72:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f76:	8b 43 08             	mov    0x8(%ebx),%eax
  803f79:	89 04 24             	mov    %eax,(%esp)
  803f7c:	e8 5c 54 00 00       	call   8093dd <udp_sendto_if>
    dhcp_delete_request(netif);
  803f81:	89 f8                	mov    %edi,%eax
  803f83:	e8 83 ef ff ff       	call   802f0b <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803f88:	8a 43 01             	mov    0x1(%ebx),%al
  803f8b:	40                   	inc    %eax
  803f8c:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803f8f:	3c 09                	cmp    $0x9,%al
  803f91:	77 11                	ja     803fa4 <dhcp_renew+0xec>
  803f93:	0f b6 d0             	movzbl %al,%edx
  803f96:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f99:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f9c:	8d 14 92             	lea    (%edx,%edx,4),%edx
  803f9f:	c1 e2 04             	shl    $0x4,%edx
  803fa2:	eb 05                	jmp    803fa9 <dhcp_renew+0xf1>
  803fa4:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803fa9:	0f b7 d2             	movzwl %dx,%edx
  803fac:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803fb2:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  803fb7:	f7 ea                	imul   %edx
  803fb9:	89 d0                	mov    %edx,%eax
  803fbb:	c1 f8 05             	sar    $0x5,%eax
  803fbe:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803fc2:	89 f0                	mov    %esi,%eax
  803fc4:	83 c4 3c             	add    $0x3c,%esp
  803fc7:	5b                   	pop    %ebx
  803fc8:	5e                   	pop    %esi
  803fc9:	5f                   	pop    %edi
  803fca:	5d                   	pop    %ebp
  803fcb:	c3                   	ret    

00803fcc <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803fcc:	55                   	push   %ebp
  803fcd:	89 e5                	mov    %esp,%ebp
  803fcf:	53                   	push   %ebx
  803fd0:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  803fd3:	8b 1d 74 b2 b3 00    	mov    0xb3b274,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803fd9:	eb 60                	jmp    80403b <dhcp_coarse_tmr+0x6f>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803fdb:	8b 43 20             	mov    0x20(%ebx),%eax
  803fde:	85 c0                	test   %eax,%eax
  803fe0:	74 57                	je     804039 <dhcp_coarse_tmr+0x6d>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803fe2:	66 8b 50 2a          	mov    0x2a(%eax),%dx
  803fe6:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803fe9:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803fed:	66 83 fa 01          	cmp    $0x1,%dx
  803ff1:	75 1a                	jne    80400d <dhcp_coarse_tmr+0x41>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803ff3:	8b 43 20             	mov    0x20(%ebx),%eax
  803ff6:	8a 00                	mov    (%eax),%al
  803ff8:	3c 01                	cmp    $0x1,%al
  803ffa:	74 08                	je     804004 <dhcp_coarse_tmr+0x38>
  803ffc:	3c 0a                	cmp    $0xa,%al
  803ffe:	74 04                	je     804004 <dhcp_coarse_tmr+0x38>
  804000:	3c 05                	cmp    $0x5,%al
  804002:	75 35                	jne    804039 <dhcp_coarse_tmr+0x6d>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  804004:	89 d8                	mov    %ebx,%eax
  804006:	e8 32 f3 ff ff       	call   80333d <dhcp_rebind>
  80400b:	eb 2c                	jmp    804039 <dhcp_coarse_tmr+0x6d>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  80400d:	8b 53 20             	mov    0x20(%ebx),%edx
  804010:	8b 42 28             	mov    0x28(%edx),%eax
  804013:	8d 48 ff             	lea    -0x1(%eax),%ecx
  804016:	66 89 4a 28          	mov    %cx,0x28(%edx)
  80401a:	66 83 f8 01          	cmp    $0x1,%ax
  80401e:	75 19                	jne    804039 <dhcp_coarse_tmr+0x6d>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804020:	8b 43 20             	mov    0x20(%ebx),%eax
  804023:	8a 00                	mov    (%eax),%al
  804025:	3c 01                	cmp    $0x1,%al
  804027:	74 08                	je     804031 <dhcp_coarse_tmr+0x65>
  804029:	3c 0a                	cmp    $0xa,%al
  80402b:	74 04                	je     804031 <dhcp_coarse_tmr+0x65>
  80402d:	3c 05                	cmp    $0x5,%al
  80402f:	75 08                	jne    804039 <dhcp_coarse_tmr+0x6d>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  804031:	89 1c 24             	mov    %ebx,(%esp)
  804034:	e8 7f fe ff ff       	call   803eb8 <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  804039:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80403b:	85 db                	test   %ebx,%ebx
  80403d:	75 9c                	jne    803fdb <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  80403f:	83 c4 14             	add    $0x14,%esp
  804042:	5b                   	pop    %ebx
  804043:	5d                   	pop    %ebp
  804044:	c3                   	ret    

00804045 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  804045:	55                   	push   %ebp
  804046:	89 e5                	mov    %esp,%ebp
  804048:	57                   	push   %edi
  804049:	56                   	push   %esi
  80404a:	53                   	push   %ebx
  80404b:	83 ec 3c             	sub    $0x3c,%esp
  80404e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  804051:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  804054:	ba 0d 00 00 00       	mov    $0xd,%edx
  804059:	89 d8                	mov    %ebx,%eax
  80405b:	e8 e8 ea ff ff       	call   802b48 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  804060:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  804067:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  80406e:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  804075:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  80407c:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  804083:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  80408a:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  804091:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  804098:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80409f:	89 f0                	mov    %esi,%eax
  8040a1:	e8 51 ef ff ff       	call   802ff7 <dhcp_create_request>
  8040a6:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8040a8:	84 c0                	test   %al,%al
  8040aa:	0f 85 87 00 00 00    	jne    804137 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8040b0:	b9 01 00 00 00       	mov    $0x1,%ecx
  8040b5:	ba 35 00 00 00       	mov    $0x35,%edx
  8040ba:	89 d8                	mov    %ebx,%eax
  8040bc:	e8 c0 eb ff ff       	call   802c81 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  8040c1:	ba 07 00 00 00       	mov    $0x7,%edx
  8040c6:	89 d8                	mov    %ebx,%eax
  8040c8:	e8 1e ec ff ff       	call   802ceb <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8040cd:	89 d8                	mov    %ebx,%eax
  8040cf:	e8 5d ec ff ff       	call   802d31 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8040d4:	8b 43 24             	mov    0x24(%ebx),%eax
  8040d7:	05 f0 00 00 00       	add    $0xf0,%eax
  8040dc:	0f b7 c0             	movzwl %ax,%eax
  8040df:	89 44 24 04          	mov    %eax,0x4(%esp)
  8040e3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8040e6:	89 04 24             	mov    %eax,(%esp)
  8040e9:	e8 59 0d 00 00       	call   804e47 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8040ee:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8040f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8040f4:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8040fb:	00 
  8040fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  804100:	8b 43 08             	mov    0x8(%ebx),%eax
  804103:	89 04 24             	mov    %eax,(%esp)
  804106:	e8 f7 54 00 00       	call   809602 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80410b:	89 74 24 10          	mov    %esi,0x10(%esp)
  80410f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  804116:	00 
  804117:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80411a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80411e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  804121:	89 44 24 04          	mov    %eax,0x4(%esp)
  804125:	8b 43 08             	mov    0x8(%ebx),%eax
  804128:	89 04 24             	mov    %eax,(%esp)
  80412b:	e8 ad 52 00 00       	call   8093dd <udp_sendto_if>
    dhcp_delete_request(netif);
  804130:	89 f0                	mov    %esi,%eax
  804132:	e8 d4 ed ff ff       	call   802f0b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  804137:	8a 43 01             	mov    0x1(%ebx),%al
  80413a:	40                   	inc    %eax
  80413b:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80413e:	3c 09                	cmp    $0x9,%al
  804140:	77 11                	ja     804153 <dhcp_release+0x10e>
  804142:	0f b6 d0             	movzbl %al,%edx
  804145:	8d 14 92             	lea    (%edx,%edx,4),%edx
  804148:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80414b:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80414e:	c1 e2 03             	shl    $0x3,%edx
  804151:	eb 05                	jmp    804158 <dhcp_release+0x113>
  804153:	ba 10 27 00 00       	mov    $0x2710,%edx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  804158:	0f b7 d2             	movzwl %dx,%edx
  80415b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  804161:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  804166:	f7 ea                	imul   %edx
  804168:	89 d0                	mov    %edx,%eax
  80416a:	c1 f8 05             	sar    $0x5,%eax
  80416d:	66 89 43 26          	mov    %ax,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  804171:	89 34 24             	mov    %esi,(%esp)
  804174:	e8 f2 0a 00 00       	call   804c6b <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  804179:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  804180:	00 
  804181:	89 34 24             	mov    %esi,(%esp)
  804184:	e8 df 08 00 00       	call   804a68 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  804189:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  804190:	00 
  804191:	89 34 24             	mov    %esi,(%esp)
  804194:	e8 4d 09 00 00       	call   804ae6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  804199:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  8041a0:	00 
  8041a1:	89 34 24             	mov    %esi,(%esp)
  8041a4:	e8 58 09 00 00       	call   804b01 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  8041a9:	89 f8                	mov    %edi,%eax
  8041ab:	83 c4 3c             	add    $0x3c,%esp
  8041ae:	5b                   	pop    %ebx
  8041af:	5e                   	pop    %esi
  8041b0:	5f                   	pop    %edi
  8041b1:	5d                   	pop    %ebp
  8041b2:	c3                   	ret    

008041b3 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  8041b3:	55                   	push   %ebp
  8041b4:	89 e5                	mov    %esp,%ebp
  8041b6:	53                   	push   %ebx
  8041b7:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  8041ba:	8b 1d 74 b2 b3 00    	mov    0xb3b274,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  8041c0:	e9 b7 00 00 00       	jmp    80427c <dhcp_fine_tmr+0xc9>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8041c5:	8b 43 20             	mov    0x20(%ebx),%eax
  8041c8:	85 c0                	test   %eax,%eax
  8041ca:	0f 84 aa 00 00 00    	je     80427a <dhcp_fine_tmr+0xc7>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8041d0:	66 8b 50 26          	mov    0x26(%eax),%dx
  8041d4:	66 83 fa 01          	cmp    $0x1,%dx
  8041d8:	76 0a                	jbe    8041e4 <dhcp_fine_tmr+0x31>
        netif->dhcp->request_timeout--;
  8041da:	4a                   	dec    %edx
  8041db:	66 89 50 26          	mov    %dx,0x26(%eax)
  8041df:	e9 96 00 00 00       	jmp    80427a <dhcp_fine_tmr+0xc7>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8041e4:	66 83 fa 01          	cmp    $0x1,%dx
  8041e8:	0f 85 8c 00 00 00    	jne    80427a <dhcp_fine_tmr+0xc7>
        netif->dhcp->request_timeout--;
  8041ee:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8041f4:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  8041f7:	8a 02                	mov    (%edx),%al
  8041f9:	3c 0c                	cmp    $0xc,%al
  8041fb:	74 04                	je     804201 <dhcp_fine_tmr+0x4e>
  8041fd:	3c 06                	cmp    $0x6,%al
  8041ff:	75 09                	jne    80420a <dhcp_fine_tmr+0x57>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  804201:	89 d8                	mov    %ebx,%eax
  804203:	e8 d9 ef ff ff       	call   8031e1 <dhcp_discover>
  804208:	eb 70                	jmp    80427a <dhcp_fine_tmr+0xc7>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  80420a:	3c 01                	cmp    $0x1,%al
  80420c:	75 20                	jne    80422e <dhcp_fine_tmr+0x7b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  80420e:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  804212:	77 09                	ja     80421d <dhcp_fine_tmr+0x6a>
      dhcp_select(netif);
  804214:	89 d8                	mov    %ebx,%eax
  804216:	e8 34 f2 ff ff       	call   80344f <dhcp_select>
  80421b:	eb 5d                	jmp    80427a <dhcp_fine_tmr+0xc7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  80421d:	89 1c 24             	mov    %ebx,(%esp)
  804220:	e8 20 fe ff ff       	call   804045 <dhcp_release>
      dhcp_discover(netif);
  804225:	89 d8                	mov    %ebx,%eax
  804227:	e8 b5 ef ff ff       	call   8031e1 <dhcp_discover>
  80422c:	eb 4c                	jmp    80427a <dhcp_fine_tmr+0xc7>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  80422e:	3c 08                	cmp    $0x8,%al
  804230:	75 18                	jne    80424a <dhcp_fine_tmr+0x97>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  804232:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  804236:	77 09                	ja     804241 <dhcp_fine_tmr+0x8e>
      dhcp_check(netif);
  804238:	89 d8                	mov    %ebx,%eax
  80423a:	e8 ab f3 ff ff       	call   8035ea <dhcp_check>
  80423f:	eb 39                	jmp    80427a <dhcp_fine_tmr+0xc7>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  804241:	89 d8                	mov    %ebx,%eax
  804243:	e8 de f3 ff ff       	call   803626 <dhcp_bind>
  804248:	eb 30                	jmp    80427a <dhcp_fine_tmr+0xc7>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  80424a:	3c 05                	cmp    $0x5,%al
  80424c:	75 0a                	jne    804258 <dhcp_fine_tmr+0xa5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  80424e:	89 1c 24             	mov    %ebx,(%esp)
  804251:	e8 62 fc ff ff       	call   803eb8 <dhcp_renew>
  804256:	eb 22                	jmp    80427a <dhcp_fine_tmr+0xc7>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  804258:	3c 04                	cmp    $0x4,%al
  80425a:	75 1e                	jne    80427a <dhcp_fine_tmr+0xc7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80425c:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  804260:	77 09                	ja     80426b <dhcp_fine_tmr+0xb8>
      dhcp_rebind(netif);
  804262:	89 d8                	mov    %ebx,%eax
  804264:	e8 d4 f0 ff ff       	call   80333d <dhcp_rebind>
  804269:	eb 0f                	jmp    80427a <dhcp_fine_tmr+0xc7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80426b:	89 1c 24             	mov    %ebx,(%esp)
  80426e:	e8 d2 fd ff ff       	call   804045 <dhcp_release>
      dhcp_discover(netif);
  804273:	89 d8                	mov    %ebx,%eax
  804275:	e8 67 ef ff ff       	call   8031e1 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  80427a:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  80427c:	85 db                	test   %ebx,%ebx
  80427e:	0f 85 41 ff ff ff    	jne    8041c5 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  804284:	83 c4 14             	add    $0x14,%esp
  804287:	5b                   	pop    %ebx
  804288:	5d                   	pop    %ebp
  804289:	c3                   	ret    

0080428a <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80428a:	55                   	push   %ebp
  80428b:	89 e5                	mov    %esp,%ebp
  80428d:	56                   	push   %esi
  80428e:	53                   	push   %ebx
  80428f:	83 ec 10             	sub    $0x10,%esp
  804292:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  804295:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  804298:	85 f6                	test   %esi,%esi
  80429a:	75 1c                	jne    8042b8 <dhcp_stop+0x2e>
  80429c:	c7 44 24 08 74 12 81 	movl   $0x811274,0x8(%esp)
  8042a3:	00 
  8042a4:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  8042ab:	00 
  8042ac:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  8042b3:	e8 c0 ab 00 00       	call   80ee78 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8042b8:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  8042bc:	85 db                	test   %ebx,%ebx
  8042be:	74 42                	je     804302 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  8042c0:	8b 43 08             	mov    0x8(%ebx),%eax
  8042c3:	85 c0                	test   %eax,%eax
  8042c5:	74 0f                	je     8042d6 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  8042c7:	89 04 24             	mov    %eax,(%esp)
  8042ca:	e8 d5 53 00 00       	call   8096a4 <udp_remove>
      dhcp->pcb = NULL;
  8042cf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  8042d6:	8b 43 0c             	mov    0xc(%ebx),%eax
  8042d9:	85 c0                	test   %eax,%eax
  8042db:	74 0f                	je     8042ec <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8042dd:	89 04 24             	mov    %eax,(%esp)
  8042e0:	e8 90 0a 00 00       	call   804d75 <pbuf_free>
      dhcp->p = NULL;
  8042e5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8042ec:	89 d8                	mov    %ebx,%eax
  8042ee:	e8 c3 ec ff ff       	call   802fb6 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8042f3:	89 1c 24             	mov    %ebx,(%esp)
  8042f6:	e8 6d 01 00 00       	call   804468 <mem_free>
    netif->dhcp = NULL;
  8042fb:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  804302:	83 c4 10             	add    $0x10,%esp
  804305:	5b                   	pop    %ebx
  804306:	5e                   	pop    %esi
  804307:	5d                   	pop    %ebp
  804308:	c3                   	ret    

00804309 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  804309:	55                   	push   %ebp
  80430a:	89 e5                	mov    %esp,%ebp
  80430c:	56                   	push   %esi
  80430d:	53                   	push   %ebx
  80430e:	83 ec 10             	sub    $0x10,%esp
  804311:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  804314:	85 f6                	test   %esi,%esi
  804316:	75 1c                	jne    804334 <dhcp_start+0x2b>
  804318:	c7 44 24 08 22 12 81 	movl   $0x811222,0x8(%esp)
  80431f:	00 
  804320:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  804327:	00 
  804328:	c7 04 24 02 12 81 00 	movl   $0x811202,(%esp)
  80432f:	e8 44 ab 00 00       	call   80ee78 <_panic>
  dhcp = netif->dhcp;
  804334:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804337:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  80433b:	85 db                	test   %ebx,%ebx
  80433d:	75 19                	jne    804358 <dhcp_start+0x4f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  80433f:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  804346:	e8 f1 03 00 00       	call   80473c <mem_malloc>
  80434b:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  80434d:	85 c0                	test   %eax,%eax
  80434f:	0f 84 a1 00 00 00    	je     8043f6 <dhcp_start+0xed>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  804355:	89 46 20             	mov    %eax,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  804358:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80435f:	00 
  804360:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804367:	00 
  804368:	89 1c 24             	mov    %ebx,(%esp)
  80436b:	e8 da b2 00 00       	call   80f64a <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  804370:	e8 75 53 00 00       	call   8096ea <udp_new>
  804375:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  804378:	85 c0                	test   %eax,%eax
  80437a:	75 13                	jne    80438f <dhcp_start+0x86>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  80437c:	89 1c 24             	mov    %ebx,(%esp)
  80437f:	e8 e4 00 00 00       	call   804468 <mem_free>
    netif->dhcp = dhcp = NULL;
  804384:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    return ERR_MEM;
  80438b:	b0 ff                	mov    $0xff,%al
  80438d:	eb 69                	jmp    8043f8 <dhcp_start+0xef>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80438f:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  804396:	00 
  804397:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  80439e:	00 
  80439f:	89 04 24             	mov    %eax,(%esp)
  8043a2:	e8 7b 4f 00 00       	call   809322 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8043a7:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8043ae:	00 
  8043af:	c7 44 24 04 d8 1a 81 	movl   $0x811ad8,0x4(%esp)
  8043b6:	00 
  8043b7:	8b 43 08             	mov    0x8(%ebx),%eax
  8043ba:	89 04 24             	mov    %eax,(%esp)
  8043bd:	e8 40 52 00 00       	call   809602 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  8043c2:	89 74 24 08          	mov    %esi,0x8(%esp)
  8043c6:	c7 44 24 04 b7 37 80 	movl   $0x8037b7,0x4(%esp)
  8043cd:	00 
  8043ce:	8b 43 08             	mov    0x8(%ebx),%eax
  8043d1:	89 04 24             	mov    %eax,(%esp)
  8043d4:	e8 b7 52 00 00       	call   809690 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  8043d9:	89 f0                	mov    %esi,%eax
  8043db:	e8 01 ee ff ff       	call   8031e1 <dhcp_discover>
  if (result != ERR_OK) {
  8043e0:	84 c0                	test   %al,%al
  8043e2:	74 0c                	je     8043f0 <dhcp_start+0xe7>
    /* free resources allocated above */
    dhcp_stop(netif);
  8043e4:	89 34 24             	mov    %esi,(%esp)
  8043e7:	e8 9e fe ff ff       	call   80428a <dhcp_stop>
    return ERR_MEM;
  8043ec:	b0 ff                	mov    $0xff,%al
  8043ee:	eb 08                	jmp    8043f8 <dhcp_start+0xef>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8043f0:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
  8043f4:	eb 02                	jmp    8043f8 <dhcp_start+0xef>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8043f6:	b0 ff                	mov    $0xff,%al
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  8043f8:	83 c4 10             	add    $0x10,%esp
  8043fb:	5b                   	pop    %ebx
  8043fc:	5e                   	pop    %esi
  8043fd:	5d                   	pop    %ebp
  8043fe:	c3                   	ret    
	...

00804400 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  804400:	55                   	push   %ebp
  804401:	89 e5                	mov    %esp,%ebp
  804403:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  804406:	b8 23 53 81 00       	mov    $0x815323,%eax
  80440b:	83 e0 fc             	and    $0xfffffffc,%eax
  80440e:	a3 3c 53 a3 00       	mov    %eax,0xa3533c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804413:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  804419:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  804420:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  804424:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  80442a:	89 15 40 53 a3 00    	mov    %edx,0xa35340
  ram_end->used = 1;
  804430:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  804437:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  80443e:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  804441:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  804448:	00 22 00 

  mem_sem = sys_sem_new(1);
  80444b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  804452:	e8 80 60 00 00       	call   80a4d7 <sys_sem_new>
  804457:	a3 44 53 a3 00       	mov    %eax,0xa35344

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80445c:	a1 3c 53 a3 00       	mov    0xa3533c,%eax
  804461:	a3 48 53 a3 00       	mov    %eax,0xa35348

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804466:	c9                   	leave  
  804467:	c3                   	ret    

00804468 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  804468:	55                   	push   %ebp
  804469:	89 e5                	mov    %esp,%ebp
  80446b:	56                   	push   %esi
  80446c:	53                   	push   %ebx
  80446d:	83 ec 10             	sub    $0x10,%esp
  804470:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  804473:	85 db                	test   %ebx,%ebx
  804475:	0f 84 75 01 00 00    	je     8045f0 <mem_free+0x188>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80447b:	f6 c3 03             	test   $0x3,%bl
  80447e:	74 1c                	je     80449c <mem_free+0x34>
  804480:	c7 44 24 08 90 12 81 	movl   $0x811290,0x8(%esp)
  804487:	00 
  804488:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80448f:	00 
  804490:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  804497:	e8 dc a9 00 00       	call   80ee78 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80449c:	3b 1d 3c 53 a3 00    	cmp    0xa3533c,%ebx
  8044a2:	72 08                	jb     8044ac <mem_free+0x44>
  8044a4:	3b 1d 40 53 a3 00    	cmp    0xa35340,%ebx
  8044aa:	72 1c                	jb     8044c8 <mem_free+0x60>
  8044ac:	c7 44 24 08 9b 13 81 	movl   $0x81139b,0x8(%esp)
  8044b3:	00 
  8044b4:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8044bb:	00 
  8044bc:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  8044c3:	e8 b0 a9 00 00       	call   80ee78 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8044c8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8044cf:	00 
  8044d0:	a1 44 53 a3 00       	mov    0xa35344,%eax
  8044d5:	89 04 24             	mov    %eax,(%esp)
  8044d8:	e8 6c 63 00 00       	call   80a849 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8044dd:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  8044e1:	75 1c                	jne    8044ff <mem_free+0x97>
  8044e3:	c7 44 24 08 b2 13 81 	movl   $0x8113b2,0x8(%esp)
  8044ea:	00 
  8044eb:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8044f2:	00 
  8044f3:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  8044fa:	e8 79 a9 00 00       	call   80ee78 <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8044ff:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  804502:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804506:	3b 05 48 53 a3 00    	cmp    0xa35348,%eax
  80450c:	73 05                	jae    804513 <mem_free+0xab>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80450e:	a3 48 53 a3 00       	mov    %eax,0xa35348
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804513:	8b 0d 3c 53 a3 00    	mov    0xa3533c,%ecx
  804519:	39 c8                	cmp    %ecx,%eax
  80451b:	73 1c                	jae    804539 <mem_free+0xd1>
  80451d:	c7 44 24 08 c6 13 81 	movl   $0x8113c6,0x8(%esp)
  804524:	00 
  804525:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80452c:	00 
  80452d:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  804534:	e8 3f a9 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804539:	8b 35 40 53 a3 00    	mov    0xa35340,%esi
  80453f:	39 f0                	cmp    %esi,%eax
  804541:	72 1c                	jb     80455f <mem_free+0xf7>
  804543:	c7 44 24 08 dd 13 81 	movl   $0x8113dd,0x8(%esp)
  80454a:	00 
  80454b:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  804552:	00 
  804553:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  80455a:	e8 19 a9 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80455f:	8b 53 f4             	mov    -0xc(%ebx),%edx
  804562:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804568:	76 1c                	jbe    804586 <mem_free+0x11e>
  80456a:	c7 44 24 08 b4 12 81 	movl   $0x8112b4,0x8(%esp)
  804571:	00 
  804572:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  804579:	00 
  80457a:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  804581:	e8 f2 a8 00 00       	call   80ee78 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804586:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804588:	39 d0                	cmp    %edx,%eax
  80458a:	74 26                	je     8045b2 <mem_free+0x14a>
  80458c:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804590:	75 20                	jne    8045b2 <mem_free+0x14a>
  804592:	39 d6                	cmp    %edx,%esi
  804594:	74 1c                	je     8045b2 <mem_free+0x14a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804596:	3b 15 48 53 a3 00    	cmp    0xa35348,%edx
  80459c:	75 05                	jne    8045a3 <mem_free+0x13b>
      lfree = mem;
  80459e:	a3 48 53 a3 00       	mov    %eax,0xa35348
    }
    mem->next = nmem->next;
  8045a3:	8b 32                	mov    (%edx),%esi
  8045a5:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8045a8:	8b 12                	mov    (%edx),%edx
  8045aa:	89 c6                	mov    %eax,%esi
  8045ac:	29 ce                	sub    %ecx,%esi
  8045ae:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8045b2:	8b 0d 3c 53 a3 00    	mov    0xa3533c,%ecx
  8045b8:	89 ca                	mov    %ecx,%edx
  8045ba:	03 53 f8             	add    -0x8(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8045bd:	39 d0                	cmp    %edx,%eax
  8045bf:	74 22                	je     8045e3 <mem_free+0x17b>
  8045c1:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8045c5:	75 1c                	jne    8045e3 <mem_free+0x17b>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8045c7:	3b 05 48 53 a3 00    	cmp    0xa35348,%eax
  8045cd:	75 06                	jne    8045d5 <mem_free+0x16d>
      lfree = pmem;
  8045cf:	89 15 48 53 a3 00    	mov    %edx,0xa35348
    }
    pmem->next = mem->next;
  8045d5:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8045d8:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8045da:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8045dd:	29 ca                	sub    %ecx,%edx
  8045df:	89 54 01 04          	mov    %edx,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8045e3:	a1 44 53 a3 00       	mov    0xa35344,%eax
  8045e8:	89 04 24             	mov    %eax,(%esp)
  8045eb:	e8 f5 61 00 00       	call   80a7e5 <sys_sem_signal>
}
  8045f0:	83 c4 10             	add    $0x10,%esp
  8045f3:	5b                   	pop    %ebx
  8045f4:	5e                   	pop    %esi
  8045f5:	5d                   	pop    %ebp
  8045f6:	c3                   	ret    

008045f7 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8045f7:	55                   	push   %ebp
  8045f8:	89 e5                	mov    %esp,%ebp
  8045fa:	57                   	push   %edi
  8045fb:	56                   	push   %esi
  8045fc:	53                   	push   %ebx
  8045fd:	83 ec 2c             	sub    $0x2c,%esp
  804600:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804603:	8b 75 0c             	mov    0xc(%ebp),%esi
  804606:	83 c6 03             	add    $0x3,%esi
  804609:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  80460c:	83 fe 0b             	cmp    $0xb,%esi
  80460f:	76 0d                	jbe    80461e <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804611:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804617:	76 0a                	jbe    804623 <mem_realloc+0x2c>
  804619:	e9 0f 01 00 00       	jmp    80472d <mem_realloc+0x136>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80461e:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804623:	a1 3c 53 a3 00       	mov    0xa3533c,%eax
  804628:	39 d8                	cmp    %ebx,%eax
  80462a:	77 08                	ja     804634 <mem_realloc+0x3d>
  80462c:	3b 1d 40 53 a3 00    	cmp    0xa35340,%ebx
  804632:	72 1c                	jb     804650 <mem_realloc+0x59>
  804634:	c7 44 24 08 f7 13 81 	movl   $0x8113f7,0x8(%esp)
  80463b:	00 
  80463c:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  804643:	00 
  804644:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  80464b:	e8 28 a8 00 00       	call   80ee78 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804650:	8d 7b f4             	lea    -0xc(%ebx),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804653:	29 c7                	sub    %eax,%edi

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804655:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804658:	83 e8 0c             	sub    $0xc,%eax
  80465b:	29 f8                	sub    %edi,%eax
  80465d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804660:	39 f0                	cmp    %esi,%eax
  804662:	73 1c                	jae    804680 <mem_realloc+0x89>
  804664:	c7 44 24 08 e0 12 81 	movl   $0x8112e0,0x8(%esp)
  80466b:	00 
  80466c:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  804673:	00 
  804674:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  80467b:	e8 f8 a7 00 00       	call   80ee78 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804680:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  804683:	0f 84 a9 00 00 00    	je     804732 <mem_realloc+0x13b>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804689:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804690:	00 
  804691:	a1 44 53 a3 00       	mov    0xa35344,%eax
  804696:	89 04 24             	mov    %eax,(%esp)
  804699:	e8 ab 61 00 00       	call   80a849 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80469e:	a1 3c 53 a3 00       	mov    0xa3533c,%eax
  8046a3:	89 c2                	mov    %eax,%edx
  8046a5:	03 53 f4             	add    -0xc(%ebx),%edx
  if(mem2->used == 0) {
  8046a8:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8046ac:	75 36                	jne    8046e4 <mem_realloc+0xed>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8046ae:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8046b0:	8d 74 3e 0c          	lea    0xc(%esi,%edi,1),%esi
    if (lfree == mem2) {
  8046b4:	39 15 48 53 a3 00    	cmp    %edx,0xa35348
  8046ba:	75 09                	jne    8046c5 <mem_realloc+0xce>
      lfree = (struct mem *)&ram[ptr2];
  8046bc:	8d 14 30             	lea    (%eax,%esi,1),%edx
  8046bf:	89 15 48 53 a3 00    	mov    %edx,0xa35348
    }
    mem2 = (struct mem *)&ram[ptr2];
  8046c5:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  8046c8:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8046cc:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8046ce:	89 7a 04             	mov    %edi,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8046d1:	89 73 f4             	mov    %esi,-0xc(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8046d4:	8b 12                	mov    (%edx),%edx
  8046d6:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8046dc:	74 40                	je     80471e <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8046de:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  8046e2:	eb 3a                	jmp    80471e <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8046e4:	8d 56 18             	lea    0x18(%esi),%edx
  8046e7:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8046ea:	72 32                	jb     80471e <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8046ec:	8d 4c 3e 0c          	lea    0xc(%esi,%edi,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8046f0:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8046f3:	3b 15 48 53 a3 00    	cmp    0xa35348,%edx
  8046f9:	73 06                	jae    804701 <mem_realloc+0x10a>
      lfree = mem2;
  8046fb:	89 15 48 53 a3 00    	mov    %edx,0xa35348
    }
    mem2->used = 0;
  804701:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  804705:	8b 73 f4             	mov    -0xc(%ebx),%esi
  804708:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  80470a:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  80470d:	89 4b f4             	mov    %ecx,-0xc(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804710:	8b 12                	mov    (%edx),%edx
  804712:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804718:	74 04                	je     80471e <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80471a:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80471e:	a1 44 53 a3 00       	mov    0xa35344,%eax
  804723:	89 04 24             	mov    %eax,(%esp)
  804726:	e8 ba 60 00 00       	call   80a7e5 <sys_sem_signal>
  return rmem;
  80472b:	eb 05                	jmp    804732 <mem_realloc+0x13b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  80472d:	bb 00 00 00 00       	mov    $0x0,%ebx
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  804732:	89 d8                	mov    %ebx,%eax
  804734:	83 c4 2c             	add    $0x2c,%esp
  804737:	5b                   	pop    %ebx
  804738:	5e                   	pop    %esi
  804739:	5f                   	pop    %edi
  80473a:	5d                   	pop    %ebp
  80473b:	c3                   	ret    

0080473c <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80473c:	55                   	push   %ebp
  80473d:	89 e5                	mov    %esp,%ebp
  80473f:	57                   	push   %edi
  804740:	56                   	push   %esi
  804741:	53                   	push   %ebx
  804742:	83 ec 2c             	sub    $0x2c,%esp
  804745:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804748:	85 f6                	test   %esi,%esi
  80474a:	0f 84 93 01 00 00    	je     8048e3 <mem_malloc+0x1a7>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804750:	83 c6 03             	add    $0x3,%esi
  804753:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804756:	83 fe 0b             	cmp    $0xb,%esi
  804759:	76 0d                	jbe    804768 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80475b:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804761:	76 0a                	jbe    80476d <mem_malloc+0x31>
  804763:	e9 82 01 00 00       	jmp    8048ea <mem_malloc+0x1ae>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  804768:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80476d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804774:	00 
  804775:	a1 44 53 a3 00       	mov    0xa35344,%eax
  80477a:	89 04 24             	mov    %eax,(%esp)
  80477d:	e8 c7 60 00 00       	call   80a849 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804782:	8b 15 3c 53 a3 00    	mov    0xa3533c,%edx
  804788:	a1 48 53 a3 00       	mov    0xa35348,%eax
  80478d:	29 d0                	sub    %edx,%eax
  80478f:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804794:	29 f1                	sub    %esi,%ecx
  804796:	e9 2c 01 00 00       	jmp    8048c7 <mem_malloc+0x18b>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80479b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80479e:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8047a2:	0f 85 1d 01 00 00    	jne    8048c5 <mem_malloc+0x189>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  8047a8:	8b 3b                	mov    (%ebx),%edi
  8047aa:	83 ef 0c             	sub    $0xc,%edi
  8047ad:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8047af:	39 f7                	cmp    %esi,%edi
  8047b1:	0f 82 0e 01 00 00    	jb     8048c5 <mem_malloc+0x189>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8047b7:	8d 4e 18             	lea    0x18(%esi),%ecx
  8047ba:	39 f9                	cmp    %edi,%ecx
  8047bc:	77 2f                	ja     8047ed <mem_malloc+0xb1>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8047be:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
  8047c2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8047c5:	01 d1                	add    %edx,%ecx
          mem2->used = 0;
  8047c7:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  8047cb:	8b 3b                	mov    (%ebx),%edi
  8047cd:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8047cf:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8047d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8047d5:	89 03                	mov    %eax,(%ebx)
          mem->used = 1;
  8047d7:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8047db:	8b 01                	mov    (%ecx),%eax
  8047dd:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8047e2:	74 0d                	je     8047f1 <mem_malloc+0xb5>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8047e4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8047e7:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  8047eb:	eb 04                	jmp    8047f1 <mem_malloc+0xb5>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8047ed:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8047f1:	3b 1d 48 53 a3 00    	cmp    0xa35348,%ebx
  8047f7:	75 53                	jne    80484c <mem_malloc+0x110>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8047f9:	8b 0d 40 53 a3 00    	mov    0xa35340,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8047ff:	8b 3d 3c 53 a3 00    	mov    0xa3533c,%edi
  804805:	89 d8                	mov    %ebx,%eax
  804807:	eb 04                	jmp    80480d <mem_malloc+0xd1>
  804809:	8b 00                	mov    (%eax),%eax
  80480b:	01 f8                	add    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80480d:	8a 50 08             	mov    0x8(%eax),%dl
  804810:	84 d2                	test   %dl,%dl
  804812:	74 0b                	je     80481f <mem_malloc+0xe3>
  804814:	39 c1                	cmp    %eax,%ecx
  804816:	75 f1                	jne    804809 <mem_malloc+0xcd>
  804818:	a3 48 53 a3 00       	mov    %eax,0xa35348
  80481d:	eb 2d                	jmp    80484c <mem_malloc+0x110>
  80481f:	a3 48 53 a3 00       	mov    %eax,0xa35348
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  804824:	3b 05 40 53 a3 00    	cmp    0xa35340,%eax
  80482a:	74 20                	je     80484c <mem_malloc+0x110>
  80482c:	84 d2                	test   %dl,%dl
  80482e:	74 1c                	je     80484c <mem_malloc+0x110>
  804830:	c7 44 24 08 11 14 81 	movl   $0x811411,0x8(%esp)
  804837:	00 
  804838:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  80483f:	00 
  804840:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  804847:	e8 2c a6 00 00       	call   80ee78 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80484c:	a1 44 53 a3 00       	mov    0xa35344,%eax
  804851:	89 04 24             	mov    %eax,(%esp)
  804854:	e8 8c 5f 00 00       	call   80a7e5 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804859:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  80485d:	39 05 40 53 a3 00    	cmp    %eax,0xa35340
  804863:	73 1c                	jae    804881 <mem_malloc+0x145>
  804865:	c7 44 24 08 04 13 81 	movl   $0x811304,0x8(%esp)
  80486c:	00 
  80486d:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  804874:	00 
  804875:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  80487c:	e8 f7 a5 00 00       	call   80ee78 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804881:	8d 43 0c             	lea    0xc(%ebx),%eax
  804884:	a8 03                	test   $0x3,%al
  804886:	74 1c                	je     8048a4 <mem_malloc+0x168>
  804888:	c7 44 24 08 34 13 81 	movl   $0x811334,0x8(%esp)
  80488f:	00 
  804890:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  804897:	00 
  804898:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  80489f:	e8 d4 a5 00 00       	call   80ee78 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8048a4:	f6 c3 03             	test   $0x3,%bl
  8048a7:	74 46                	je     8048ef <mem_malloc+0x1b3>
  8048a9:	c7 44 24 08 64 13 81 	movl   $0x811364,0x8(%esp)
  8048b0:	00 
  8048b1:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  8048b8:	00 
  8048b9:	c7 04 24 87 13 81 00 	movl   $0x811387,(%esp)
  8048c0:	e8 b3 a5 00 00       	call   80ee78 <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  8048c5:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8048c7:	39 c8                	cmp    %ecx,%eax
  8048c9:	0f 82 cc fe ff ff    	jb     80479b <mem_malloc+0x5f>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8048cf:	a1 44 53 a3 00       	mov    0xa35344,%eax
  8048d4:	89 04 24             	mov    %eax,(%esp)
  8048d7:	e8 09 5f 00 00       	call   80a7e5 <sys_sem_signal>
  return NULL;
  8048dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8048e1:	eb 0c                	jmp    8048ef <mem_malloc+0x1b3>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8048e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8048e8:	eb 05                	jmp    8048ef <mem_malloc+0x1b3>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  8048ea:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  8048ef:	83 c4 2c             	add    $0x2c,%esp
  8048f2:	5b                   	pop    %ebx
  8048f3:	5e                   	pop    %esi
  8048f4:	5f                   	pop    %edi
  8048f5:	5d                   	pop    %ebp
  8048f6:	c3                   	ret    

008048f7 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8048f7:	55                   	push   %ebp
  8048f8:	89 e5                	mov    %esp,%ebp
  8048fa:	56                   	push   %esi
  8048fb:	53                   	push   %ebx
  8048fc:	83 ec 10             	sub    $0x10,%esp
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8048ff:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  804902:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  804906:	89 1c 24             	mov    %ebx,(%esp)
  804909:	e8 2e fe ff ff       	call   80473c <mem_malloc>
  80490e:	89 c6                	mov    %eax,%esi
  if (p) {
  804910:	85 c0                	test   %eax,%eax
  804912:	74 14                	je     804928 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  804914:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804918:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80491f:	00 
  804920:	89 04 24             	mov    %eax,(%esp)
  804923:	e8 22 ad 00 00       	call   80f64a <memset>
  }
  return p;
}
  804928:	89 f0                	mov    %esi,%eax
  80492a:	83 c4 10             	add    $0x10,%esp
  80492d:	5b                   	pop    %ebx
  80492e:	5e                   	pop    %esi
  80492f:	5d                   	pop    %ebp
  804930:	c3                   	ret    
  804931:	00 00                	add    %al,(%eax)
	...

00804934 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804934:	55                   	push   %ebp
  804935:	89 e5                	mov    %esp,%ebp
  804937:	56                   	push   %esi
  804938:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804939:	b8 63 53 a3 00       	mov    $0xa35363,%eax
  80493e:	83 e0 fc             	and    $0xfffffffc,%eax
  804941:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  804946:	c7 84 12 e0 43 b3 00 	movl   $0x0,0xb343e0(%edx,%edx,1)
  80494d:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804951:	66 8b b2 bc 14 81 00 	mov    0x8114bc(%edx),%si
  804958:	b9 00 00 00 00       	mov    $0x0,%ecx
  80495d:	eb 1a                	jmp    804979 <memp_init+0x45>
      memp->next = memp_tab[i];
  80495f:	8b 9c 12 e0 43 b3 00 	mov    0xb343e0(%edx,%edx,1),%ebx
  804966:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804968:	89 84 12 e0 43 b3 00 	mov    %eax,0xb343e0(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80496f:	0f b7 9a a0 14 81 00 	movzwl 0x8114a0(%edx),%ebx
  804976:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804978:	41                   	inc    %ecx
  804979:	66 39 f1             	cmp    %si,%cx
  80497c:	75 e1                	jne    80495f <memp_init+0x2b>
  80497e:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804981:	83 fa 1c             	cmp    $0x1c,%edx
  804984:	75 c0                	jne    804946 <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804986:	5b                   	pop    %ebx
  804987:	5e                   	pop    %esi
  804988:	5d                   	pop    %ebp
  804989:	c3                   	ret    

0080498a <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80498a:	55                   	push   %ebp
  80498b:	89 e5                	mov    %esp,%ebp
  80498d:	83 ec 18             	sub    $0x18,%esp
  804990:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804993:	83 fa 0d             	cmp    $0xd,%edx
  804996:	76 1c                	jbe    8049b4 <memp_malloc+0x2a>
  804998:	c7 44 24 08 2a 14 81 	movl   $0x81142a,0x8(%esp)
  80499f:	00 
  8049a0:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  8049a7:	00 
  8049a8:	c7 04 24 47 14 81 00 	movl   $0x811447,(%esp)
  8049af:	e8 c4 a4 00 00       	call   80ee78 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8049b4:	8b 04 95 e0 43 b3 00 	mov    0xb343e0(,%edx,4),%eax
  
  if (memp != NULL) {    
  8049bb:	85 c0                	test   %eax,%eax
  8049bd:	74 29                	je     8049e8 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  8049bf:	8b 08                	mov    (%eax),%ecx
  8049c1:	89 0c 95 e0 43 b3 00 	mov    %ecx,0xb343e0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8049c8:	a8 03                	test   $0x3,%al
  8049ca:	74 1c                	je     8049e8 <memp_malloc+0x5e>
  8049cc:	c7 44 24 08 5c 14 81 	movl   $0x81145c,0x8(%esp)
  8049d3:	00 
  8049d4:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  8049db:	00 
  8049dc:	c7 04 24 47 14 81 00 	movl   $0x811447,(%esp)
  8049e3:	e8 90 a4 00 00       	call   80ee78 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8049e8:	c9                   	leave  
  8049e9:	c3                   	ret    

008049ea <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8049ea:	55                   	push   %ebp
  8049eb:	89 e5                	mov    %esp,%ebp
  8049ed:	83 ec 18             	sub    $0x18,%esp
  8049f0:	8b 55 08             	mov    0x8(%ebp),%edx
  8049f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8049f6:	85 c0                	test   %eax,%eax
  8049f8:	74 30                	je     804a2a <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8049fa:	a8 03                	test   $0x3,%al
  8049fc:	74 1c                	je     804a1a <memp_free+0x30>
  8049fe:	c7 44 24 08 80 14 81 	movl   $0x811480,0x8(%esp)
  804a05:	00 
  804a06:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  804a0d:	00 
  804a0e:	c7 04 24 47 14 81 00 	movl   $0x811447,(%esp)
  804a15:	e8 5e a4 00 00       	call   80ee78 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804a1a:	8b 0c 95 e0 43 b3 00 	mov    0xb343e0(,%edx,4),%ecx
  804a21:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804a23:	89 04 95 e0 43 b3 00 	mov    %eax,0xb343e0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804a2a:	c9                   	leave  
  804a2b:	c3                   	ret    

00804a2c <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804a2c:	55                   	push   %ebp
  804a2d:	89 e5                	mov    %esp,%ebp
  804a2f:	53                   	push   %ebx
  804a30:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804a33:	85 c9                	test   %ecx,%ecx
  804a35:	74 29                	je     804a60 <netif_find+0x34>
    return NULL;
  }

  num = name[2] - '0';
  804a37:	8a 51 02             	mov    0x2(%ecx),%dl
  804a3a:	83 ea 30             	sub    $0x30,%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804a3d:	a1 74 b2 b3 00       	mov    0xb3b274,%eax
  804a42:	eb 16                	jmp    804a5a <netif_find+0x2e>
    if (num == netif->num &&
  804a44:	38 50 31             	cmp    %dl,0x31(%eax)
  804a47:	75 0f                	jne    804a58 <netif_find+0x2c>
  804a49:	8a 58 2f             	mov    0x2f(%eax),%bl
  804a4c:	38 19                	cmp    %bl,(%ecx)
  804a4e:	75 08                	jne    804a58 <netif_find+0x2c>
       name[0] == netif->name[0] &&
  804a50:	8a 58 30             	mov    0x30(%eax),%bl
  804a53:	38 59 01             	cmp    %bl,0x1(%ecx)
  804a56:	74 0d                	je     804a65 <netif_find+0x39>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804a58:	8b 00                	mov    (%eax),%eax
  804a5a:	85 c0                	test   %eax,%eax
  804a5c:	75 e6                	jne    804a44 <netif_find+0x18>
  804a5e:	eb 05                	jmp    804a65 <netif_find+0x39>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804a60:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804a65:	5b                   	pop    %ebx
  804a66:	5d                   	pop    %ebp
  804a67:	c3                   	ret    

00804a68 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804a68:	55                   	push   %ebp
  804a69:	89 e5                	mov    %esp,%ebp
  804a6b:	57                   	push   %edi
  804a6c:	56                   	push   %esi
  804a6d:	53                   	push   %ebx
  804a6e:	83 ec 1c             	sub    $0x1c,%esp
  804a71:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804a74:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804a77:	8b 43 04             	mov    0x4(%ebx),%eax
  804a7a:	39 06                	cmp    %eax,(%esi)
  804a7c:	74 50                	je     804ace <netif_set_ipaddr+0x66>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804a7e:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
    while (pcb != NULL) {
  804a83:	eb 19                	jmp    804a9e <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804a85:	8b 53 04             	mov    0x4(%ebx),%edx
  804a88:	39 10                	cmp    %edx,(%eax)
  804a8a:	75 0f                	jne    804a9b <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804a8c:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804a8f:	89 04 24             	mov    %eax,(%esp)
  804a92:	e8 ef 14 00 00       	call   805f86 <tcp_abort>
        pcb = next;
  804a97:	89 f8                	mov    %edi,%eax
  804a99:	eb 03                	jmp    804a9e <netif_set_ipaddr+0x36>
      } else {
        pcb = pcb->next;
  804a9b:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804a9e:	85 c0                	test   %eax,%eax
  804aa0:	75 e3                	jne    804a85 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804aa2:	a1 84 b2 b3 00       	mov    0xb3b284,%eax
  804aa7:	eb 21                	jmp    804aca <netif_set_ipaddr+0x62>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804aa9:	85 c0                	test   %eax,%eax
  804aab:	74 1a                	je     804ac7 <netif_set_ipaddr+0x5f>
  804aad:	8b 10                	mov    (%eax),%edx
  804aaf:	85 d2                	test   %edx,%edx
  804ab1:	74 14                	je     804ac7 <netif_set_ipaddr+0x5f>
  804ab3:	3b 53 04             	cmp    0x4(%ebx),%edx
  804ab6:	75 0f                	jne    804ac7 <netif_set_ipaddr+0x5f>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804ab8:	85 f6                	test   %esi,%esi
  804aba:	74 04                	je     804ac0 <netif_set_ipaddr+0x58>
  804abc:	8b 16                	mov    (%esi),%edx
  804abe:	eb 05                	jmp    804ac5 <netif_set_ipaddr+0x5d>
  804ac0:	ba 00 00 00 00       	mov    $0x0,%edx
  804ac5:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804ac7:	8b 40 0c             	mov    0xc(%eax),%eax
  804aca:	85 c0                	test   %eax,%eax
  804acc:	75 db                	jne    804aa9 <netif_set_ipaddr+0x41>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804ace:	85 f6                	test   %esi,%esi
  804ad0:	74 04                	je     804ad6 <netif_set_ipaddr+0x6e>
  804ad2:	8b 06                	mov    (%esi),%eax
  804ad4:	eb 05                	jmp    804adb <netif_set_ipaddr+0x73>
  804ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  804adb:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804ade:	83 c4 1c             	add    $0x1c,%esp
  804ae1:	5b                   	pop    %ebx
  804ae2:	5e                   	pop    %esi
  804ae3:	5f                   	pop    %edi
  804ae4:	5d                   	pop    %ebp
  804ae5:	c3                   	ret    

00804ae6 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804ae6:	55                   	push   %ebp
  804ae7:	89 e5                	mov    %esp,%ebp
  804ae9:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804aec:	85 c0                	test   %eax,%eax
  804aee:	74 04                	je     804af4 <netif_set_gw+0xe>
  804af0:	8b 10                	mov    (%eax),%edx
  804af2:	eb 05                	jmp    804af9 <netif_set_gw+0x13>
  804af4:	ba 00 00 00 00       	mov    $0x0,%edx
  804af9:	8b 45 08             	mov    0x8(%ebp),%eax
  804afc:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804aff:	5d                   	pop    %ebp
  804b00:	c3                   	ret    

00804b01 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804b01:	55                   	push   %ebp
  804b02:	89 e5                	mov    %esp,%ebp
  804b04:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804b07:	85 c0                	test   %eax,%eax
  804b09:	74 04                	je     804b0f <netif_set_netmask+0xe>
  804b0b:	8b 10                	mov    (%eax),%edx
  804b0d:	eb 05                	jmp    804b14 <netif_set_netmask+0x13>
  804b0f:	ba 00 00 00 00       	mov    $0x0,%edx
  804b14:	8b 45 08             	mov    0x8(%ebp),%eax
  804b17:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804b1a:	5d                   	pop    %ebp
  804b1b:	c3                   	ret    

00804b1c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804b1c:	55                   	push   %ebp
  804b1d:	89 e5                	mov    %esp,%ebp
  804b1f:	53                   	push   %ebx
  804b20:	83 ec 14             	sub    $0x14,%esp
  804b23:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  804b26:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b29:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b2d:	89 1c 24             	mov    %ebx,(%esp)
  804b30:	e8 33 ff ff ff       	call   804a68 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  804b35:	8b 45 10             	mov    0x10(%ebp),%eax
  804b38:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b3c:	89 1c 24             	mov    %ebx,(%esp)
  804b3f:	e8 bd ff ff ff       	call   804b01 <netif_set_netmask>
  netif_set_gw(netif, gw);
  804b44:	8b 45 14             	mov    0x14(%ebp),%eax
  804b47:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b4b:	89 1c 24             	mov    %ebx,(%esp)
  804b4e:	e8 93 ff ff ff       	call   804ae6 <netif_set_gw>
}
  804b53:	83 c4 14             	add    $0x14,%esp
  804b56:	5b                   	pop    %ebx
  804b57:	5d                   	pop    %ebp
  804b58:	c3                   	ret    

00804b59 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804b59:	55                   	push   %ebp
  804b5a:	89 e5                	mov    %esp,%ebp
  804b5c:	53                   	push   %ebx
  804b5d:	83 ec 14             	sub    $0x14,%esp
  804b60:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804b63:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804b6a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804b71:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804b78:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804b7c:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804b83:	8b 45 18             	mov    0x18(%ebp),%eax
  804b86:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804b89:	a0 18 44 b3 00       	mov    0xb34418,%al
  804b8e:	88 43 31             	mov    %al,0x31(%ebx)
  804b91:	40                   	inc    %eax
  804b92:	a2 18 44 b3 00       	mov    %al,0xb34418
  netif->input = input;
  804b97:	8b 45 20             	mov    0x20(%ebp),%eax
  804b9a:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804b9d:	8b 45 14             	mov    0x14(%ebp),%eax
  804ba0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804ba4:	8b 45 10             	mov    0x10(%ebp),%eax
  804ba7:	89 44 24 08          	mov    %eax,0x8(%esp)
  804bab:	8b 45 0c             	mov    0xc(%ebp),%eax
  804bae:	89 44 24 04          	mov    %eax,0x4(%esp)
  804bb2:	89 1c 24             	mov    %ebx,(%esp)
  804bb5:	e8 62 ff ff ff       	call   804b1c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804bba:	89 1c 24             	mov    %ebx,(%esp)
  804bbd:	ff 55 1c             	call   *0x1c(%ebp)
  804bc0:	84 c0                	test   %al,%al
  804bc2:	75 0f                	jne    804bd3 <netif_add+0x7a>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804bc4:	a1 74 b2 b3 00       	mov    0xb3b274,%eax
  804bc9:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804bcb:	89 1d 74 b2 b3 00    	mov    %ebx,0xb3b274
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804bd1:	eb 05                	jmp    804bd8 <netif_add+0x7f>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  804bd3:	bb 00 00 00 00       	mov    $0x0,%ebx
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804bd8:	89 d8                	mov    %ebx,%eax
  804bda:	83 c4 14             	add    $0x14,%esp
  804bdd:	5b                   	pop    %ebx
  804bde:	5d                   	pop    %ebp
  804bdf:	c3                   	ret    

00804be0 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804be0:	55                   	push   %ebp
  804be1:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804be3:	8b 45 08             	mov    0x8(%ebp),%eax
  804be6:	a3 78 b2 b3 00       	mov    %eax,0xb3b278
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804beb:	5d                   	pop    %ebp
  804bec:	c3                   	ret    

00804bed <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804bed:	55                   	push   %ebp
  804bee:	89 e5                	mov    %esp,%ebp
  804bf0:	83 ec 04             	sub    $0x4,%esp
  804bf3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804bf6:	85 c9                	test   %ecx,%ecx
  804bf8:	74 3a                	je     804c34 <netif_remove+0x47>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804bfa:	a1 74 b2 b3 00       	mov    0xb3b274,%eax
  804bff:	39 c8                	cmp    %ecx,%eax
  804c01:	75 17                	jne    804c1a <netif_remove+0x2d>
    netif_list = netif->next;
  804c03:	8b 00                	mov    (%eax),%eax
  804c05:	a3 74 b2 b3 00       	mov    %eax,0xb3b274
  804c0a:	eb 14                	jmp    804c20 <netif_remove+0x33>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804c0c:	8b 10                	mov    (%eax),%edx
  804c0e:	39 ca                	cmp    %ecx,%edx
  804c10:	75 06                	jne    804c18 <netif_remove+0x2b>
        tmpNetif->next = netif->next;
  804c12:	8b 11                	mov    (%ecx),%edx
  804c14:	89 10                	mov    %edx,(%eax)
  804c16:	eb 08                	jmp    804c20 <netif_remove+0x33>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804c18:	89 d0                	mov    %edx,%eax
  804c1a:	85 c0                	test   %eax,%eax
  804c1c:	75 ee                	jne    804c0c <netif_remove+0x1f>
  804c1e:	eb 14                	jmp    804c34 <netif_remove+0x47>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804c20:	39 0d 78 b2 b3 00    	cmp    %ecx,0xb3b278
  804c26:	75 0c                	jne    804c34 <netif_remove+0x47>
    /* reset default netif */
    netif_set_default(NULL);
  804c28:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804c2f:	e8 ac ff ff ff       	call   804be0 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804c34:	c9                   	leave  
  804c35:	c3                   	ret    

00804c36 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804c36:	55                   	push   %ebp
  804c37:	89 e5                	mov    %esp,%ebp
  804c39:	83 ec 18             	sub    $0x18,%esp
  804c3c:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804c3f:	8a 50 2e             	mov    0x2e(%eax),%dl
  804c42:	f6 c2 01             	test   $0x1,%dl
  804c45:	75 22                	jne    804c69 <netif_set_up+0x33>
    netif->flags |= NETIF_FLAG_UP;
  804c47:	83 ca 01             	or     $0x1,%edx
  804c4a:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804c4d:	f6 c2 20             	test   $0x20,%dl
  804c50:	74 17                	je     804c69 <netif_set_up+0x33>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804c52:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c59:	00 
  804c5a:	8d 50 04             	lea    0x4(%eax),%edx
  804c5d:	89 54 24 04          	mov    %edx,0x4(%esp)
  804c61:	89 04 24             	mov    %eax,(%esp)
  804c64:	e8 66 53 00 00       	call   809fcf <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804c69:	c9                   	leave  
  804c6a:	c3                   	ret    

00804c6b <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804c6b:	55                   	push   %ebp
  804c6c:	89 e5                	mov    %esp,%ebp
  804c6e:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804c71:	8a 50 2e             	mov    0x2e(%eax),%dl
  804c74:	f6 c2 01             	test   $0x1,%dl
  804c77:	74 06                	je     804c7f <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804c79:	83 e2 fe             	and    $0xfffffffe,%edx
  804c7c:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804c7f:	5d                   	pop    %ebp
  804c80:	c3                   	ret    

00804c81 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804c81:	55                   	push   %ebp
  804c82:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804c84:	8b 45 08             	mov    0x8(%ebp),%eax
  804c87:	8a 40 2e             	mov    0x2e(%eax),%al
  804c8a:	83 e0 01             	and    $0x1,%eax
}
  804c8d:	5d                   	pop    %ebp
  804c8e:	c3                   	ret    
	...

00804c90 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804c90:	55                   	push   %ebp
  804c91:	89 e5                	mov    %esp,%ebp
  804c93:	56                   	push   %esi
  804c94:	53                   	push   %ebx
  804c95:	83 ec 10             	sub    $0x10,%esp
  804c98:	8b 45 08             	mov    0x8(%ebp),%eax
  804c9b:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804c9e:	85 c0                	test   %eax,%eax
  804ca0:	75 1c                	jne    804cbe <pbuf_header+0x2e>
  804ca2:	c7 44 24 08 52 15 81 	movl   $0x811552,0x8(%esp)
  804ca9:	00 
  804caa:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804cb1:	00 
  804cb2:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804cb9:	e8 ba a1 00 00       	call   80ee78 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804cbe:	66 85 d2             	test   %dx,%dx
  804cc1:	0f 84 9d 00 00 00    	je     804d64 <pbuf_header+0xd4>
    return 0;
 
  if (header_size_increment < 0){
  804cc7:	66 85 d2             	test   %dx,%dx
  804cca:	79 26                	jns    804cf2 <pbuf_header+0x62>
    increment_magnitude = -header_size_increment;
  804ccc:	89 d6                	mov    %edx,%esi
  804cce:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804cd0:	66 3b 70 0a          	cmp    0xa(%eax),%si
  804cd4:	76 1e                	jbe    804cf4 <pbuf_header+0x64>
  804cd6:	c7 44 24 08 ed 14 81 	movl   $0x8114ed,0x8(%esp)
  804cdd:	00 
  804cde:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804ce5:	00 
  804ce6:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804ced:	e8 86 a1 00 00       	call   80ee78 <_panic>
  } else {
    increment_magnitude = header_size_increment;
  804cf2:	89 d6                	mov    %edx,%esi
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804cf4:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  804cf8:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804cfb:	66 85 c9             	test   %cx,%cx
  804cfe:	74 06                	je     804d06 <pbuf_header+0x76>
  804d00:	66 83 f9 03          	cmp    $0x3,%cx
  804d04:	75 1a                	jne    804d20 <pbuf_header+0x90>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804d06:	0f bf ca             	movswl %dx,%ecx
  804d09:	89 de                	mov    %ebx,%esi
  804d0b:	29 ce                	sub    %ecx,%esi
  804d0d:	89 f1                	mov    %esi,%ecx
  804d0f:	89 70 04             	mov    %esi,0x4(%eax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804d12:	8d 70 10             	lea    0x10(%eax),%esi
  804d15:	39 f1                	cmp    %esi,%ecx
  804d17:	73 3f                	jae    804d58 <pbuf_header+0xc8>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  804d19:	89 58 04             	mov    %ebx,0x4(%eax)
      /* bail out unsuccesfully */
      return 1;
  804d1c:	b0 01                	mov    $0x1,%al
  804d1e:	eb 4e                	jmp    804d6e <pbuf_header+0xde>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804d20:	49                   	dec    %ecx
  804d21:	66 83 f9 01          	cmp    $0x1,%cx
  804d25:	77 15                	ja     804d3c <pbuf_header+0xac>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804d27:	66 85 d2             	test   %dx,%dx
  804d2a:	79 3c                	jns    804d68 <pbuf_header+0xd8>
  804d2c:	66 3b 70 0a          	cmp    0xa(%eax),%si
  804d30:	77 3a                	ja     804d6c <pbuf_header+0xdc>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804d32:	0f bf ca             	movswl %dx,%ecx
  804d35:	29 cb                	sub    %ecx,%ebx
  804d37:	89 58 04             	mov    %ebx,0x4(%eax)
  804d3a:	eb 1c                	jmp    804d58 <pbuf_header+0xc8>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804d3c:	c7 44 24 08 0b 15 81 	movl   $0x81150b,0x8(%esp)
  804d43:	00 
  804d44:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804d4b:	00 
  804d4c:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804d53:	e8 20 a1 00 00       	call   80ee78 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804d58:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  804d5c:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804d60:	b0 00                	mov    $0x0,%al
  804d62:	eb 0a                	jmp    804d6e <pbuf_header+0xde>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804d64:	b0 00                	mov    $0x0,%al
  804d66:	eb 06                	jmp    804d6e <pbuf_header+0xde>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804d68:	b0 01                	mov    $0x1,%al
  804d6a:	eb 02                	jmp    804d6e <pbuf_header+0xde>
  804d6c:	b0 01                	mov    $0x1,%al

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804d6e:	83 c4 10             	add    $0x10,%esp
  804d71:	5b                   	pop    %ebx
  804d72:	5e                   	pop    %esi
  804d73:	5d                   	pop    %ebp
  804d74:	c3                   	ret    

00804d75 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804d75:	55                   	push   %ebp
  804d76:	89 e5                	mov    %esp,%ebp
  804d78:	56                   	push   %esi
  804d79:	53                   	push   %ebx
  804d7a:	83 ec 10             	sub    $0x10,%esp
  804d7d:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804d80:	85 d2                	test   %edx,%edx
  804d82:	75 1c                	jne    804da0 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  804d84:	c7 44 24 08 52 15 81 	movl   $0x811552,0x8(%esp)
  804d8b:	00 
  804d8c:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  804d93:	00 
  804d94:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804d9b:	e8 d8 a0 00 00       	call   80ee78 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804da0:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804da4:	76 1c                	jbe    804dc2 <pbuf_free+0x4d>
  804da6:	c7 44 24 08 19 15 81 	movl   $0x811519,0x8(%esp)
  804dad:	00 
  804dae:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  804db5:	00 
  804db6:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804dbd:	e8 b6 a0 00 00       	call   80ee78 <_panic>
  804dc2:	be 00 00 00 00       	mov    $0x0,%esi
  804dc7:	eb 02                	jmp    804dcb <pbuf_free+0x56>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804dc9:	89 da                	mov    %ebx,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804dcb:	66 8b 42 0e          	mov    0xe(%edx),%ax
  804dcf:	66 85 c0             	test   %ax,%ax
  804dd2:	75 1c                	jne    804df0 <pbuf_free+0x7b>
  804dd4:	c7 44 24 08 2e 15 81 	movl   $0x81152e,0x8(%esp)
  804ddb:	00 
  804ddc:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  804de3:	00 
  804de4:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804deb:	e8 88 a0 00 00       	call   80ee78 <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804df0:	48                   	dec    %eax
  804df1:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804df5:	66 85 c0             	test   %ax,%ax
  804df8:	75 44                	jne    804e3e <pbuf_free+0xc9>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804dfa:	8b 1a                	mov    (%edx),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804dfc:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  804e00:	66 83 f8 03          	cmp    $0x3,%ax
  804e04:	75 12                	jne    804e18 <pbuf_free+0xa3>
        memp_free(MEMP_PBUF_POOL, p);
  804e06:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e0a:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804e11:	e8 d4 fb ff ff       	call   8049ea <memp_free>
  804e16:	eb 21                	jmp    804e39 <pbuf_free+0xc4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804e18:	48                   	dec    %eax
  804e19:	66 83 f8 01          	cmp    $0x1,%ax
  804e1d:	77 12                	ja     804e31 <pbuf_free+0xbc>
        memp_free(MEMP_PBUF, p);
  804e1f:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e23:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  804e2a:	e8 bb fb ff ff       	call   8049ea <memp_free>
  804e2f:	eb 08                	jmp    804e39 <pbuf_free+0xc4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804e31:	89 14 24             	mov    %edx,(%esp)
  804e34:	e8 2f f6 ff ff       	call   804468 <mem_free>
      }
      count++;
  804e39:	46                   	inc    %esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804e3a:	85 db                	test   %ebx,%ebx
  804e3c:	75 8b                	jne    804dc9 <pbuf_free+0x54>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804e3e:	89 f0                	mov    %esi,%eax
  804e40:	83 c4 10             	add    $0x10,%esp
  804e43:	5b                   	pop    %ebx
  804e44:	5e                   	pop    %esi
  804e45:	5d                   	pop    %ebp
  804e46:	c3                   	ret    

00804e47 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804e47:	55                   	push   %ebp
  804e48:	89 e5                	mov    %esp,%ebp
  804e4a:	56                   	push   %esi
  804e4b:	53                   	push   %ebx
  804e4c:	83 ec 10             	sub    $0x10,%esp
  804e4f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804e52:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804e55:	85 db                	test   %ebx,%ebx
  804e57:	75 1c                	jne    804e75 <pbuf_realloc+0x2e>
  804e59:	c7 44 24 08 44 15 81 	movl   $0x811544,0x8(%esp)
  804e60:	00 
  804e61:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  804e68:	00 
  804e69:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804e70:	e8 03 a0 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804e75:	8a 43 0c             	mov    0xc(%ebx),%al
  804e78:	3c 03                	cmp    $0x3,%al
  804e7a:	74 28                	je     804ea4 <pbuf_realloc+0x5d>
  804e7c:	3c 01                	cmp    $0x1,%al
  804e7e:	74 24                	je     804ea4 <pbuf_realloc+0x5d>
  804e80:	84 c0                	test   %al,%al
  804e82:	74 20                	je     804ea4 <pbuf_realloc+0x5d>
  804e84:	3c 02                	cmp    $0x2,%al
  804e86:	74 1c                	je     804ea4 <pbuf_realloc+0x5d>
  804e88:	c7 44 24 08 5c 15 81 	movl   $0x81155c,0x8(%esp)
  804e8f:	00 
  804e90:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  804e97:	00 
  804e98:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804e9f:	e8 d4 9f 00 00       	call   80ee78 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804ea4:	8b 43 08             	mov    0x8(%ebx),%eax
  804ea7:	66 39 f0             	cmp    %si,%ax
  804eaa:	0f 86 bf 00 00 00    	jbe    804f6f <pbuf_realloc+0x128>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804eb0:	0f b7 d6             	movzwl %si,%edx
  804eb3:	0f b7 c0             	movzwl %ax,%eax
  804eb6:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804eb8:	eb 4d                	jmp    804f07 <pbuf_realloc+0xc0>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804eba:	66 29 c6             	sub    %ax,%si
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804ebd:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  804ec3:	7e 1c                	jle    804ee1 <pbuf_realloc+0x9a>
  804ec5:	c7 44 24 08 77 15 81 	movl   $0x811577,0x8(%esp)
  804ecc:	00 
  804ecd:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  804ed4:	00 
  804ed5:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804edc:	e8 97 9f 00 00       	call   80ee78 <_panic>
    q->tot_len += (u16_t)grow;
  804ee1:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804ee5:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804ee7:	85 db                	test   %ebx,%ebx
  804ee9:	75 1c                	jne    804f07 <pbuf_realloc+0xc0>
  804eeb:	c7 44 24 08 88 15 81 	movl   $0x811588,0x8(%esp)
  804ef2:	00 
  804ef3:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  804efa:	00 
  804efb:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804f02:	e8 71 9f 00 00       	call   80ee78 <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804f07:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  804f0b:	66 39 c6             	cmp    %ax,%si
  804f0e:	77 aa                	ja     804eba <pbuf_realloc+0x73>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804f10:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804f14:	75 3d                	jne    804f53 <pbuf_realloc+0x10c>
  804f16:	66 39 f0             	cmp    %si,%ax
  804f19:	74 38                	je     804f53 <pbuf_realloc+0x10c>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804f1b:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804f1e:	29 d9                	sub    %ebx,%ecx
  804f20:	0f b7 c6             	movzwl %si,%eax
  804f23:	01 c8                	add    %ecx,%eax
  804f25:	89 44 24 04          	mov    %eax,0x4(%esp)
  804f29:	89 1c 24             	mov    %ebx,(%esp)
  804f2c:	e8 c6 f6 ff ff       	call   8045f7 <mem_realloc>
  804f31:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804f33:	85 c0                	test   %eax,%eax
  804f35:	75 1c                	jne    804f53 <pbuf_realloc+0x10c>
  804f37:	c7 44 24 08 a0 15 81 	movl   $0x8115a0,0x8(%esp)
  804f3e:	00 
  804f3f:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  804f46:	00 
  804f47:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804f4e:	e8 25 9f 00 00       	call   80ee78 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804f53:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804f57:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804f5b:	8b 03                	mov    (%ebx),%eax
  804f5d:	85 c0                	test   %eax,%eax
  804f5f:	74 08                	je     804f69 <pbuf_realloc+0x122>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804f61:	89 04 24             	mov    %eax,(%esp)
  804f64:	e8 0c fe ff ff       	call   804d75 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  804f69:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804f6f:	83 c4 10             	add    $0x10,%esp
  804f72:	5b                   	pop    %ebx
  804f73:	5e                   	pop    %esi
  804f74:	5d                   	pop    %ebp
  804f75:	c3                   	ret    

00804f76 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  804f76:	55                   	push   %ebp
  804f77:	89 e5                	mov    %esp,%ebp
  804f79:	57                   	push   %edi
  804f7a:	56                   	push   %esi
  804f7b:	53                   	push   %ebx
  804f7c:	83 ec 2c             	sub    $0x2c,%esp
  804f7f:	8b 45 08             	mov    0x8(%ebp),%eax
  804f82:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  804f85:	83 f8 01             	cmp    $0x1,%eax
  804f88:	74 11                	je     804f9b <pbuf_alloc+0x25>
  804f8a:	83 f8 01             	cmp    $0x1,%eax
  804f8d:	72 13                	jb     804fa2 <pbuf_alloc+0x2c>
  804f8f:	83 f8 02             	cmp    $0x2,%eax
  804f92:	74 18                	je     804fac <pbuf_alloc+0x36>
  804f94:	83 f8 03             	cmp    $0x3,%eax
  804f97:	75 1d                	jne    804fb6 <pbuf_alloc+0x40>
  804f99:	eb 37                	jmp    804fd2 <pbuf_alloc+0x5c>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f9b:	bf 00 00 00 00       	mov    $0x0,%edi
  804fa0:	eb 05                	jmp    804fa7 <pbuf_alloc+0x31>
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804fa2:	bf 14 00 00 00       	mov    $0x14,%edi
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804fa7:	83 c7 14             	add    $0x14,%edi
  804faa:	eb 05                	jmp    804fb1 <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804fac:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804fb1:	83 c7 0e             	add    $0xe,%edi
    break;
  804fb4:	eb 21                	jmp    804fd7 <pbuf_alloc+0x61>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804fb6:	c7 44 24 08 bb 15 81 	movl   $0x8115bb,0x8(%esp)
  804fbd:	00 
  804fbe:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  804fc5:	00 
  804fc6:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  804fcd:	e8 a6 9e 00 00       	call   80ee78 <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804fd2:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804fd7:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804fdb:	77 0f                	ja     804fec <pbuf_alloc+0x76>
  804fdd:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804fe1:	0f 83 b6 01 00 00    	jae    80519d <pbuf_alloc+0x227>
  804fe7:	e9 71 01 00 00       	jmp    80515d <pbuf_alloc+0x1e7>
  804fec:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804ff0:	0f 85 d6 01 00 00    	jne    8051cc <pbuf_alloc+0x256>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804ff6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804ffd:	e8 88 f9 ff ff       	call   80498a <memp_malloc>
  805002:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  805004:	85 c0                	test   %eax,%eax
  805006:	0f 84 e6 01 00 00    	je     8051f2 <pbuf_alloc+0x27c>
      return NULL;
    }
    p->type = type;
  80500c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  805010:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  805016:	0f b7 ff             	movzwl %di,%edi
  805019:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  80501d:	83 e2 fc             	and    $0xfffffffc,%edx
  805020:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  805023:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  805027:	0f b7 db             	movzwl %bx,%ebx
  80502a:	83 c7 03             	add    $0x3,%edi
  80502d:	83 e7 fc             	and    $0xfffffffc,%edi
  805030:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  805035:	29 f9                	sub    %edi,%ecx
  805037:	89 c8                	mov    %ecx,%eax
  805039:	39 d9                	cmp    %ebx,%ecx
  80503b:	7e 02                	jle    80503f <pbuf_alloc+0xc9>
  80503d:	89 d8                	mov    %ebx,%eax
  80503f:	89 c1                	mov    %eax,%ecx
  805041:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  805045:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  80504b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80504e:	0f b7 c1             	movzwl %cx,%eax
  805051:	01 c2                	add    %eax,%edx
  805053:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805056:	73 1c                	jae    805074 <pbuf_alloc+0xfe>
  805058:	c7 44 24 08 5c 16 81 	movl   $0x81165c,0x8(%esp)
  80505f:	00 
  805060:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  805067:	00 
  805068:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80506f:	e8 04 9e 00 00       	call   80ee78 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  805074:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80507a:	0f b7 c9             	movzwl %cx,%ecx
  80507d:	29 cb                	sub    %ecx,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80507f:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  805081:	e9 ca 00 00 00       	jmp    805150 <pbuf_alloc+0x1da>
      q = memp_malloc(MEMP_PBUF_POOL);
  805086:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  80508d:	e8 f8 f8 ff ff       	call   80498a <memp_malloc>
      if (q == NULL) {
  805092:	85 c0                	test   %eax,%eax
  805094:	75 12                	jne    8050a8 <pbuf_alloc+0x132>
        /* free chain so far allocated */
        pbuf_free(p);
  805096:	89 34 24             	mov    %esi,(%esp)
  805099:	e8 d7 fc ff ff       	call   804d75 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  80509e:	be 00 00 00 00       	mov    $0x0,%esi
  8050a3:	e9 4a 01 00 00       	jmp    8051f2 <pbuf_alloc+0x27c>
      }
      q->type = type;
  8050a8:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  8050ac:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  8050b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  8050b6:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  8050b8:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  8050be:	7e 1c                	jle    8050dc <pbuf_alloc+0x166>
  8050c0:	c7 44 24 08 d6 15 81 	movl   $0x8115d6,0x8(%esp)
  8050c7:	00 
  8050c8:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  8050cf:	00 
  8050d0:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8050d7:	e8 9c 9d 00 00       	call   80ee78 <_panic>
      q->tot_len = (u16_t)rem_len;
  8050dc:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  8050e0:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  8050e5:	77 04                	ja     8050eb <pbuf_alloc+0x175>
  8050e7:	89 d9                	mov    %ebx,%ecx
  8050e9:	eb 05                	jmp    8050f0 <pbuf_alloc+0x17a>
  8050eb:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  8050f0:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  8050f4:	8d 50 10             	lea    0x10(%eax),%edx
  8050f7:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8050fa:	f6 c2 03             	test   $0x3,%dl
  8050fd:	74 1c                	je     80511b <pbuf_alloc+0x1a5>
  8050ff:	c7 44 24 08 90 16 81 	movl   $0x811690,0x8(%esp)
  805106:	00 
  805107:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80510e:	00 
  80510f:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  805116:	e8 5d 9d 00 00       	call   80ee78 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80511b:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80511f:	03 56 04             	add    0x4(%esi),%edx
  805122:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805125:	73 1c                	jae    805143 <pbuf_alloc+0x1cd>
  805127:	c7 44 24 08 5c 16 81 	movl   $0x81165c,0x8(%esp)
  80512e:	00 
  80512f:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  805136:	00 
  805137:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80513e:	e8 35 9d 00 00       	call   80ee78 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  805143:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  805149:	0f b7 c9             	movzwl %cx,%ecx
  80514c:	29 cb                	sub    %ecx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80514e:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  805150:	85 db                	test   %ebx,%ebx
  805152:	0f 8f 2e ff ff ff    	jg     805086 <pbuf_alloc+0x110>
  805158:	e9 8b 00 00 00       	jmp    8051e8 <pbuf_alloc+0x272>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80515d:	0f b7 ff             	movzwl %di,%edi
  805160:	8d 57 13             	lea    0x13(%edi),%edx
  805163:	83 e2 fc             	and    $0xfffffffc,%edx
  805166:	0f b7 c3             	movzwl %bx,%eax
  805169:	83 c0 03             	add    $0x3,%eax
  80516c:	83 e0 fc             	and    $0xfffffffc,%eax
  80516f:	01 d0                	add    %edx,%eax
  805171:	89 04 24             	mov    %eax,(%esp)
  805174:	e8 c3 f5 ff ff       	call   80473c <mem_malloc>
  805179:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80517b:	85 c0                	test   %eax,%eax
  80517d:	74 73                	je     8051f2 <pbuf_alloc+0x27c>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80517f:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  805183:	83 e0 fc             	and    $0xfffffffc,%eax
  805186:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  805189:	66 89 5e 08          	mov    %bx,0x8(%esi)
  80518d:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  805191:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  805197:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80519b:	eb 4b                	jmp    8051e8 <pbuf_alloc+0x272>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80519d:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8051a4:	e8 e1 f7 ff ff       	call   80498a <memp_malloc>
  8051a9:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8051ab:	85 c0                	test   %eax,%eax
  8051ad:	74 43                	je     8051f2 <pbuf_alloc+0x27c>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  8051af:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  8051b6:	66 89 58 08          	mov    %bx,0x8(%eax)
  8051ba:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  8051be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  8051c4:	8a 55 10             	mov    0x10(%ebp),%dl
  8051c7:	88 50 0c             	mov    %dl,0xc(%eax)
    break;
  8051ca:	eb 1c                	jmp    8051e8 <pbuf_alloc+0x272>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  8051cc:	c7 44 24 08 ea 15 81 	movl   $0x8115ea,0x8(%esp)
  8051d3:	00 
  8051d4:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  8051db:	00 
  8051dc:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8051e3:	e8 90 9c 00 00       	call   80ee78 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  8051e8:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  8051ee:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  8051f2:	89 f0                	mov    %esi,%eax
  8051f4:	83 c4 2c             	add    $0x2c,%esp
  8051f7:	5b                   	pop    %ebx
  8051f8:	5e                   	pop    %esi
  8051f9:	5f                   	pop    %edi
  8051fa:	5d                   	pop    %ebp
  8051fb:	c3                   	ret    

008051fc <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  8051fc:	55                   	push   %ebp
  8051fd:	89 e5                	mov    %esp,%ebp
  8051ff:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  805202:	b0 00                	mov    $0x0,%al
  while (p != NULL) {
  805204:	eb 03                	jmp    805209 <pbuf_clen+0xd>
    ++len;
  805206:	40                   	inc    %eax
    p = p->next;
  805207:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  805209:	85 d2                	test   %edx,%edx
  80520b:	75 f9                	jne    805206 <pbuf_clen+0xa>
    ++len;
    p = p->next;
  }
  return len;
}
  80520d:	5d                   	pop    %ebp
  80520e:	c3                   	ret    

0080520f <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80520f:	55                   	push   %ebp
  805210:	89 e5                	mov    %esp,%ebp
  805212:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  805215:	85 c0                	test   %eax,%eax
  805217:	74 04                	je     80521d <pbuf_ref+0xe>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  805219:	66 ff 40 0e          	incw   0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80521d:	5d                   	pop    %ebp
  80521e:	c3                   	ret    

0080521f <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80521f:	55                   	push   %ebp
  805220:	89 e5                	mov    %esp,%ebp
  805222:	53                   	push   %ebx
  805223:	83 ec 14             	sub    $0x14,%esp
  805226:	8b 45 08             	mov    0x8(%ebp),%eax
  805229:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80522c:	85 c0                	test   %eax,%eax
  80522e:	74 04                	je     805234 <pbuf_cat+0x15>
  805230:	85 db                	test   %ebx,%ebx
  805232:	75 25                	jne    805259 <pbuf_cat+0x3a>
  805234:	c7 44 24 08 c0 16 81 	movl   $0x8116c0,0x8(%esp)
  80523b:	00 
  80523c:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  805243:	00 
  805244:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80524b:	e8 28 9c 00 00       	call   80ee78 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  805250:	8b 4b 08             	mov    0x8(%ebx),%ecx
  805253:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  805257:	89 d0                	mov    %edx,%eax
  805259:	8b 10                	mov    (%eax),%edx
  80525b:	85 d2                	test   %edx,%edx
  80525d:	75 f1                	jne    805250 <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80525f:	8b 50 08             	mov    0x8(%eax),%edx
  805262:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  805266:	74 1c                	je     805284 <pbuf_cat+0x65>
  805268:	c7 44 24 08 f8 16 81 	movl   $0x8116f8,0x8(%esp)
  80526f:	00 
  805270:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  805277:	00 
  805278:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80527f:	e8 f4 9b 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  805284:	03 53 08             	add    0x8(%ebx),%edx
  805287:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80528b:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80528d:	83 c4 14             	add    $0x14,%esp
  805290:	5b                   	pop    %ebx
  805291:	5d                   	pop    %ebp
  805292:	c3                   	ret    

00805293 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  805293:	55                   	push   %ebp
  805294:	89 e5                	mov    %esp,%ebp
  805296:	53                   	push   %ebx
  805297:	83 ec 14             	sub    $0x14,%esp
  80529a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  80529d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8052a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8052a4:	89 04 24             	mov    %eax,(%esp)
  8052a7:	e8 73 ff ff ff       	call   80521f <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  8052ac:	89 1c 24             	mov    %ebx,(%esp)
  8052af:	e8 5b ff ff ff       	call   80520f <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  8052b4:	83 c4 14             	add    $0x14,%esp
  8052b7:	5b                   	pop    %ebx
  8052b8:	5d                   	pop    %ebp
  8052b9:	c3                   	ret    

008052ba <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  8052ba:	55                   	push   %ebp
  8052bb:	89 e5                	mov    %esp,%ebp
  8052bd:	57                   	push   %edi
  8052be:	56                   	push   %esi
  8052bf:	53                   	push   %ebx
  8052c0:	83 ec 2c             	sub    $0x2c,%esp
  8052c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  8052c6:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  8052c8:	85 f6                	test   %esi,%esi
  8052ca:	74 56                	je     805322 <pbuf_dechain+0x68>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  8052cc:	8b 53 08             	mov    0x8(%ebx),%edx
  8052cf:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  8052d3:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8052d7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8052da:	0f b7 fa             	movzwl %dx,%edi
  8052dd:	0f b7 c8             	movzwl %ax,%ecx
  8052e0:	29 cf                	sub    %ecx,%edi
  8052e2:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  8052e5:	74 1c                	je     805303 <pbuf_dechain+0x49>
  8052e7:	c7 44 24 08 28 17 81 	movl   $0x811728,0x8(%esp)
  8052ee:	00 
  8052ef:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  8052f6:	00 
  8052f7:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8052fe:	e8 75 9b 00 00       	call   80ee78 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  805303:	66 29 c2             	sub    %ax,%dx
  805306:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80530a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  805310:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  805314:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  805318:	89 34 24             	mov    %esi,(%esp)
  80531b:	e8 55 fa ff ff       	call   804d75 <pbuf_free>
  805320:	eb 02                	jmp    805324 <pbuf_dechain+0x6a>
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  struct pbuf *q;
  u8_t tail_gone = 1;
  805322:	b0 01                	mov    $0x1,%al
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  805324:	66 8b 53 0a          	mov    0xa(%ebx),%dx
  805328:	66 39 53 08          	cmp    %dx,0x8(%ebx)
  80532c:	74 1c                	je     80534a <pbuf_dechain+0x90>
  80532e:	c7 44 24 08 05 16 81 	movl   $0x811605,0x8(%esp)
  805335:	00 
  805336:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  80533d:	00 
  80533e:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  805345:	e8 2e 9b 00 00       	call   80ee78 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  80534a:	84 c0                	test   %al,%al
  80534c:	74 05                	je     805353 <pbuf_dechain+0x99>
  80534e:	be 00 00 00 00       	mov    $0x0,%esi
}
  805353:	89 f0                	mov    %esi,%eax
  805355:	83 c4 2c             	add    $0x2c,%esp
  805358:	5b                   	pop    %ebx
  805359:	5e                   	pop    %esi
  80535a:	5f                   	pop    %edi
  80535b:	5d                   	pop    %ebp
  80535c:	c3                   	ret    

0080535d <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80535d:	55                   	push   %ebp
  80535e:	89 e5                	mov    %esp,%ebp
  805360:	57                   	push   %edi
  805361:	56                   	push   %esi
  805362:	53                   	push   %ebx
  805363:	83 ec 2c             	sub    $0x2c,%esp
  805366:	8b 7d 0c             	mov    0xc(%ebp),%edi

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805369:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80536d:	74 10                	je     80537f <pbuf_copy+0x22>
  80536f:	85 ff                	test   %edi,%edi
  805371:	74 0c                	je     80537f <pbuf_copy+0x22>
  805373:	8b 57 08             	mov    0x8(%edi),%edx
  805376:	8b 45 08             	mov    0x8(%ebp),%eax
  805379:	66 39 50 08          	cmp    %dx,0x8(%eax)
  80537d:	73 3e                	jae    8053bd <pbuf_copy+0x60>
  80537f:	c7 44 24 08 4c 17 81 	movl   $0x81174c,0x8(%esp)
  805386:	00 
  805387:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  80538e:	00 
  80538f:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  805396:	e8 dd 9a 00 00       	call   80ee78 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80539b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80539f:	75 26                	jne    8053c7 <pbuf_copy+0x6a>
  8053a1:	c7 44 24 08 1a 16 81 	movl   $0x81161a,0x8(%esp)
  8053a8:	00 
  8053a9:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  8053b0:	00 
  8053b1:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8053b8:	e8 bb 9a 00 00       	call   80ee78 <_panic>

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  8053bd:	bb 00 00 00 00       	mov    $0x0,%ebx
  8053c2:	be 00 00 00 00       	mov    $0x0,%esi
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  8053c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8053ca:	66 8b 40 0a          	mov    0xa(%eax),%ax
  8053ce:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  8053d2:	66 8b 4f 0a          	mov    0xa(%edi),%cx
  8053d6:	0f b7 d0             	movzwl %ax,%edx
  8053d9:	0f b7 c6             	movzwl %si,%eax
  8053dc:	29 c2                	sub    %eax,%edx
  8053de:	89 55 e0             	mov    %edx,-0x20(%ebp)
  8053e1:	0f b7 d1             	movzwl %cx,%edx
  8053e4:	0f b7 c3             	movzwl %bx,%eax
  8053e7:	29 c2                	sub    %eax,%edx
  8053e9:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  8053ec:	7c 09                	jl     8053f7 <pbuf_copy+0x9a>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  8053ee:	66 29 d9             	sub    %bx,%cx
  8053f1:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  8053f5:	eb 0b                	jmp    805402 <pbuf_copy+0xa5>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  8053f7:	66 8b 55 e6          	mov    -0x1a(%ebp),%dx
  8053fb:	66 29 f2             	sub    %si,%dx
  8053fe:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  805402:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805406:	89 44 24 08          	mov    %eax,0x8(%esp)
  80540a:	0f b7 c3             	movzwl %bx,%eax
  80540d:	03 47 04             	add    0x4(%edi),%eax
  805410:	89 44 24 04          	mov    %eax,0x4(%esp)
  805414:	0f b7 c6             	movzwl %si,%eax
  805417:	8b 55 08             	mov    0x8(%ebp),%edx
  80541a:	03 42 04             	add    0x4(%edx),%eax
  80541d:	89 04 24             	mov    %eax,(%esp)
  805420:	e8 d9 a2 00 00       	call   80f6fe <memcpy>
    offset_to += len;
  805425:	66 03 75 e6          	add    -0x1a(%ebp),%si
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  805429:	8b 55 08             	mov    0x8(%ebp),%edx
  80542c:	66 8b 42 0a          	mov    0xa(%edx),%ax
  805430:	66 39 c6             	cmp    %ax,%si
  805433:	76 1c                	jbe    805451 <pbuf_copy+0xf4>
  805435:	c7 44 24 08 27 16 81 	movl   $0x811627,0x8(%esp)
  80543c:	00 
  80543d:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  805444:	00 
  805445:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80544c:	e8 27 9a 00 00       	call   80ee78 <_panic>
    if (offset_to == p_to->len) {
  805451:	66 39 c6             	cmp    %ax,%si
  805454:	75 0d                	jne    805463 <pbuf_copy+0x106>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805456:	8b 45 08             	mov    0x8(%ebp),%eax
  805459:	8b 00                	mov    (%eax),%eax
  80545b:	89 45 08             	mov    %eax,0x8(%ebp)
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  80545e:	be 00 00 00 00       	mov    $0x0,%esi
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  805463:	66 03 5d e6          	add    -0x1a(%ebp),%bx
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805467:	66 8b 47 0a          	mov    0xa(%edi),%ax
  80546b:	66 39 c3             	cmp    %ax,%bx
  80546e:	76 1c                	jbe    80548c <pbuf_copy+0x12f>
  805470:	c7 44 24 08 3e 16 81 	movl   $0x81163e,0x8(%esp)
  805477:	00 
  805478:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  80547f:	00 
  805480:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  805487:	e8 ec 99 00 00       	call   80ee78 <_panic>
    if (offset_from >= p_from->len) {
  80548c:	66 39 c3             	cmp    %ax,%bx
  80548f:	72 07                	jb     805498 <pbuf_copy+0x13b>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  805491:	8b 3f                	mov    (%edi),%edi
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805493:	bb 00 00 00 00       	mov    $0x0,%ebx
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805498:	85 ff                	test   %edi,%edi
  80549a:	74 2a                	je     8054c6 <pbuf_copy+0x169>
  80549c:	8b 57 08             	mov    0x8(%edi),%edx
  80549f:	66 39 57 0a          	cmp    %dx,0xa(%edi)
  8054a3:	75 21                	jne    8054c6 <pbuf_copy+0x169>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8054a5:	83 3f 00             	cmpl   $0x0,(%edi)
  8054a8:	74 1c                	je     8054c6 <pbuf_copy+0x169>
  8054aa:	c7 44 24 08 7c 17 81 	movl   $0x81177c,0x8(%esp)
  8054b1:	00 
  8054b2:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  8054b9:	00 
  8054ba:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8054c1:	e8 b2 99 00 00       	call   80ee78 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  8054c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8054ca:	74 2d                	je     8054f9 <pbuf_copy+0x19c>
  8054cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8054cf:	8b 50 08             	mov    0x8(%eax),%edx
  8054d2:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8054d6:	75 21                	jne    8054f9 <pbuf_copy+0x19c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8054d8:	83 38 00             	cmpl   $0x0,(%eax)
  8054db:	74 1c                	je     8054f9 <pbuf_copy+0x19c>
  8054dd:	c7 44 24 08 7c 17 81 	movl   $0x81177c,0x8(%esp)
  8054e4:	00 
  8054e5:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  8054ec:	00 
  8054ed:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  8054f4:	e8 7f 99 00 00       	call   80ee78 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  8054f9:	85 ff                	test   %edi,%edi
  8054fb:	0f 85 9a fe ff ff    	jne    80539b <pbuf_copy+0x3e>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805501:	b0 00                	mov    $0x0,%al
  805503:	83 c4 2c             	add    $0x2c,%esp
  805506:	5b                   	pop    %ebx
  805507:	5e                   	pop    %esi
  805508:	5f                   	pop    %edi
  805509:	5d                   	pop    %ebp
  80550a:	c3                   	ret    

0080550b <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80550b:	55                   	push   %ebp
  80550c:	89 e5                	mov    %esp,%ebp
  80550e:	57                   	push   %edi
  80550f:	56                   	push   %esi
  805510:	53                   	push   %ebx
  805511:	83 ec 2c             	sub    $0x2c,%esp
  805514:	8b 7d 08             	mov    0x8(%ebp),%edi
  805517:	8b 75 10             	mov    0x10(%ebp),%esi
  80551a:	8b 45 14             	mov    0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80551d:	85 ff                	test   %edi,%edi
  80551f:	75 1c                	jne    80553d <pbuf_copy_partial+0x32>
  805521:	c7 44 24 08 a8 17 81 	movl   $0x8117a8,0x8(%esp)
  805528:	00 
  805529:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  805530:	00 
  805531:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  805538:	e8 3b 99 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80553d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  805541:	75 73                	jne    8055b6 <pbuf_copy_partial+0xab>
  805543:	c7 44 24 08 cc 17 81 	movl   $0x8117cc,0x8(%esp)
  80554a:	00 
  80554b:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  805552:	00 
  805553:	c7 04 24 d8 14 81 00 	movl   $0x8114d8,(%esp)
  80555a:	e8 19 99 00 00       	call   80ee78 <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80555f:	66 85 c0             	test   %ax,%ax
  805562:	74 0e                	je     805572 <pbuf_copy_partial+0x67>
  805564:	66 8b 57 0a          	mov    0xa(%edi),%dx
  805568:	66 39 d0             	cmp    %dx,%ax
  80556b:	72 05                	jb     805572 <pbuf_copy_partial+0x67>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80556d:	66 29 d0             	sub    %dx,%ax
  805570:	eb 40                	jmp    8055b2 <pbuf_copy_partial+0xa7>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805572:	66 8b 57 0a          	mov    0xa(%edi),%dx
  805576:	66 29 c2             	sub    %ax,%dx
  805579:	89 d3                	mov    %edx,%ebx
  80557b:	66 39 f2             	cmp    %si,%dx
  80557e:	76 02                	jbe    805582 <pbuf_copy_partial+0x77>
  805580:	89 f3                	mov    %esi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805582:	0f b7 d3             	movzwl %bx,%edx
  805585:	89 54 24 08          	mov    %edx,0x8(%esp)
  805589:	0f b7 c0             	movzwl %ax,%eax
  80558c:	03 47 04             	add    0x4(%edi),%eax
  80558f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805593:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805597:	03 45 0c             	add    0xc(%ebp),%eax
  80559a:	89 04 24             	mov    %eax,(%esp)
  80559d:	e8 5c a1 00 00       	call   80f6fe <memcpy>
      copied_total += buf_copy_len;
  8055a2:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  8055a6:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  8055aa:	66 29 de             	sub    %bx,%si
      offset = 0;
  8055ad:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8055b2:	8b 3f                	mov    (%edi),%edi
  8055b4:	eb 0c                	jmp    8055c2 <pbuf_copy_partial+0xb7>
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8055b6:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  8055bc:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8055c2:	66 85 f6             	test   %si,%si
  8055c5:	74 04                	je     8055cb <pbuf_copy_partial+0xc0>
  8055c7:	85 ff                	test   %edi,%edi
  8055c9:	75 94                	jne    80555f <pbuf_copy_partial+0x54>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  8055cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8055ce:	83 c4 2c             	add    $0x2c,%esp
  8055d1:	5b                   	pop    %ebx
  8055d2:	5e                   	pop    %esi
  8055d3:	5f                   	pop    %edi
  8055d4:	5d                   	pop    %ebp
  8055d5:	c3                   	ret    
	...

008055d8 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8055d8:	55                   	push   %ebp
  8055d9:	89 e5                	mov    %esp,%ebp
  8055db:	83 ec 18             	sub    $0x18,%esp
  8055de:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8055e1:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8055e6:	8b 40 04             	mov    0x4(%eax),%eax
  8055e9:	8b 00                	mov    (%eax),%eax
  8055eb:	89 04 24             	mov    %eax,(%esp)
  8055ee:	e8 f2 51 00 00       	call   80a7e5 <sys_sem_signal>
}
  8055f3:	c9                   	leave  
  8055f4:	c3                   	ret    

008055f5 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  8055f5:	55                   	push   %ebp
  8055f6:	89 e5                	mov    %esp,%ebp
  8055f8:	57                   	push   %edi
  8055f9:	56                   	push   %esi
  8055fa:	53                   	push   %ebx
  8055fb:	83 ec 1c             	sub    $0x1c,%esp
  8055fe:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  805601:	e8 74 56 00 00       	call   80ac7a <sys_arch_timeouts>
  805606:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805608:	85 c0                	test   %eax,%eax
  80560a:	74 06                	je     805612 <sys_mbox_fetch+0x1d>
  80560c:	8b 00                	mov    (%eax),%eax
  80560e:	85 c0                	test   %eax,%eax
  805610:	75 19                	jne    80562b <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  805612:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805619:	00 
  80561a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80561e:	8b 45 08             	mov    0x8(%ebp),%eax
  805621:	89 04 24             	mov    %eax,(%esp)
  805624:	e8 68 54 00 00       	call   80aa91 <sys_arch_mbox_fetch>
  805629:	eb 5d                	jmp    805688 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80562b:	8b 40 04             	mov    0x4(%eax),%eax
  80562e:	85 c0                	test   %eax,%eax
  805630:	74 18                	je     80564a <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805632:	89 44 24 08          	mov    %eax,0x8(%esp)
  805636:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80563a:	8b 45 08             	mov    0x8(%ebp),%eax
  80563d:	89 04 24             	mov    %eax,(%esp)
  805640:	e8 4c 54 00 00       	call   80aa91 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805645:	83 f8 ff             	cmp    $0xffffffff,%eax
  805648:	75 27                	jne    805671 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80564a:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80564c:	8b 10                	mov    (%eax),%edx
  80564e:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  805650:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805653:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805656:	89 44 24 04          	mov    %eax,0x4(%esp)
  80565a:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805661:	e8 84 f3 ff ff       	call   8049ea <memp_free>
      if (h != NULL) {
  805666:	85 db                	test   %ebx,%ebx
  805668:	74 97                	je     805601 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80566a:	89 34 24             	mov    %esi,(%esp)
  80566d:	ff d3                	call   *%ebx
  80566f:	eb 90                	jmp    805601 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805671:	8b 13                	mov    (%ebx),%edx
  805673:	8b 4a 04             	mov    0x4(%edx),%ecx
  805676:	39 c8                	cmp    %ecx,%eax
  805678:	73 07                	jae    805681 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  80567a:	29 c1                	sub    %eax,%ecx
  80567c:	89 4a 04             	mov    %ecx,0x4(%edx)
  80567f:	eb 07                	jmp    805688 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  805681:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805688:	83 c4 1c             	add    $0x1c,%esp
  80568b:	5b                   	pop    %ebx
  80568c:	5e                   	pop    %esi
  80568d:	5f                   	pop    %edi
  80568e:	5d                   	pop    %ebp
  80568f:	c3                   	ret    

00805690 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  805690:	55                   	push   %ebp
  805691:	89 e5                	mov    %esp,%ebp
  805693:	57                   	push   %edi
  805694:	56                   	push   %esi
  805695:	53                   	push   %ebx
  805696:	83 ec 1c             	sub    $0x1c,%esp
  805699:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80569c:	e8 d9 55 00 00       	call   80ac7a <sys_arch_timeouts>
  8056a1:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8056a3:	85 c0                	test   %eax,%eax
  8056a5:	74 06                	je     8056ad <sys_sem_wait+0x1d>
  8056a7:	8b 00                	mov    (%eax),%eax
  8056a9:	85 c0                	test   %eax,%eax
  8056ab:	75 12                	jne    8056bf <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  8056ad:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8056b4:	00 
  8056b5:	89 3c 24             	mov    %edi,(%esp)
  8056b8:	e8 8c 51 00 00       	call   80a849 <sys_arch_sem_wait>
  8056bd:	eb 56                	jmp    805715 <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  8056bf:	8b 40 04             	mov    0x4(%eax),%eax
  8056c2:	85 c0                	test   %eax,%eax
  8056c4:	74 11                	je     8056d7 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8056c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056ca:	89 3c 24             	mov    %edi,(%esp)
  8056cd:	e8 77 51 00 00       	call   80a849 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8056d2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8056d5:	75 27                	jne    8056fe <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8056d7:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8056d9:	8b 10                	mov    (%eax),%edx
  8056db:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8056dd:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8056e0:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8056e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056e7:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8056ee:	e8 f7 f2 ff ff       	call   8049ea <memp_free>
      if (h != NULL) {
  8056f3:	85 db                	test   %ebx,%ebx
  8056f5:	74 a5                	je     80569c <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8056f7:	89 34 24             	mov    %esi,(%esp)
  8056fa:	ff d3                	call   *%ebx
  8056fc:	eb 9e                	jmp    80569c <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8056fe:	8b 13                	mov    (%ebx),%edx
  805700:	8b 4a 04             	mov    0x4(%edx),%ecx
  805703:	39 c8                	cmp    %ecx,%eax
  805705:	73 07                	jae    80570e <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  805707:	29 c1                	sub    %eax,%ecx
  805709:	89 4a 04             	mov    %ecx,0x4(%edx)
  80570c:	eb 07                	jmp    805715 <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  80570e:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805715:	83 c4 1c             	add    $0x1c,%esp
  805718:	5b                   	pop    %ebx
  805719:	5e                   	pop    %esi
  80571a:	5f                   	pop    %edi
  80571b:	5d                   	pop    %ebp
  80571c:	c3                   	ret    

0080571d <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80571d:	55                   	push   %ebp
  80571e:	89 e5                	mov    %esp,%ebp
  805720:	56                   	push   %esi
  805721:	53                   	push   %ebx
  805722:	83 ec 10             	sub    $0x10,%esp
  805725:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805728:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80572f:	e8 56 f2 ff ff       	call   80498a <memp_malloc>
  805734:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  805736:	85 c0                	test   %eax,%eax
  805738:	75 1c                	jne    805756 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80573a:	c7 44 24 08 f1 17 81 	movl   $0x8117f1,0x8(%esp)
  805741:	00 
  805742:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  805749:	00 
  80574a:	c7 04 24 0e 18 81 00 	movl   $0x81180e,(%esp)
  805751:	e8 22 97 00 00       	call   80ee78 <_panic>
    return;
  }
  timeout->next = NULL;
  805756:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  80575c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80575f:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  805762:	8b 45 10             	mov    0x10(%ebp),%eax
  805765:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805768:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  80576b:	e8 0a 55 00 00       	call   80ac7a <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  805770:	85 c0                	test   %eax,%eax
  805772:	75 1c                	jne    805790 <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805774:	c7 44 24 08 22 18 81 	movl   $0x811822,0x8(%esp)
  80577b:	00 
  80577c:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  805783:	00 
  805784:	c7 04 24 0e 18 81 00 	movl   $0x81180e,(%esp)
  80578b:	e8 e8 96 00 00       	call   80ee78 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  805790:	8b 10                	mov    (%eax),%edx
  805792:	85 d2                	test   %edx,%edx
  805794:	75 04                	jne    80579a <sys_timeout+0x7d>
    timeouts->next = timeout;
  805796:	89 18                	mov    %ebx,(%eax)
    return;
  805798:	eb 39                	jmp    8057d3 <sys_timeout+0xb6>
  }

  if (timeouts->next->time > msecs) {
  80579a:	8b 4a 04             	mov    0x4(%edx),%ecx
  80579d:	39 ce                	cmp    %ecx,%esi
  80579f:	73 0d                	jae    8057ae <sys_timeout+0x91>
    timeouts->next->time -= msecs;
  8057a1:	29 f1                	sub    %esi,%ecx
  8057a3:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  8057a6:	8b 10                	mov    (%eax),%edx
  8057a8:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8057aa:	89 18                	mov    %ebx,(%eax)
  8057ac:	eb 25                	jmp    8057d3 <sys_timeout+0xb6>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8057ae:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8057b1:	2b 4a 04             	sub    0x4(%edx),%ecx
  8057b4:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8057b7:	8b 02                	mov    (%edx),%eax
  8057b9:	85 c0                	test   %eax,%eax
  8057bb:	74 09                	je     8057c6 <sys_timeout+0xa9>
  8057bd:	3b 48 04             	cmp    0x4(%eax),%ecx
  8057c0:	72 0c                	jb     8057ce <sys_timeout+0xb1>
  8057c2:	89 c2                	mov    %eax,%edx
  8057c4:	eb e8                	jmp    8057ae <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  8057c6:	8b 02                	mov    (%edx),%eax
  8057c8:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  8057ca:	89 1a                	mov    %ebx,(%edx)
        break;
  8057cc:	eb 05                	jmp    8057d3 <sys_timeout+0xb6>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  8057ce:	29 48 04             	sub    %ecx,0x4(%eax)
  8057d1:	eb f3                	jmp    8057c6 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  8057d3:	83 c4 10             	add    $0x10,%esp
  8057d6:	5b                   	pop    %ebx
  8057d7:	5e                   	pop    %esi
  8057d8:	5d                   	pop    %ebp
  8057d9:	c3                   	ret    

008057da <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  8057da:	55                   	push   %ebp
  8057db:	89 e5                	mov    %esp,%ebp
  8057dd:	57                   	push   %edi
  8057de:	56                   	push   %esi
  8057df:	53                   	push   %ebx
  8057e0:	83 ec 1c             	sub    $0x1c,%esp
  8057e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8057e6:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  8057e9:	e8 8c 54 00 00       	call   80ac7a <sys_arch_timeouts>

  if (timeouts == NULL) {
  8057ee:	85 c0                	test   %eax,%eax
  8057f0:	75 1c                	jne    80580e <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8057f2:	c7 44 24 08 40 18 81 	movl   $0x811840,0x8(%esp)
  8057f9:	00 
  8057fa:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  805801:	00 
  805802:	c7 04 24 0e 18 81 00 	movl   $0x81180e,(%esp)
  805809:	e8 6a 96 00 00       	call   80ee78 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  80580e:	8b 10                	mov    (%eax),%edx
  805810:	85 d2                	test   %edx,%edx
  805812:	74 47                	je     80585b <sys_untimeout+0x81>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805814:	bf 00 00 00 00       	mov    $0x0,%edi
  805819:	eb 04                	jmp    80581f <sys_untimeout+0x45>
  80581b:	89 d7                	mov    %edx,%edi
  80581d:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80581f:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805822:	75 31                	jne    805855 <sys_untimeout+0x7b>
  805824:	39 72 0c             	cmp    %esi,0xc(%edx)
  805827:	75 2c                	jne    805855 <sys_untimeout+0x7b>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805829:	85 ff                	test   %edi,%edi
  80582b:	75 06                	jne    805833 <sys_untimeout+0x59>
        timeouts->next = t->next;
  80582d:	8b 0a                	mov    (%edx),%ecx
  80582f:	89 08                	mov    %ecx,(%eax)
  805831:	eb 04                	jmp    805837 <sys_untimeout+0x5d>
      else
        prev_t->next = t->next;
  805833:	8b 02                	mov    (%edx),%eax
  805835:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  805837:	8b 02                	mov    (%edx),%eax
  805839:	85 c0                	test   %eax,%eax
  80583b:	74 06                	je     805843 <sys_untimeout+0x69>
        t->next->time += t->time;
  80583d:	8b 4a 04             	mov    0x4(%edx),%ecx
  805840:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805843:	89 54 24 04          	mov    %edx,0x4(%esp)
  805847:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80584e:	e8 97 f1 ff ff       	call   8049ea <memp_free>
      return;
  805853:	eb 06                	jmp    80585b <sys_untimeout+0x81>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805855:	8b 0a                	mov    (%edx),%ecx
  805857:	85 c9                	test   %ecx,%ecx
  805859:	75 c0                	jne    80581b <sys_untimeout+0x41>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80585b:	83 c4 1c             	add    $0x1c,%esp
  80585e:	5b                   	pop    %ebx
  80585f:	5e                   	pop    %esi
  805860:	5f                   	pop    %edi
  805861:	5d                   	pop    %ebp
  805862:	c3                   	ret    

00805863 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805863:	55                   	push   %ebp
  805864:	89 e5                	mov    %esp,%ebp
  805866:	83 ec 28             	sub    $0x28,%esp
  805869:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80586c:	8d 55 08             	lea    0x8(%ebp),%edx
  80586f:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805872:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805878:	85 c0                	test   %eax,%eax
  80587a:	74 17                	je     805893 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80587c:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80587f:	89 54 24 08          	mov    %edx,0x8(%esp)
  805883:	c7 44 24 04 d8 55 80 	movl   $0x8055d8,0x4(%esp)
  80588a:	00 
  80588b:	89 04 24             	mov    %eax,(%esp)
  80588e:	e8 8a fe ff ff       	call   80571d <sys_timeout>
  }
  sys_sem_wait(sem);
  805893:	8b 45 08             	mov    0x8(%ebp),%eax
  805896:	89 04 24             	mov    %eax,(%esp)
  805899:	e8 f2 fd ff ff       	call   805690 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80589e:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8058a3:	75 1a                	jne    8058bf <sys_sem_wait_timeout+0x5c>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8058a5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8058a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8058ac:	c7 04 24 d8 55 80 00 	movl   $0x8055d8,(%esp)
  8058b3:	e8 22 ff ff ff       	call   8057da <sys_untimeout>
    return 1;
  8058b8:	b8 01 00 00 00       	mov    $0x1,%eax
  8058bd:	eb 05                	jmp    8058c4 <sys_sem_wait_timeout+0x61>
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  8058bf:	b8 00 00 00 00       	mov    $0x0,%eax
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8058c4:	c9                   	leave  
  8058c5:	c3                   	ret    

008058c6 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8058c6:	55                   	push   %ebp
  8058c7:	89 e5                	mov    %esp,%ebp
  8058c9:	53                   	push   %ebx
  8058ca:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8058cd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8058d4:	e8 fe 4b 00 00       	call   80a4d7 <sys_sem_new>
  8058d9:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8058db:	8b 45 08             	mov    0x8(%ebp),%eax
  8058de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8058e2:	89 1c 24             	mov    %ebx,(%esp)
  8058e5:	e8 79 ff ff ff       	call   805863 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8058ea:	89 1c 24             	mov    %ebx,(%esp)
  8058ed:	e8 81 4c 00 00       	call   80a573 <sys_sem_free>
}
  8058f2:	83 c4 14             	add    $0x14,%esp
  8058f5:	5b                   	pop    %ebx
  8058f6:	5d                   	pop    %ebp
  8058f7:	c3                   	ret    

008058f8 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  8058f8:	55                   	push   %ebp
  8058f9:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  8058fb:	b0 fb                	mov    $0xfb,%al
  8058fd:	5d                   	pop    %ebp
  8058fe:	c3                   	ret    

008058ff <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8058ff:	55                   	push   %ebp
  805900:	89 e5                	mov    %esp,%ebp
  805902:	56                   	push   %esi
  805903:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805904:	8b 0d 7c b2 b3 00    	mov    0xb3b27c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80590a:	8b 1d 90 b2 b3 00    	mov    0xb3b290,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805910:	8b 35 84 b2 b3 00    	mov    0xb3b284,%esi
  805916:	66 a1 08 40 81 00    	mov    0x814008,%ax
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80591c:	66 40                	inc    %ax
  80591e:	79 05                	jns    805925 <tcp_new_port+0x26>
    port = TCP_LOCAL_PORT_RANGE_START;
  805920:	b8 00 10 00 00       	mov    $0x1000,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805925:	89 ca                	mov    %ecx,%edx
  805927:	eb 09                	jmp    805932 <tcp_new_port+0x33>
    if (pcb->local_port == port) {
  805929:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80592d:	74 ed                	je     80591c <tcp_new_port+0x1d>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80592f:	8b 52 0c             	mov    0xc(%edx),%edx
  805932:	85 d2                	test   %edx,%edx
  805934:	75 f3                	jne    805929 <tcp_new_port+0x2a>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805936:	89 da                	mov    %ebx,%edx
  805938:	eb 09                	jmp    805943 <tcp_new_port+0x44>
    if (pcb->local_port == port) {
  80593a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80593e:	74 dc                	je     80591c <tcp_new_port+0x1d>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805940:	8b 52 0c             	mov    0xc(%edx),%edx
  805943:	85 d2                	test   %edx,%edx
  805945:	75 f3                	jne    80593a <tcp_new_port+0x3b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805947:	89 f2                	mov    %esi,%edx
  805949:	eb 09                	jmp    805954 <tcp_new_port+0x55>
    if (pcb->local_port == port) {
  80594b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80594f:	74 cb                	je     80591c <tcp_new_port+0x1d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805951:	8b 52 0c             	mov    0xc(%edx),%edx
  805954:	85 d2                	test   %edx,%edx
  805956:	75 f3                	jne    80594b <tcp_new_port+0x4c>
  805958:	66 a3 08 40 81 00    	mov    %ax,0x814008
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  80595e:	5b                   	pop    %ebx
  80595f:	5e                   	pop    %esi
  805960:	5d                   	pop    %ebp
  805961:	c3                   	ret    

00805962 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  805962:	55                   	push   %ebp
  805963:	89 e5                	mov    %esp,%ebp
  805965:	57                   	push   %edi
  805966:	56                   	push   %esi
  805967:	53                   	push   %ebx
  805968:	83 ec 1c             	sub    $0x1c,%esp
  80596b:	8b 75 08             	mov    0x8(%ebp),%esi
  80596e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805971:	8b 45 10             	mov    0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805974:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805978:	74 1c                	je     805996 <tcp_bind+0x34>
  80597a:	c7 44 24 08 60 18 81 	movl   $0x811860,0x8(%esp)
  805981:	00 
  805982:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  805989:	00 
  80598a:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  805991:	e8 e2 94 00 00       	call   80ee78 <_panic>

  if (port == 0) {
  805996:	66 85 c0             	test   %ax,%ax
  805999:	75 05                	jne    8059a0 <tcp_bind+0x3e>
    port = tcp_new_port();
  80599b:	e8 5f ff ff ff       	call   8058ff <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8059a0:	8b 15 84 b2 b3 00    	mov    0xb3b284,%edx
  8059a6:	eb 35                	jmp    8059dd <tcp_bind+0x7b>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8059a8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8059ac:	75 2c                	jne    8059da <tcp_bind+0x78>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8059ae:	85 d2                	test   %edx,%edx
  8059b0:	0f 84 f0 00 00 00    	je     805aa6 <tcp_bind+0x144>
  8059b6:	8b 0a                	mov    (%edx),%ecx
  8059b8:	85 c9                	test   %ecx,%ecx
  8059ba:	0f 84 ea 00 00 00    	je     805aaa <tcp_bind+0x148>
  8059c0:	85 db                	test   %ebx,%ebx
  8059c2:	0f 84 e6 00 00 00    	je     805aae <tcp_bind+0x14c>
          ip_addr_isany(ipaddr) ||
  8059c8:	8b 3b                	mov    (%ebx),%edi
  8059ca:	85 ff                	test   %edi,%edi
  8059cc:	0f 84 e0 00 00 00    	je     805ab2 <tcp_bind+0x150>
  8059d2:	39 f9                	cmp    %edi,%ecx
  8059d4:	0f 84 dc 00 00 00    	je     805ab6 <tcp_bind+0x154>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8059da:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8059dd:	85 d2                	test   %edx,%edx
  8059df:	75 c7                	jne    8059a8 <tcp_bind+0x46>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8059e1:	8b 15 7c b2 b3 00    	mov    0xb3b27c,%edx
  8059e7:	eb 35                	jmp    805a1e <tcp_bind+0xbc>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8059e9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8059ed:	75 2c                	jne    805a1b <tcp_bind+0xb9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8059ef:	85 d2                	test   %edx,%edx
  8059f1:	0f 84 c3 00 00 00    	je     805aba <tcp_bind+0x158>
  8059f7:	8b 0a                	mov    (%edx),%ecx
  8059f9:	85 c9                	test   %ecx,%ecx
  8059fb:	0f 84 bd 00 00 00    	je     805abe <tcp_bind+0x15c>
  805a01:	85 db                	test   %ebx,%ebx
  805a03:	0f 84 b9 00 00 00    	je     805ac2 <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  805a09:	8b 3b                	mov    (%ebx),%edi
  805a0b:	85 ff                	test   %edi,%edi
  805a0d:	0f 84 b3 00 00 00    	je     805ac6 <tcp_bind+0x164>
  805a13:	39 f9                	cmp    %edi,%ecx
  805a15:	0f 84 af 00 00 00    	je     805aca <tcp_bind+0x168>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805a1b:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805a1e:	85 d2                	test   %edx,%edx
  805a20:	75 c7                	jne    8059e9 <tcp_bind+0x87>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a22:	8b 15 8c b2 b3 00    	mov    0xb3b28c,%edx
  805a28:	eb 35                	jmp    805a5f <tcp_bind+0xfd>
    if (cpcb->local_port == port) {
  805a2a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a2e:	75 2c                	jne    805a5c <tcp_bind+0xfa>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a30:	85 d2                	test   %edx,%edx
  805a32:	0f 84 96 00 00 00    	je     805ace <tcp_bind+0x16c>
  805a38:	8b 0a                	mov    (%edx),%ecx
  805a3a:	85 c9                	test   %ecx,%ecx
  805a3c:	0f 84 90 00 00 00    	je     805ad2 <tcp_bind+0x170>
  805a42:	85 db                	test   %ebx,%ebx
  805a44:	0f 84 8c 00 00 00    	je     805ad6 <tcp_bind+0x174>
          ip_addr_isany(ipaddr) ||
  805a4a:	8b 3b                	mov    (%ebx),%edi
  805a4c:	85 ff                	test   %edi,%edi
  805a4e:	0f 84 86 00 00 00    	je     805ada <tcp_bind+0x178>
  805a54:	39 f9                	cmp    %edi,%ecx
  805a56:	0f 84 82 00 00 00    	je     805ade <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a5c:	8b 52 0c             	mov    0xc(%edx),%edx
  805a5f:	85 d2                	test   %edx,%edx
  805a61:	75 c7                	jne    805a2a <tcp_bind+0xc8>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a63:	8b 15 90 b2 b3 00    	mov    0xb3b290,%edx
  805a69:	eb 0f                	jmp    805a7a <tcp_bind+0x118>
    if (cpcb->local_port == port) {
  805a6b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a6f:	75 06                	jne    805a77 <tcp_bind+0x115>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805a71:	8b 0b                	mov    (%ebx),%ecx
  805a73:	39 0a                	cmp    %ecx,(%edx)
  805a75:	74 6b                	je     805ae2 <tcp_bind+0x180>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805a77:	8b 52 0c             	mov    0xc(%edx),%edx
  805a7a:	85 d2                	test   %edx,%edx
  805a7c:	75 ed                	jne    805a6b <tcp_bind+0x109>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805a7e:	85 db                	test   %ebx,%ebx
  805a80:	74 09                	je     805a8b <tcp_bind+0x129>
  805a82:	83 3b 00             	cmpl   $0x0,(%ebx)
  805a85:	74 04                	je     805a8b <tcp_bind+0x129>
    pcb->local_ip = *ipaddr;
  805a87:	8b 13                	mov    (%ebx),%edx
  805a89:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  805a8b:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805a8f:	a1 8c b2 b3 00       	mov    0xb3b28c,%eax
  805a94:	89 46 0c             	mov    %eax,0xc(%esi)
  805a97:	89 35 8c b2 b3 00    	mov    %esi,0xb3b28c
  805a9d:	e8 b0 ca ff ff       	call   802552 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805aa2:	b0 00                	mov    $0x0,%al
  805aa4:	eb 3e                	jmp    805ae4 <tcp_bind+0x182>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805aa6:	b0 f5                	mov    $0xf5,%al
  805aa8:	eb 3a                	jmp    805ae4 <tcp_bind+0x182>
  805aaa:	b0 f5                	mov    $0xf5,%al
  805aac:	eb 36                	jmp    805ae4 <tcp_bind+0x182>
  805aae:	b0 f5                	mov    $0xf5,%al
  805ab0:	eb 32                	jmp    805ae4 <tcp_bind+0x182>
  805ab2:	b0 f5                	mov    $0xf5,%al
  805ab4:	eb 2e                	jmp    805ae4 <tcp_bind+0x182>
  805ab6:	b0 f5                	mov    $0xf5,%al
  805ab8:	eb 2a                	jmp    805ae4 <tcp_bind+0x182>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805aba:	b0 f5                	mov    $0xf5,%al
  805abc:	eb 26                	jmp    805ae4 <tcp_bind+0x182>
  805abe:	b0 f5                	mov    $0xf5,%al
  805ac0:	eb 22                	jmp    805ae4 <tcp_bind+0x182>
  805ac2:	b0 f5                	mov    $0xf5,%al
  805ac4:	eb 1e                	jmp    805ae4 <tcp_bind+0x182>
  805ac6:	b0 f5                	mov    $0xf5,%al
  805ac8:	eb 1a                	jmp    805ae4 <tcp_bind+0x182>
  805aca:	b0 f5                	mov    $0xf5,%al
  805acc:	eb 16                	jmp    805ae4 <tcp_bind+0x182>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805ace:	b0 f5                	mov    $0xf5,%al
  805ad0:	eb 12                	jmp    805ae4 <tcp_bind+0x182>
  805ad2:	b0 f5                	mov    $0xf5,%al
  805ad4:	eb 0e                	jmp    805ae4 <tcp_bind+0x182>
  805ad6:	b0 f5                	mov    $0xf5,%al
  805ad8:	eb 0a                	jmp    805ae4 <tcp_bind+0x182>
  805ada:	b0 f5                	mov    $0xf5,%al
  805adc:	eb 06                	jmp    805ae4 <tcp_bind+0x182>
  805ade:	b0 f5                	mov    $0xf5,%al
  805ae0:	eb 02                	jmp    805ae4 <tcp_bind+0x182>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805ae2:	b0 f5                	mov    $0xf5,%al
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805ae4:	83 c4 1c             	add    $0x1c,%esp
  805ae7:	5b                   	pop    %ebx
  805ae8:	5e                   	pop    %esi
  805ae9:	5f                   	pop    %edi
  805aea:	5d                   	pop    %ebp
  805aeb:	c3                   	ret    

00805aec <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805aec:	55                   	push   %ebp
  805aed:	89 e5                	mov    %esp,%ebp
  805aef:	56                   	push   %esi
  805af0:	53                   	push   %ebx
  805af1:	83 ec 10             	sub    $0x10,%esp
  805af4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805af7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805afb:	74 1c                	je     805b19 <tcp_listen_with_backlog+0x2d>
  805afd:	c7 44 24 08 8c 18 81 	movl   $0x81188c,0x8(%esp)
  805b04:	00 
  805b05:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805b0c:	00 
  805b0d:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  805b14:	e8 5f 93 00 00       	call   80ee78 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805b19:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805b20:	e8 65 ee ff ff       	call   80498a <memp_malloc>
  805b25:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805b27:	85 c0                	test   %eax,%eax
  805b29:	0f 84 af 00 00 00    	je     805bde <tcp_listen_with_backlog+0xf2>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805b2f:	8b 43 18             	mov    0x18(%ebx),%eax
  805b32:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805b35:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805b38:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805b3c:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805b43:	8b 43 08             	mov    0x8(%ebx),%eax
  805b46:	83 c8 02             	or     $0x2,%eax
  805b49:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805b4d:	8a 43 0b             	mov    0xb(%ebx),%al
  805b50:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805b53:	8a 43 0a             	mov    0xa(%ebx),%al
  805b56:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805b59:	85 db                	test   %ebx,%ebx
  805b5b:	74 04                	je     805b61 <tcp_listen_with_backlog+0x75>
  805b5d:	8b 03                	mov    (%ebx),%eax
  805b5f:	eb 05                	jmp    805b66 <tcp_listen_with_backlog+0x7a>
  805b61:	b8 00 00 00 00       	mov    $0x0,%eax
  805b66:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805b68:	8b 15 8c b2 b3 00    	mov    0xb3b28c,%edx
  805b6e:	39 da                	cmp    %ebx,%edx
  805b70:	75 0a                	jne    805b7c <tcp_listen_with_backlog+0x90>
  805b72:	8b 42 0c             	mov    0xc(%edx),%eax
  805b75:	a3 8c b2 b3 00       	mov    %eax,0xb3b28c
  805b7a:	eb 31                	jmp    805bad <tcp_listen_with_backlog+0xc1>
  805b7c:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805b82:	eb 1f                	jmp    805ba3 <tcp_listen_with_backlog+0xb7>
  805b84:	8b 42 0c             	mov    0xc(%edx),%eax
  805b87:	85 c0                	test   %eax,%eax
  805b89:	74 12                	je     805b9d <tcp_listen_with_backlog+0xb1>
  805b8b:	39 c3                	cmp    %eax,%ebx
  805b8d:	75 12                	jne    805ba1 <tcp_listen_with_backlog+0xb5>
  805b8f:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805b95:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b98:	89 42 0c             	mov    %eax,0xc(%edx)
  805b9b:	eb 10                	jmp    805bad <tcp_listen_with_backlog+0xc1>
  805b9d:	89 c2                	mov    %eax,%edx
  805b9f:	eb 02                	jmp    805ba3 <tcp_listen_with_backlog+0xb7>
  805ba1:	89 c2                	mov    %eax,%edx
  805ba3:	85 d2                	test   %edx,%edx
  805ba5:	75 dd                	jne    805b84 <tcp_listen_with_backlog+0x98>
  805ba7:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805bad:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805bb4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805bb8:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805bbf:	e8 26 ee ff ff       	call   8049ea <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805bc4:	c7 46 20 f8 58 80 00 	movl   $0x8058f8,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805bcb:	a1 84 b2 b3 00       	mov    0xb3b284,%eax
  805bd0:	89 46 0c             	mov    %eax,0xc(%esi)
  805bd3:	89 35 84 b2 b3 00    	mov    %esi,0xb3b284
  805bd9:	e8 74 c9 ff ff       	call   802552 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
}
  805bde:	89 f0                	mov    %esi,%eax
  805be0:	83 c4 10             	add    $0x10,%esp
  805be3:	5b                   	pop    %ebx
  805be4:	5e                   	pop    %esi
  805be5:	5d                   	pop    %ebp
  805be6:	c3                   	ret    

00805be7 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805be7:	55                   	push   %ebp
  805be8:	89 e5                	mov    %esp,%ebp
  805bea:	56                   	push   %esi
  805beb:	53                   	push   %ebx
  805bec:	83 ec 10             	sub    $0x10,%esp
  805bef:	8b 45 08             	mov    0x8(%ebp),%eax
  805bf2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805bf5:	8b 50 28             	mov    0x28(%eax),%edx
  805bf8:	0f b7 f1             	movzwl %cx,%esi
  805bfb:	0f b7 da             	movzwl %dx,%ebx
  805bfe:	01 f3                	add    %esi,%ebx
  805c00:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805c06:	76 0e                	jbe    805c16 <tcp_recved+0x2f>
    pcb->rcv_wnd = TCP_WND;
  805c08:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805c0e:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805c14:	eb 10                	jmp    805c26 <tcp_recved+0x3f>
  } else {
    pcb->rcv_wnd += len;
  805c16:	01 ca                	add    %ecx,%edx
  805c18:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805c1c:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805c20:	72 04                	jb     805c26 <tcp_recved+0x3f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805c22:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805c26:	8a 50 20             	mov    0x20(%eax),%dl
  805c29:	f6 c2 03             	test   $0x3,%dl
  805c2c:	75 20                	jne    805c4e <tcp_recved+0x67>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805c2e:	f6 c2 01             	test   $0x1,%dl
  805c31:	74 13                	je     805c46 <tcp_recved+0x5f>
  805c33:	83 e2 fe             	and    $0xfffffffe,%edx
  805c36:	83 ca 02             	or     $0x2,%edx
  805c39:	88 50 20             	mov    %dl,0x20(%eax)
  805c3c:	89 04 24             	mov    %eax,(%esp)
  805c3f:	e8 1e 2a 00 00       	call   808662 <tcp_output>
  805c44:	eb 23                	jmp    805c69 <tcp_recved+0x82>
  805c46:	83 ca 01             	or     $0x1,%edx
  805c49:	88 50 20             	mov    %dl,0x20(%eax)
  805c4c:	eb 1b                	jmp    805c69 <tcp_recved+0x82>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805c4e:	f6 c2 01             	test   $0x1,%dl
  805c51:	74 16                	je     805c69 <tcp_recved+0x82>
  805c53:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805c59:	76 0e                	jbe    805c69 <tcp_recved+0x82>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805c5b:	83 ca 02             	or     $0x2,%edx
  805c5e:	88 50 20             	mov    %dl,0x20(%eax)
  805c61:	89 04 24             	mov    %eax,(%esp)
  805c64:	e8 f9 29 00 00       	call   808662 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805c69:	83 c4 10             	add    $0x10,%esp
  805c6c:	5b                   	pop    %ebx
  805c6d:	5e                   	pop    %esi
  805c6e:	5d                   	pop    %ebp
  805c6f:	c3                   	ret    

00805c70 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805c70:	55                   	push   %ebp
  805c71:	89 e5                	mov    %esp,%ebp
  805c73:	53                   	push   %ebx
  805c74:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805c77:	8b 1d 7c b2 b3 00    	mov    0xb3b27c,%ebx
  805c7d:	eb 60                	jmp    805cdf <tcp_fasttmr+0x6f>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805c7f:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805c85:	85 c0                	test   %eax,%eax
  805c87:	74 3a                	je     805cc3 <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805c89:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805c8f:	85 d2                	test   %edx,%edx
  805c91:	74 1e                	je     805cb1 <tcp_fasttmr+0x41>
  805c93:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805c9a:	00 
  805c9b:	89 44 24 08          	mov    %eax,0x8(%esp)
  805c9f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805ca3:	8b 43 18             	mov    0x18(%ebx),%eax
  805ca6:	89 04 24             	mov    %eax,(%esp)
  805ca9:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805cab:	84 c0                	test   %al,%al
  805cad:	75 14                	jne    805cc3 <tcp_fasttmr+0x53>
  805caf:	eb 08                	jmp    805cb9 <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805cb1:	89 04 24             	mov    %eax,(%esp)
  805cb4:	e8 bc f0 ff ff       	call   804d75 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805cb9:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805cc0:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805cc3:	8a 43 20             	mov    0x20(%ebx),%al
  805cc6:	a8 01                	test   $0x1,%al
  805cc8:	74 12                	je     805cdc <tcp_fasttmr+0x6c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805cca:	83 c8 02             	or     $0x2,%eax
  805ccd:	88 43 20             	mov    %al,0x20(%ebx)
  805cd0:	89 1c 24             	mov    %ebx,(%esp)
  805cd3:	e8 8a 29 00 00       	call   808662 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805cd8:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805cdc:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805cdf:	85 db                	test   %ebx,%ebx
  805ce1:	75 9c                	jne    805c7f <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805ce3:	83 c4 14             	add    $0x14,%esp
  805ce6:	5b                   	pop    %ebx
  805ce7:	5d                   	pop    %ebp
  805ce8:	c3                   	ret    

00805ce9 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805ce9:	55                   	push   %ebp
  805cea:	89 e5                	mov    %esp,%ebp
  805cec:	56                   	push   %esi
  805ced:	53                   	push   %ebx
  805cee:	83 ec 10             	sub    $0x10,%esp
  805cf1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805cf4:	85 db                	test   %ebx,%ebx
  805cf6:	74 2a                	je     805d22 <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  805cf8:	8b 43 04             	mov    0x4(%ebx),%eax
  805cfb:	85 c0                	test   %eax,%eax
  805cfd:	74 0c                	je     805d0b <tcp_seg_free+0x22>
      count = pbuf_free(seg->p);
  805cff:	89 04 24             	mov    %eax,(%esp)
  805d02:	e8 6e f0 ff ff       	call   804d75 <pbuf_free>
  805d07:	89 c6                	mov    %eax,%esi
  805d09:	eb 05                	jmp    805d10 <tcp_seg_free+0x27>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805d0b:	be 00 00 00 00       	mov    $0x0,%esi
      count = pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805d10:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805d14:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805d1b:	e8 ca ec ff ff       	call   8049ea <memp_free>
  805d20:	eb 05                	jmp    805d27 <tcp_seg_free+0x3e>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805d22:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  805d27:	89 f0                	mov    %esi,%eax
  805d29:	83 c4 10             	add    $0x10,%esp
  805d2c:	5b                   	pop    %ebx
  805d2d:	5e                   	pop    %esi
  805d2e:	5d                   	pop    %ebp
  805d2f:	c3                   	ret    

00805d30 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805d30:	55                   	push   %ebp
  805d31:	89 e5                	mov    %esp,%ebp
  805d33:	56                   	push   %esi
  805d34:	53                   	push   %ebx
  805d35:	83 ec 10             	sub    $0x10,%esp
  805d38:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805d3b:	be 00 00 00 00       	mov    $0x0,%esi
  struct tcp_seg *next;
  while (seg != NULL) {
  805d40:	eb 0e                	jmp    805d50 <tcp_segs_free+0x20>
    next = seg->next;
  805d42:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  805d44:	89 04 24             	mov    %eax,(%esp)
  805d47:	e8 9d ff ff ff       	call   805ce9 <tcp_seg_free>
  805d4c:	01 c6                	add    %eax,%esi
    seg = next;
  805d4e:	89 d8                	mov    %ebx,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805d50:	85 c0                	test   %eax,%eax
  805d52:	75 ee                	jne    805d42 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805d54:	89 f0                	mov    %esi,%eax
  805d56:	83 c4 10             	add    $0x10,%esp
  805d59:	5b                   	pop    %ebx
  805d5a:	5e                   	pop    %esi
  805d5b:	5d                   	pop    %ebp
  805d5c:	c3                   	ret    

00805d5d <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805d5d:	55                   	push   %ebp
  805d5e:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805d60:	8b 55 0c             	mov    0xc(%ebp),%edx
  805d63:	8b 45 08             	mov    0x8(%ebp),%eax
  805d66:	88 50 14             	mov    %dl,0x14(%eax)
}
  805d69:	5d                   	pop    %ebp
  805d6a:	c3                   	ret    

00805d6b <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805d6b:	55                   	push   %ebp
  805d6c:	89 e5                	mov    %esp,%ebp
  805d6e:	53                   	push   %ebx
  805d6f:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805d72:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805d79:	e8 0c ec ff ff       	call   80498a <memp_malloc>
  805d7e:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805d80:	85 c0                	test   %eax,%eax
  805d82:	74 22                	je     805da6 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805d84:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805d8b:	00 
  805d8c:	8b 45 08             	mov    0x8(%ebp),%eax
  805d8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d93:	89 1c 24             	mov    %ebx,(%esp)
  805d96:	e8 63 99 00 00       	call   80f6fe <memcpy>
  pbuf_ref(cseg->p);
  805d9b:	8b 43 04             	mov    0x4(%ebx),%eax
  805d9e:	89 04 24             	mov    %eax,(%esp)
  805da1:	e8 69 f4 ff ff       	call   80520f <pbuf_ref>
  return cseg;
}
  805da6:	89 d8                	mov    %ebx,%eax
  805da8:	83 c4 14             	add    $0x14,%esp
  805dab:	5b                   	pop    %ebx
  805dac:	5d                   	pop    %ebp
  805dad:	c3                   	ret    

00805dae <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805dae:	55                   	push   %ebp
  805daf:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805db1:	8b 55 0c             	mov    0xc(%ebp),%edx
  805db4:	8b 45 08             	mov    0x8(%ebp),%eax
  805db7:	89 50 18             	mov    %edx,0x18(%eax)
}
  805dba:	5d                   	pop    %ebp
  805dbb:	c3                   	ret    

00805dbc <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805dbc:	55                   	push   %ebp
  805dbd:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805dbf:	8b 55 0c             	mov    0xc(%ebp),%edx
  805dc2:	8b 45 08             	mov    0x8(%ebp),%eax
  805dc5:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805dcb:	5d                   	pop    %ebp
  805dcc:	c3                   	ret    

00805dcd <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805dcd:	55                   	push   %ebp
  805dce:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805dd0:	8b 55 0c             	mov    0xc(%ebp),%edx
  805dd3:	8b 45 08             	mov    0x8(%ebp),%eax
  805dd6:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805ddc:	5d                   	pop    %ebp
  805ddd:	c3                   	ret    

00805dde <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805dde:	55                   	push   %ebp
  805ddf:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805de1:	8b 55 0c             	mov    0xc(%ebp),%edx
  805de4:	8b 45 08             	mov    0x8(%ebp),%eax
  805de7:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805ded:	5d                   	pop    %ebp
  805dee:	c3                   	ret    

00805def <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805def:	55                   	push   %ebp
  805df0:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805df2:	8b 55 0c             	mov    0xc(%ebp),%edx
  805df5:	8b 45 08             	mov    0x8(%ebp),%eax
  805df8:	89 50 20             	mov    %edx,0x20(%eax)
}
  805dfb:	5d                   	pop    %ebp
  805dfc:	c3                   	ret    

00805dfd <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805dfd:	55                   	push   %ebp
  805dfe:	89 e5                	mov    %esp,%ebp
  805e00:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805e03:	8b 55 0c             	mov    0xc(%ebp),%edx
  805e06:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805e0c:	8b 55 10             	mov    0x10(%ebp),%edx
  805e0f:	88 50 31             	mov    %dl,0x31(%eax)
}
  805e12:	5d                   	pop    %ebp
  805e13:	c3                   	ret    

00805e14 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805e14:	55                   	push   %ebp
  805e15:	89 e5                	mov    %esp,%ebp
  805e17:	53                   	push   %ebx
  805e18:	83 ec 14             	sub    $0x14,%esp
  805e1b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805e1e:	8b 43 10             	mov    0x10(%ebx),%eax
  805e21:	85 c0                	test   %eax,%eax
  805e23:	74 62                	je     805e87 <tcp_pcb_purge+0x73>
  805e25:	83 f8 0a             	cmp    $0xa,%eax
  805e28:	74 5d                	je     805e87 <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
  805e2a:	83 f8 01             	cmp    $0x1,%eax
  805e2d:	74 58                	je     805e87 <tcp_pcb_purge+0x73>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805e2f:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805e35:	85 c0                	test   %eax,%eax
  805e37:	74 12                	je     805e4b <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805e39:	89 04 24             	mov    %eax,(%esp)
  805e3c:	e8 34 ef ff ff       	call   804d75 <pbuf_free>
      pcb->refused_data = NULL;
  805e41:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805e48:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805e4b:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805e51:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805e54:	89 04 24             	mov    %eax,(%esp)
  805e57:	e8 d4 fe ff ff       	call   805d30 <tcp_segs_free>
    pcb->ooseq = NULL;
  805e5c:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805e63:	8b 43 74             	mov    0x74(%ebx),%eax
  805e66:	89 04 24             	mov    %eax,(%esp)
  805e69:	e8 c2 fe ff ff       	call   805d30 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805e6e:	8b 43 78             	mov    0x78(%ebx),%eax
  805e71:	89 04 24             	mov    %eax,(%esp)
  805e74:	e8 b7 fe ff ff       	call   805d30 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805e79:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805e80:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805e87:	83 c4 14             	add    $0x14,%esp
  805e8a:	5b                   	pop    %ebx
  805e8b:	5d                   	pop    %ebp
  805e8c:	c3                   	ret    

00805e8d <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805e8d:	55                   	push   %ebp
  805e8e:	89 e5                	mov    %esp,%ebp
  805e90:	53                   	push   %ebx
  805e91:	83 ec 14             	sub    $0x14,%esp
  805e94:	8b 45 08             	mov    0x8(%ebp),%eax
  805e97:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805e9a:	8b 10                	mov    (%eax),%edx
  805e9c:	39 da                	cmp    %ebx,%edx
  805e9e:	75 07                	jne    805ea7 <tcp_pcb_remove+0x1a>
  805ea0:	8b 52 0c             	mov    0xc(%edx),%edx
  805ea3:	89 10                	mov    %edx,(%eax)
  805ea5:	eb 31                	jmp    805ed8 <tcp_pcb_remove+0x4b>
  805ea7:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805ead:	eb 1f                	jmp    805ece <tcp_pcb_remove+0x41>
  805eaf:	8b 42 0c             	mov    0xc(%edx),%eax
  805eb2:	85 c0                	test   %eax,%eax
  805eb4:	74 12                	je     805ec8 <tcp_pcb_remove+0x3b>
  805eb6:	39 c3                	cmp    %eax,%ebx
  805eb8:	75 12                	jne    805ecc <tcp_pcb_remove+0x3f>
  805eba:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805ec0:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ec3:	89 42 0c             	mov    %eax,0xc(%edx)
  805ec6:	eb 10                	jmp    805ed8 <tcp_pcb_remove+0x4b>
  805ec8:	89 c2                	mov    %eax,%edx
  805eca:	eb 02                	jmp    805ece <tcp_pcb_remove+0x41>
  805ecc:	89 c2                	mov    %eax,%edx
  805ece:	85 d2                	test   %edx,%edx
  805ed0:	75 dd                	jne    805eaf <tcp_pcb_remove+0x22>
  805ed2:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  805ed8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805edf:	89 1c 24             	mov    %ebx,(%esp)
  805ee2:	e8 2d ff ff ff       	call   805e14 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805ee7:	8b 43 10             	mov    0x10(%ebx),%eax
  805eea:	83 f8 0a             	cmp    $0xa,%eax
  805eed:	74 24                	je     805f13 <tcp_pcb_remove+0x86>
  805eef:	83 f8 01             	cmp    $0x1,%eax
  805ef2:	0f 84 81 00 00 00    	je     805f79 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805ef8:	8a 43 20             	mov    0x20(%ebx),%al

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805efb:	a8 01                	test   $0x1,%al
  805efd:	74 14                	je     805f13 <tcp_pcb_remove+0x86>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  805eff:	83 c8 02             	or     $0x2,%eax
  805f02:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805f05:	89 1c 24             	mov    %ebx,(%esp)
  805f08:	e8 55 27 00 00       	call   808662 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  805f0d:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805f11:	74 66                	je     805f79 <tcp_pcb_remove+0xec>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805f13:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805f17:	74 1c                	je     805f35 <tcp_pcb_remove+0xa8>
  805f19:	c7 44 24 08 56 1a 81 	movl   $0x811a56,0x8(%esp)
  805f20:	00 
  805f21:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  805f28:	00 
  805f29:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  805f30:	e8 43 8f 00 00       	call   80ee78 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805f35:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805f39:	74 1c                	je     805f57 <tcp_pcb_remove+0xca>
  805f3b:	c7 44 24 08 6e 1a 81 	movl   $0x811a6e,0x8(%esp)
  805f42:	00 
  805f43:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  805f4a:	00 
  805f4b:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  805f52:	e8 21 8f 00 00       	call   80ee78 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805f57:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805f5b:	74 1c                	je     805f79 <tcp_pcb_remove+0xec>
  805f5d:	c7 44 24 08 87 1a 81 	movl   $0x811a87,0x8(%esp)
  805f64:	00 
  805f65:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  805f6c:	00 
  805f6d:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  805f74:	e8 ff 8e 00 00       	call   80ee78 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805f79:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805f80:	83 c4 14             	add    $0x14,%esp
  805f83:	5b                   	pop    %ebx
  805f84:	5d                   	pop    %ebp
  805f85:	c3                   	ret    

00805f86 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805f86:	55                   	push   %ebp
  805f87:	89 e5                	mov    %esp,%ebp
  805f89:	57                   	push   %edi
  805f8a:	56                   	push   %esi
  805f8b:	53                   	push   %ebx
  805f8c:	83 ec 4c             	sub    $0x4c,%esp
  805f8f:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805f92:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805f96:	75 25                	jne    805fbd <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805f98:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805f9c:	c7 04 24 90 b2 b3 00 	movl   $0xb3b290,(%esp)
  805fa3:	e8 e5 fe ff ff       	call   805e8d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805fa8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805fac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805fb3:	e8 32 ea ff ff       	call   8049ea <memp_free>
  805fb8:	e9 d6 00 00 00       	jmp    806093 <tcp_abort+0x10d>
  } else {
    seqno = pcb->snd_nxt;
  805fbd:	8b 43 54             	mov    0x54(%ebx),%eax
  805fc0:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  805fc3:	8b 43 24             	mov    0x24(%ebx),%eax
  805fc6:	89 45 cc             	mov    %eax,-0x34(%ebp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805fc9:	85 db                	test   %ebx,%ebx
  805fcb:	74 04                	je     805fd1 <tcp_abort+0x4b>
  805fcd:	8b 03                	mov    (%ebx),%eax
  805fcf:	eb 05                	jmp    805fd6 <tcp_abort+0x50>
  805fd1:	b8 00 00 00 00       	mov    $0x0,%eax
  805fd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805fd9:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805fdc:	74 05                	je     805fe3 <tcp_abort+0x5d>
  805fde:	8b 43 04             	mov    0x4(%ebx),%eax
  805fe1:	eb 05                	jmp    805fe8 <tcp_abort+0x62>
  805fe3:	b8 00 00 00 00       	mov    $0x0,%eax
  805fe8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805feb:	8b 7b 1c             	mov    0x1c(%ebx),%edi
    remote_port = pcb->remote_port;
  805fee:	66 8b 73 1e          	mov    0x1e(%ebx),%si
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805ff2:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805ff8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805ffb:	8b 43 18             	mov    0x18(%ebx),%eax
  805ffe:	89 45 c8             	mov    %eax,-0x38(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806001:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806005:	c7 04 24 7c b2 b3 00 	movl   $0xb3b27c,(%esp)
  80600c:	e8 7c fe ff ff       	call   805e8d <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  806011:	8b 43 78             	mov    0x78(%ebx),%eax
  806014:	85 c0                	test   %eax,%eax
  806016:	74 08                	je     806020 <tcp_abort+0x9a>
      tcp_segs_free(pcb->unacked);
  806018:	89 04 24             	mov    %eax,(%esp)
  80601b:	e8 10 fd ff ff       	call   805d30 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  806020:	8b 43 74             	mov    0x74(%ebx),%eax
  806023:	85 c0                	test   %eax,%eax
  806025:	74 08                	je     80602f <tcp_abort+0xa9>
      tcp_segs_free(pcb->unsent);
  806027:	89 04 24             	mov    %eax,(%esp)
  80602a:	e8 01 fd ff ff       	call   805d30 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80602f:	8b 43 7c             	mov    0x7c(%ebx),%eax
  806032:	85 c0                	test   %eax,%eax
  806034:	74 08                	je     80603e <tcp_abort+0xb8>
      tcp_segs_free(pcb->ooseq);
  806036:	89 04 24             	mov    %eax,(%esp)
  806039:	e8 f2 fc ff ff       	call   805d30 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80603e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806042:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806049:	e8 9c e9 ff ff       	call   8049ea <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80604e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806052:	74 11                	je     806065 <tcp_abort+0xdf>
  806054:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80605b:	ff 
  80605c:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80605f:	89 04 24             	mov    %eax,(%esp)
  806062:	ff 55 d4             	call   *-0x2c(%ebp)
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  806065:	0f b7 f6             	movzwl %si,%esi
  806068:	89 74 24 14          	mov    %esi,0x14(%esp)
  80606c:	0f b7 ff             	movzwl %di,%edi
  80606f:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806073:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806076:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80607a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80607d:	89 44 24 08          	mov    %eax,0x8(%esp)
  806081:	8b 45 cc             	mov    -0x34(%ebp),%eax
  806084:	89 44 24 04          	mov    %eax,0x4(%esp)
  806088:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80608b:	89 04 24             	mov    %eax,(%esp)
  80608e:	e8 59 2a 00 00       	call   808aec <tcp_rst>
  }
}
  806093:	83 c4 4c             	add    $0x4c,%esp
  806096:	5b                   	pop    %ebx
  806097:	5e                   	pop    %esi
  806098:	5f                   	pop    %edi
  806099:	5d                   	pop    %ebp
  80609a:	c3                   	ret    

0080609b <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80609b:	55                   	push   %ebp
  80609c:	89 e5                	mov    %esp,%ebp
  80609e:	57                   	push   %edi
  80609f:	56                   	push   %esi
  8060a0:	53                   	push   %ebx
  8060a1:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  8060a4:	ff 05 80 b2 b3 00    	incl   0xb3b280

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  8060aa:	8b 1d 7c b2 b3 00    	mov    0xb3b27c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  8060b0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  8060b4:	bf 00 00 00 00       	mov    $0x0,%edi
  8060b9:	e9 3b 03 00 00       	jmp    8063f9 <tcp_slowtmr+0x35e>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  8060be:	8b 43 10             	mov    0x10(%ebx),%eax
  8060c1:	85 c0                	test   %eax,%eax
  8060c3:	75 1c                	jne    8060e1 <tcp_slowtmr+0x46>
  8060c5:	c7 44 24 08 b0 18 81 	movl   $0x8118b0,0x8(%esp)
  8060cc:	00 
  8060cd:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  8060d4:	00 
  8060d5:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  8060dc:	e8 97 8d 00 00       	call   80ee78 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8060e1:	83 f8 01             	cmp    $0x1,%eax
  8060e4:	75 1c                	jne    806102 <tcp_slowtmr+0x67>
  8060e6:	c7 44 24 08 dc 18 81 	movl   $0x8118dc,0x8(%esp)
  8060ed:	00 
  8060ee:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  8060f5:	00 
  8060f6:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  8060fd:	e8 76 8d 00 00       	call   80ee78 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  806102:	83 f8 0a             	cmp    $0xa,%eax
  806105:	75 1c                	jne    806123 <tcp_slowtmr+0x88>
  806107:	c7 44 24 08 08 19 81 	movl   $0x811908,0x8(%esp)
  80610e:	00 
  80610f:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  806116:	00 
  806117:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80611e:	e8 55 8d 00 00       	call   80ee78 <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  806123:	83 f8 02             	cmp    $0x2,%eax
  806126:	75 0a                	jne    806132 <tcp_slowtmr+0x97>
  806128:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  80612c:	0f 84 13 01 00 00    	je     806245 <tcp_slowtmr+0x1aa>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806132:	8a 53 46             	mov    0x46(%ebx),%dl
  806135:	80 fa 0c             	cmp    $0xc,%dl
  806138:	0f 84 d0 00 00 00    	je     80620e <tcp_slowtmr+0x173>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80613e:	8a 8b a4 00 00 00    	mov    0xa4(%ebx),%cl
  806144:	84 c9                	test   %cl,%cl
  806146:	74 47                	je     80618f <tcp_slowtmr+0xf4>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  806148:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  80614e:	40                   	inc    %eax
  80614f:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  806155:	0f b6 d1             	movzbl %cl,%edx
  806158:	0f b6 92 bf 1a 81 00 	movzbl 0x811abf(%edx),%edx
  80615f:	39 d0                	cmp    %edx,%eax
  806161:	0f 82 ae 00 00 00    	jb     806215 <tcp_slowtmr+0x17a>
          pcb->persist_cnt = 0;
  806167:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80616e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  806171:	80 f9 06             	cmp    $0x6,%cl
  806174:	77 07                	ja     80617d <tcp_slowtmr+0xe2>
            pcb->persist_backoff++;
  806176:	41                   	inc    %ecx
  806177:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  80617d:	89 1c 24             	mov    %ebx,(%esp)
  806180:	e8 b5 2c 00 00       	call   808e3a <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806185:	be 00 00 00 00       	mov    $0x0,%esi
  80618a:	e9 99 00 00 00       	jmp    806228 <tcp_slowtmr+0x18d>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80618f:	66 8b 4b 32          	mov    0x32(%ebx),%cx
  806193:	66 85 c9             	test   %cx,%cx
  806196:	78 05                	js     80619d <tcp_slowtmr+0x102>
          ++pcb->rtime;
  806198:	41                   	inc    %ecx
  806199:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80619d:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8061a1:	74 79                	je     80621c <tcp_slowtmr+0x181>
  8061a3:	8b 4b 44             	mov    0x44(%ebx),%ecx
  8061a6:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  8061aa:	7c 77                	jl     806223 <tcp_slowtmr+0x188>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  8061ac:	83 f8 02             	cmp    $0x2,%eax
  8061af:	74 1e                	je     8061cf <tcp_slowtmr+0x134>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  8061b1:	8b 43 40             	mov    0x40(%ebx),%eax
  8061b4:	66 c1 f8 03          	sar    $0x3,%ax
  8061b8:	98                   	cwtl   
  8061b9:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  8061bd:	01 c8                	add    %ecx,%eax
  8061bf:	0f b6 d2             	movzbl %dl,%edx
  8061c2:	0f b6 8a c7 1a 81 00 	movzbl 0x811ac7(%edx),%ecx
  8061c9:	d3 e0                	shl    %cl,%eax
  8061cb:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  8061cf:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  8061d5:	8b 53 5c             	mov    0x5c(%ebx),%edx
  8061d8:	66 8b 43 4e          	mov    0x4e(%ebx),%ax
  8061dc:	66 39 d0             	cmp    %dx,%ax
  8061df:	76 02                	jbe    8061e3 <tcp_slowtmr+0x148>
  8061e1:	89 d0                	mov    %edx,%eax
          pcb->ssthresh = eff_wnd >> 1;
  8061e3:	89 c2                	mov    %eax,%edx
  8061e5:	66 d1 ea             	shr    %dx
  8061e8:	66 89 53 50          	mov    %dx,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  8061ec:	8b 43 34             	mov    0x34(%ebx),%eax
  8061ef:	66 39 c2             	cmp    %ax,%dx
  8061f2:	73 07                	jae    8061fb <tcp_slowtmr+0x160>
            pcb->ssthresh = pcb->mss * 2;
  8061f4:	8d 14 00             	lea    (%eax,%eax,1),%edx
  8061f7:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  8061fb:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8061ff:	89 1c 24             	mov    %ebx,(%esp)
  806202:	e8 40 2a 00 00       	call   808c47 <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806207:	be 00 00 00 00       	mov    $0x0,%esi
  80620c:	eb 1a                	jmp    806228 <tcp_slowtmr+0x18d>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
      ++pcb_remove;
  80620e:	be 01 00 00 00       	mov    $0x1,%esi
  806213:	eb 13                	jmp    806228 <tcp_slowtmr+0x18d>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806215:	be 00 00 00 00       	mov    $0x0,%esi
  80621a:	eb 0c                	jmp    806228 <tcp_slowtmr+0x18d>
  80621c:	be 00 00 00 00       	mov    $0x0,%esi
  806221:	eb 05                	jmp    806228 <tcp_slowtmr+0x18d>
  806223:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  806228:	8b 43 10             	mov    0x10(%ebx),%eax
  80622b:	83 f8 06             	cmp    $0x6,%eax
  80622e:	75 1a                	jne    80624a <tcp_slowtmr+0x1af>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806230:	8b 15 80 b2 b3 00    	mov    0xb3b280,%edx
  806236:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806239:	83 fa 29             	cmp    $0x29,%edx
  80623c:	89 f2                	mov    %esi,%edx
  80623e:	80 da ff             	sbb    $0xff,%dl
  806241:	89 d6                	mov    %edx,%esi
  806243:	eb 05                	jmp    80624a <tcp_slowtmr+0x1af>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
  806245:	be 01 00 00 00       	mov    $0x1,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80624a:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80624e:	74 6f                	je     8062bf <tcp_slowtmr+0x224>
  806250:	83 f8 04             	cmp    $0x4,%eax
  806253:	74 05                	je     80625a <tcp_slowtmr+0x1bf>
       ((pcb->state == ESTABLISHED) || 
  806255:	83 f8 07             	cmp    $0x7,%eax
  806258:	75 65                	jne    8062bf <tcp_slowtmr+0x224>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80625a:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  80625f:	2b 43 2c             	sub    0x2c(%ebx),%eax
  806262:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806265:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  80626b:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  806271:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806276:	f7 e2                	mul    %edx
  806278:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80627b:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80627e:	76 0a                	jbe    80628a <tcp_slowtmr+0x1ef>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  806280:	89 1c 24             	mov    %ebx,(%esp)
  806283:	e8 fe fc ff ff       	call   805f86 <tcp_abort>
  806288:	eb 35                	jmp    8062bf <tcp_slowtmr+0x224>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80628a:	0f b6 83 a5 00 00 00 	movzbl 0xa5(%ebx),%eax
  806291:	8d 14 c0             	lea    (%eax,%eax,8),%edx
  806294:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  806297:	8d 14 90             	lea    (%eax,%edx,4),%edx
  80629a:	c1 e2 05             	shl    $0x5,%edx
  80629d:	29 c2                	sub    %eax,%edx
  80629f:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
              / TCP_SLOW_INTERVAL)
  8062a2:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8062a7:	f7 e2                	mul    %edx
  8062a9:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  8062ac:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8062af:	76 0e                	jbe    8062bf <tcp_slowtmr+0x224>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  8062b1:	89 1c 24             	mov    %ebx,(%esp)
  8062b4:	e8 2e 2a 00 00       	call   808ce7 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  8062b9:	fe 83 a5 00 00 00    	incb   0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  8062bf:	8b 53 7c             	mov    0x7c(%ebx),%edx
  8062c2:	85 d2                	test   %edx,%edx
  8062c4:	74 25                	je     8062eb <tcp_slowtmr+0x250>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  8062c6:	8b 0d 80 b2 b3 00    	mov    0xb3b280,%ecx
  8062cc:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  8062cf:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  8062d3:	8d 04 40             	lea    (%eax,%eax,2),%eax
  8062d6:	d1 e0                	shl    %eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  8062d8:	39 c1                	cmp    %eax,%ecx
  8062da:	72 0f                	jb     8062eb <tcp_slowtmr+0x250>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  8062dc:	89 14 24             	mov    %edx,(%esp)
  8062df:	e8 4c fa ff ff       	call   805d30 <tcp_segs_free>
      pcb->ooseq = NULL;
  8062e4:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8062eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8062ee:	83 f8 03             	cmp    $0x3,%eax
  8062f1:	75 11                	jne    806304 <tcp_slowtmr+0x269>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8062f3:	8b 15 80 b2 b3 00    	mov    0xb3b280,%edx
  8062f9:	2b 53 2c             	sub    0x2c(%ebx),%edx
  8062fc:	83 fa 28             	cmp    $0x28,%edx
  8062ff:	76 03                	jbe    806304 <tcp_slowtmr+0x269>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806301:	46                   	inc    %esi
  806302:	eb 19                	jmp    80631d <tcp_slowtmr+0x282>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  806304:	83 f8 09             	cmp    $0x9,%eax
  806307:	75 14                	jne    80631d <tcp_slowtmr+0x282>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806309:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  80630e:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  806311:	3d f1 00 00 00       	cmp    $0xf1,%eax
  806316:	89 f2                	mov    %esi,%edx
  806318:	80 da ff             	sbb    $0xff,%dl
  80631b:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80631d:	89 f1                	mov    %esi,%ecx
  80631f:	84 c9                	test   %cl,%cl
  806321:	0f 84 96 00 00 00    	je     8063bd <tcp_slowtmr+0x322>
      tcp_pcb_purge(pcb);      
  806327:	89 1c 24             	mov    %ebx,(%esp)
  80632a:	e8 e5 fa ff ff       	call   805e14 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80632f:	85 ff                	test   %edi,%edi
  806331:	74 2c                	je     80635f <tcp_slowtmr+0x2c4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806333:	3b 1d 7c b2 b3 00    	cmp    0xb3b27c,%ebx
  806339:	75 1c                	jne    806357 <tcp_slowtmr+0x2bc>
  80633b:	c7 44 24 08 38 19 81 	movl   $0x811938,0x8(%esp)
  806342:	00 
  806343:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  80634a:	00 
  80634b:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  806352:	e8 21 8b 00 00       	call   80ee78 <_panic>
        prev->next = pcb->next;
  806357:	8b 43 0c             	mov    0xc(%ebx),%eax
  80635a:	89 47 0c             	mov    %eax,0xc(%edi)
  80635d:	eb 2d                	jmp    80638c <tcp_slowtmr+0x2f1>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80635f:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  806364:	39 d8                	cmp    %ebx,%eax
  806366:	74 1c                	je     806384 <tcp_slowtmr+0x2e9>
  806368:	c7 44 24 08 64 19 81 	movl   $0x811964,0x8(%esp)
  80636f:	00 
  806370:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  806377:	00 
  806378:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80637f:	e8 f4 8a 00 00       	call   80ee78 <_panic>
        tcp_active_pcbs = pcb->next;
  806384:	8b 40 0c             	mov    0xc(%eax),%eax
  806387:	a3 7c b2 b3 00       	mov    %eax,0xb3b27c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80638c:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  806392:	85 c0                	test   %eax,%eax
  806394:	74 10                	je     8063a6 <tcp_slowtmr+0x30b>
  806396:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80639d:	ff 
  80639e:	8b 53 18             	mov    0x18(%ebx),%edx
  8063a1:	89 14 24             	mov    %edx,(%esp)
  8063a4:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  8063a6:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  8063a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8063ad:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8063b4:	e8 31 e6 ff ff       	call   8049ea <memp_free>
      pcb = pcb2;
  8063b9:	89 f3                	mov    %esi,%ebx
  8063bb:	eb 3c                	jmp    8063f9 <tcp_slowtmr+0x35e>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  8063bd:	8a 43 30             	mov    0x30(%ebx),%al
  8063c0:	40                   	inc    %eax
  8063c1:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  8063c4:	3a 43 31             	cmp    0x31(%ebx),%al
  8063c7:	72 2b                	jb     8063f4 <tcp_slowtmr+0x359>
        pcb->polltmr = 0;
  8063c9:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8063cd:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  8063d3:	85 c0                	test   %eax,%eax
  8063d5:	74 0f                	je     8063e6 <tcp_slowtmr+0x34b>
  8063d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8063db:	8b 53 18             	mov    0x18(%ebx),%edx
  8063de:	89 14 24             	mov    %edx,(%esp)
  8063e1:	ff d0                	call   *%eax
  8063e3:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8063e6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8063ea:	75 08                	jne    8063f4 <tcp_slowtmr+0x359>
          tcp_output(pcb);
  8063ec:	89 1c 24             	mov    %ebx,(%esp)
  8063ef:	e8 6e 22 00 00       	call   808662 <tcp_output>
        }
      }
      
      prev = pcb;
  8063f4:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  8063f6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8063f9:	85 db                	test   %ebx,%ebx
  8063fb:	0f 85 bd fc ff ff    	jne    8060be <tcp_slowtmr+0x23>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  806401:	8b 1d 90 b2 b3 00    	mov    0xb3b290,%ebx
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  806407:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80640c:	e9 b2 00 00 00       	jmp    8064c3 <tcp_slowtmr+0x428>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806411:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  806415:	74 1c                	je     806433 <tcp_slowtmr+0x398>
  806417:	c7 44 24 08 90 19 81 	movl   $0x811990,0x8(%esp)
  80641e:	00 
  80641f:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  806426:	00 
  806427:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80642e:	e8 45 8a 00 00       	call   80ee78 <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806433:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  806438:	2b 43 2c             	sub    0x2c(%ebx),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80643b:	3d f0 00 00 00       	cmp    $0xf0,%eax
  806440:	76 7c                	jbe    8064be <tcp_slowtmr+0x423>
      tcp_pcb_purge(pcb);      
  806442:	89 1c 24             	mov    %ebx,(%esp)
  806445:	e8 ca f9 ff ff       	call   805e14 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80644a:	85 f6                	test   %esi,%esi
  80644c:	74 2c                	je     80647a <tcp_slowtmr+0x3df>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80644e:	3b 1d 90 b2 b3 00    	cmp    0xb3b290,%ebx
  806454:	75 1c                	jne    806472 <tcp_slowtmr+0x3d7>
  806456:	c7 44 24 08 c0 19 81 	movl   $0x8119c0,0x8(%esp)
  80645d:	00 
  80645e:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  806465:	00 
  806466:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80646d:	e8 06 8a 00 00       	call   80ee78 <_panic>
        prev->next = pcb->next;
  806472:	8b 43 0c             	mov    0xc(%ebx),%eax
  806475:	89 46 0c             	mov    %eax,0xc(%esi)
  806478:	eb 2d                	jmp    8064a7 <tcp_slowtmr+0x40c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80647a:	a1 90 b2 b3 00       	mov    0xb3b290,%eax
  80647f:	39 d8                	cmp    %ebx,%eax
  806481:	74 1c                	je     80649f <tcp_slowtmr+0x404>
  806483:	c7 44 24 08 e8 19 81 	movl   $0x8119e8,0x8(%esp)
  80648a:	00 
  80648b:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  806492:	00 
  806493:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80649a:	e8 d9 89 00 00       	call   80ee78 <_panic>
        tcp_tw_pcbs = pcb->next;
  80649f:	8b 40 0c             	mov    0xc(%eax),%eax
  8064a2:	a3 90 b2 b3 00       	mov    %eax,0xb3b290
      }
      pcb2 = pcb->next;
  8064a7:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8064aa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8064ae:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8064b5:	e8 30 e5 ff ff       	call   8049ea <memp_free>
      pcb = pcb2;
  8064ba:	89 fb                	mov    %edi,%ebx
  8064bc:	eb 05                	jmp    8064c3 <tcp_slowtmr+0x428>
    } else {
      prev = pcb;
  8064be:	89 de                	mov    %ebx,%esi
      pcb = pcb->next;
  8064c0:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8064c3:	85 db                	test   %ebx,%ebx
  8064c5:	0f 85 46 ff ff ff    	jne    806411 <tcp_slowtmr+0x376>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8064cb:	83 c4 2c             	add    $0x2c,%esp
  8064ce:	5b                   	pop    %ebx
  8064cf:	5e                   	pop    %esi
  8064d0:	5f                   	pop    %edi
  8064d1:	5d                   	pop    %ebp
  8064d2:	c3                   	ret    

008064d3 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8064d3:	55                   	push   %ebp
  8064d4:	89 e5                	mov    %esp,%ebp
  8064d6:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8064d9:	e8 92 f7 ff ff       	call   805c70 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8064de:	a0 1c 44 b3 00       	mov    0xb3441c,%al
  8064e3:	40                   	inc    %eax
  8064e4:	a2 1c 44 b3 00       	mov    %al,0xb3441c
  8064e9:	a8 01                	test   $0x1,%al
  8064eb:	74 05                	je     8064f2 <tcp_tmr+0x1f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8064ed:	e8 a9 fb ff ff       	call   80609b <tcp_slowtmr>
  }
}
  8064f2:	c9                   	leave  
  8064f3:	c3                   	ret    

008064f4 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8064f4:	55                   	push   %ebp
  8064f5:	89 e5                	mov    %esp,%ebp
  8064f7:	56                   	push   %esi
  8064f8:	53                   	push   %ebx
  8064f9:	83 ec 10             	sub    $0x10,%esp
  8064fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8064ff:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  806503:	0f 87 1e 01 00 00    	ja     806627 <tcp_close+0x133>
  806509:	8b 43 10             	mov    0x10(%ebx),%eax
  80650c:	ff 24 85 a0 1a 81 00 	jmp    *0x811aa0(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  806513:	8b 15 8c b2 b3 00    	mov    0xb3b28c,%edx
  806519:	39 da                	cmp    %ebx,%edx
  80651b:	75 0a                	jne    806527 <tcp_close+0x33>
  80651d:	8b 42 0c             	mov    0xc(%edx),%eax
  806520:	a3 8c b2 b3 00       	mov    %eax,0xb3b28c
  806525:	eb 31                	jmp    806558 <tcp_close+0x64>
  806527:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  80652d:	eb 1f                	jmp    80654e <tcp_close+0x5a>
  80652f:	8b 42 0c             	mov    0xc(%edx),%eax
  806532:	85 c0                	test   %eax,%eax
  806534:	74 12                	je     806548 <tcp_close+0x54>
  806536:	39 c3                	cmp    %eax,%ebx
  806538:	75 12                	jne    80654c <tcp_close+0x58>
  80653a:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  806540:	8b 43 0c             	mov    0xc(%ebx),%eax
  806543:	89 42 0c             	mov    %eax,0xc(%edx)
  806546:	eb 10                	jmp    806558 <tcp_close+0x64>
  806548:	89 c2                	mov    %eax,%edx
  80654a:	eb 02                	jmp    80654e <tcp_close+0x5a>
  80654c:	89 c2                	mov    %eax,%edx
  80654e:	85 d2                	test   %edx,%edx
  806550:	75 dd                	jne    80652f <tcp_close+0x3b>
  806552:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  806558:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  80655f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806563:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80656a:	e8 7b e4 ff ff       	call   8049ea <memp_free>
    pcb = NULL;
    break;
  80656f:	be 00 00 00 00       	mov    $0x0,%esi
  806574:	e9 ca 00 00 00       	jmp    806643 <tcp_close+0x14f>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  806579:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80657d:	c7 04 24 84 b2 b3 00 	movl   $0xb3b284,(%esp)
  806584:	e8 04 f9 ff ff       	call   805e8d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  806589:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80658d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  806594:	e8 51 e4 ff ff       	call   8049ea <memp_free>
    pcb = NULL;
    break;
  806599:	be 00 00 00 00       	mov    $0x0,%esi
  80659e:	e9 a0 00 00 00       	jmp    806643 <tcp_close+0x14f>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8065a3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8065a7:	c7 04 24 7c b2 b3 00 	movl   $0xb3b27c,(%esp)
  8065ae:	e8 da f8 ff ff       	call   805e8d <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8065b3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8065b7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8065be:	e8 27 e4 ff ff       	call   8049ea <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  8065c3:	be 00 00 00 00       	mov    $0x0,%esi
  8065c8:	eb 79                	jmp    806643 <tcp_close+0x14f>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8065ca:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8065d1:	00 
  8065d2:	89 1c 24             	mov    %ebx,(%esp)
  8065d5:	e8 45 20 00 00       	call   80861f <tcp_send_ctrl>
  8065da:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8065dc:	84 c0                	test   %al,%al
  8065de:	75 51                	jne    806631 <tcp_close+0x13d>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8065e0:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8065e7:	eb 48                	jmp    806631 <tcp_close+0x13d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8065e9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8065f0:	00 
  8065f1:	89 1c 24             	mov    %ebx,(%esp)
  8065f4:	e8 26 20 00 00       	call   80861f <tcp_send_ctrl>
  8065f9:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  8065fb:	84 c0                	test   %al,%al
  8065fd:	75 32                	jne    806631 <tcp_close+0x13d>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8065ff:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806606:	eb 29                	jmp    806631 <tcp_close+0x13d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806608:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80660f:	00 
  806610:	89 1c 24             	mov    %ebx,(%esp)
  806613:	e8 07 20 00 00       	call   80861f <tcp_send_ctrl>
  806618:	89 c6                	mov    %eax,%esi
    if (err == ERR_OK) {
  80661a:	84 c0                	test   %al,%al
  80661c:	75 13                	jne    806631 <tcp_close+0x13d>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80661e:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  806625:	eb 0a                	jmp    806631 <tcp_close+0x13d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  806627:	be 00 00 00 00       	mov    $0x0,%esi
    pcb = NULL;
  80662c:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  806631:	85 db                	test   %ebx,%ebx
  806633:	74 0e                	je     806643 <tcp_close+0x14f>
  806635:	89 f0                	mov    %esi,%eax
  806637:	84 c0                	test   %al,%al
  806639:	75 08                	jne    806643 <tcp_close+0x14f>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80663b:	89 1c 24             	mov    %ebx,(%esp)
  80663e:	e8 1f 20 00 00       	call   808662 <tcp_output>
  }
  return err;
}
  806643:	89 f0                	mov    %esi,%eax
  806645:	83 c4 10             	add    $0x10,%esp
  806648:	5b                   	pop    %ebx
  806649:	5e                   	pop    %esi
  80664a:	5d                   	pop    %ebp
  80664b:	c3                   	ret    

0080664c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80664c:	55                   	push   %ebp
  80664d:	89 e5                	mov    %esp,%ebp
  80664f:	83 ec 18             	sub    $0x18,%esp
  806652:	8b 45 10             	mov    0x10(%ebp),%eax
  806655:	8a 55 14             	mov    0x14(%ebp),%dl
  arg = arg;
  if (p != NULL) {
  806658:	85 c0                	test   %eax,%eax
  80665a:	74 0c                	je     806668 <tcp_recv_null+0x1c>
    pbuf_free(p);
  80665c:	89 04 24             	mov    %eax,(%esp)
  80665f:	e8 11 e7 ff ff       	call   804d75 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  806664:	b0 00                	mov    $0x0,%al
  806666:	eb 13                	jmp    80667b <tcp_recv_null+0x2f>
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  806668:	84 d2                	test   %dl,%dl
  80666a:	75 0d                	jne    806679 <tcp_recv_null+0x2d>
    return tcp_close(pcb);
  80666c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80666f:	89 04 24             	mov    %eax,(%esp)
  806672:	e8 7d fe ff ff       	call   8064f4 <tcp_close>
  806677:	eb 02                	jmp    80667b <tcp_recv_null+0x2f>
  }
  return ERR_OK;
  806679:	b0 00                	mov    $0x0,%al
}
  80667b:	c9                   	leave  
  80667c:	c3                   	ret    

0080667d <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80667d:	55                   	push   %ebp
  80667e:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806680:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  806685:	03 05 0c 40 81 00    	add    0x81400c,%eax
  80668b:	a3 0c 40 81 00       	mov    %eax,0x81400c
  return iss;
}
  806690:	5d                   	pop    %ebp
  806691:	c3                   	ret    

00806692 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  806692:	55                   	push   %ebp
  806693:	89 e5                	mov    %esp,%ebp
  806695:	57                   	push   %edi
  806696:	56                   	push   %esi
  806697:	53                   	push   %ebx
  806698:	83 ec 2c             	sub    $0x2c,%esp
  80669b:	8a 45 08             	mov    0x8(%ebp),%al
  80669e:	88 45 e7             	mov    %al,-0x19(%ebp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8066a1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8066a8:	e8 dd e2 ff ff       	call   80498a <memp_malloc>
  8066ad:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8066af:	85 c0                	test   %eax,%eax
  8066b1:	0f 85 aa 00 00 00    	jne    806761 <tcp_alloc+0xcf>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8066b7:	a1 90 b2 b3 00       	mov    0xb3b290,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8066bc:	8b 1d 80 b2 b3 00    	mov    0xb3b280,%ebx
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8066c2:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8066c7:	be 00 00 00 00       	mov    $0x0,%esi
  8066cc:	eb 10                	jmp    8066de <tcp_alloc+0x4c>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8066ce:	89 da                	mov    %ebx,%edx
  8066d0:	2b 50 2c             	sub    0x2c(%eax),%edx
  8066d3:	39 ca                	cmp    %ecx,%edx
  8066d5:	72 04                	jb     8066db <tcp_alloc+0x49>
      inactivity = tcp_ticks - pcb->tmr;
  8066d7:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8066d9:	89 c6                	mov    %eax,%esi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8066db:	8b 40 0c             	mov    0xc(%eax),%eax
  8066de:	85 c0                	test   %eax,%eax
  8066e0:	75 ec                	jne    8066ce <tcp_alloc+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8066e2:	85 f6                	test   %esi,%esi
  8066e4:	74 08                	je     8066ee <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8066e6:	89 34 24             	mov    %esi,(%esp)
  8066e9:	e8 98 f8 ff ff       	call   805f86 <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8066ee:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8066f5:	e8 90 e2 ff ff       	call   80498a <memp_malloc>
  8066fa:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8066fc:	85 c0                	test   %eax,%eax
  8066fe:	75 61                	jne    806761 <tcp_alloc+0xcf>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806700:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806705:	8b 3d 80 b2 b3 00    	mov    0xb3b280,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  80670b:	b1 7f                	mov    $0x7f,%cl
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  80670d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  inactive = NULL;
  806714:	be 00 00 00 00       	mov    $0x0,%esi
  806719:	eb 20                	jmp    80673b <tcp_alloc+0xa9>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80671b:	8a 50 14             	mov    0x14(%eax),%dl
  80671e:	38 55 e7             	cmp    %dl,-0x19(%ebp)
  806721:	72 15                	jb     806738 <tcp_alloc+0xa6>
  806723:	38 ca                	cmp    %cl,%dl
  806725:	77 11                	ja     806738 <tcp_alloc+0xa6>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806727:	89 fb                	mov    %edi,%ebx
  806729:	2b 58 2c             	sub    0x2c(%eax),%ebx
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  80672c:	3b 5d e0             	cmp    -0x20(%ebp),%ebx
  80672f:	72 07                	jb     806738 <tcp_alloc+0xa6>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  806731:	88 d1                	mov    %dl,%cl
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  806733:	89 5d e0             	mov    %ebx,-0x20(%ebp)
      inactive = pcb;
  806736:	89 c6                	mov    %eax,%esi
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806738:	8b 40 0c             	mov    0xc(%eax),%eax
  80673b:	85 c0                	test   %eax,%eax
  80673d:	75 dc                	jne    80671b <tcp_alloc+0x89>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80673f:	85 f6                	test   %esi,%esi
  806741:	74 08                	je     80674b <tcp_alloc+0xb9>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806743:	89 34 24             	mov    %esi,(%esp)
  806746:	e8 3b f8 ff ff       	call   805f86 <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80674b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806752:	e8 33 e2 ff ff       	call   80498a <memp_malloc>
  806757:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  806759:	85 c0                	test   %eax,%eax
  80675b:	0f 84 9b 00 00 00    	je     8067fc <tcp_alloc+0x16a>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806761:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  806768:	00 
  806769:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806770:	00 
  806771:	89 1c 24             	mov    %ebx,(%esp)
  806774:	e8 d1 8e 00 00       	call   80f64a <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806779:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80677d:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  806783:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806789:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80678f:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  806795:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806799:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80679d:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8067a3:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8067a9:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8067af:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8067b5:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8067bb:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  8067c1:	e8 b7 fe ff ff       	call   80667d <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8067c6:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  8067c9:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  8067cc:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  8067cf:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  8067d2:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  8067d5:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  8067da:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  8067dd:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8067e1:	c7 83 88 00 00 00 4c 	movl   $0x80664c,0x88(%ebx)
  8067e8:	66 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8067eb:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8067f2:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8067f5:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  8067fc:	89 d8                	mov    %ebx,%eax
  8067fe:	83 c4 2c             	add    $0x2c,%esp
  806801:	5b                   	pop    %ebx
  806802:	5e                   	pop    %esi
  806803:	5f                   	pop    %edi
  806804:	5d                   	pop    %ebp
  806805:	c3                   	ret    

00806806 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  806806:	55                   	push   %ebp
  806807:	89 e5                	mov    %esp,%ebp
  806809:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80680c:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  806813:	e8 7a fe ff ff       	call   806692 <tcp_alloc>
}
  806818:	c9                   	leave  
  806819:	c3                   	ret    

0080681a <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80681a:	55                   	push   %ebp
  80681b:	89 e5                	mov    %esp,%ebp
  80681d:	53                   	push   %ebx
  80681e:	83 ec 14             	sub    $0x14,%esp
  806821:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806824:	8b 45 0c             	mov    0xc(%ebp),%eax
  806827:	89 04 24             	mov    %eax,(%esp)
  80682a:	e8 d5 01 00 00       	call   806a04 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80682f:	85 c0                	test   %eax,%eax
  806831:	74 12                	je     806845 <tcp_eff_send_mss+0x2b>
  806833:	8b 40 2c             	mov    0x2c(%eax),%eax
  806836:	66 85 c0             	test   %ax,%ax
  806839:	74 0a                	je     806845 <tcp_eff_send_mss+0x2b>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80683b:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80683e:	66 39 c3             	cmp    %ax,%bx
  806841:	76 02                	jbe    806845 <tcp_eff_send_mss+0x2b>
  806843:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
}
  806845:	89 d8                	mov    %ebx,%eax
  806847:	83 c4 14             	add    $0x14,%esp
  80684a:	5b                   	pop    %ebx
  80684b:	5d                   	pop    %ebp
  80684c:	c3                   	ret    

0080684d <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80684d:	55                   	push   %ebp
  80684e:	89 e5                	mov    %esp,%ebp
  806850:	56                   	push   %esi
  806851:	53                   	push   %ebx
  806852:	83 ec 30             	sub    $0x30,%esp
  806855:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806858:	8b 75 0c             	mov    0xc(%ebp),%esi
  80685b:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80685e:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806862:	74 1c                	je     806880 <tcp_connect+0x33>
  806864:	c7 44 24 08 10 1a 81 	movl   $0x811a10,0x8(%esp)
  80686b:	00 
  80686c:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  806873:	00 
  806874:	c7 04 24 42 1a 81 00 	movl   $0x811a42,(%esp)
  80687b:	e8 f8 85 00 00       	call   80ee78 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806880:	85 f6                	test   %esi,%esi
  806882:	0f 84 28 01 00 00    	je     8069b0 <tcp_connect+0x163>
    pcb->remote_ip = *ipaddr;
  806888:	8b 16                	mov    (%esi),%edx
  80688a:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80688d:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806891:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806896:	75 09                	jne    8068a1 <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  806898:	e8 62 f0 ff ff       	call   8058ff <tcp_new_port>
  80689d:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  8068a1:	e8 d7 fd ff ff       	call   80667d <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8068a6:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8068ad:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8068b0:	48                   	dec    %eax
  8068b1:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8068b4:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8068b7:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8068bd:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8068c3:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8068c9:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8068cf:	89 74 24 04          	mov    %esi,0x4(%esp)
  8068d3:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8068da:	e8 3b ff ff ff       	call   80681a <tcp_eff_send_mss>
  8068df:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8068e3:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8068e9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8068ec:	d1 e0                	shl    %eax
  8068ee:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8068f2:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8068f9:	8b 45 14             	mov    0x14(%ebp),%eax
  8068fc:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806902:	8b 15 8c b2 b3 00    	mov    0xb3b28c,%edx
  806908:	39 da                	cmp    %ebx,%edx
  80690a:	75 0a                	jne    806916 <tcp_connect+0xc9>
  80690c:	8b 42 0c             	mov    0xc(%edx),%eax
  80690f:	a3 8c b2 b3 00       	mov    %eax,0xb3b28c
  806914:	eb 31                	jmp    806947 <tcp_connect+0xfa>
  806916:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  80691c:	eb 1f                	jmp    80693d <tcp_connect+0xf0>
  80691e:	8b 42 0c             	mov    0xc(%edx),%eax
  806921:	85 c0                	test   %eax,%eax
  806923:	74 12                	je     806937 <tcp_connect+0xea>
  806925:	39 c3                	cmp    %eax,%ebx
  806927:	75 12                	jne    80693b <tcp_connect+0xee>
  806929:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  80692f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806932:	89 42 0c             	mov    %eax,0xc(%edx)
  806935:	eb 10                	jmp    806947 <tcp_connect+0xfa>
  806937:	89 c2                	mov    %eax,%edx
  806939:	eb 02                	jmp    80693d <tcp_connect+0xf0>
  80693b:	89 c2                	mov    %eax,%edx
  80693d:	85 d2                	test   %edx,%edx
  80693f:	75 dd                	jne    80691e <tcp_connect+0xd1>
  806941:	89 15 88 b2 b3 00    	mov    %edx,0xb3b288
  TCP_REG(&tcp_active_pcbs, pcb);
  806947:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80694c:	89 43 0c             	mov    %eax,0xc(%ebx)
  80694f:	89 1d 7c b2 b3 00    	mov    %ebx,0xb3b27c
  806955:	e8 f8 bb ff ff       	call   802552 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80695a:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  806961:	e8 37 13 00 00       	call   807c9d <htonl>
  806966:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806969:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  806970:	00 
  806971:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806974:	89 44 24 14          	mov    %eax,0x14(%esp)
  806978:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80697f:	00 
  806980:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  806987:	00 
  806988:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80698f:	00 
  806990:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806997:	00 
  806998:	89 1c 24             	mov    %ebx,(%esp)
  80699b:	e8 68 15 00 00       	call   807f08 <tcp_enqueue>
  8069a0:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8069a2:	84 c0                	test   %al,%al
  8069a4:	75 0f                	jne    8069b5 <tcp_connect+0x168>
    tcp_output(pcb);
  8069a6:	89 1c 24             	mov    %ebx,(%esp)
  8069a9:	e8 b4 1c 00 00       	call   808662 <tcp_output>
  8069ae:	eb 05                	jmp    8069b5 <tcp_connect+0x168>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  8069b0:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  8069b5:	89 f0                	mov    %esi,%eax
  8069b7:	83 c4 30             	add    $0x30,%esp
  8069ba:	5b                   	pop    %ebx
  8069bb:	5e                   	pop    %esi
  8069bc:	5d                   	pop    %ebp
  8069bd:	c3                   	ret    
	...

008069c0 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8069c0:	55                   	push   %ebp
  8069c1:	89 e5                	mov    %esp,%ebp
  8069c3:	8b 55 0c             	mov    0xc(%ebp),%edx
  u32_t addr2test;

  addr2test = addr->addr;
  8069c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8069c9:	8b 00                	mov    (%eax),%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8069cb:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8069ce:	83 f9 fd             	cmp    $0xfffffffd,%ecx
  8069d1:	77 21                	ja     8069f4 <ip_addr_isbroadcast+0x34>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8069d3:	f6 42 2e 02          	testb  $0x2,0x2e(%edx)
  8069d7:	74 1f                	je     8069f8 <ip_addr_isbroadcast+0x38>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8069d9:	8b 4a 04             	mov    0x4(%edx),%ecx
  8069dc:	39 c1                	cmp    %eax,%ecx
  8069de:	74 1c                	je     8069fc <ip_addr_isbroadcast+0x3c>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8069e0:	8b 52 08             	mov    0x8(%edx),%edx
  8069e3:	31 c1                	xor    %eax,%ecx
  8069e5:	85 d1                	test   %edx,%ecx
  8069e7:	75 17                	jne    806a00 <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8069e9:	f7 d2                	not    %edx
  8069eb:	21 d0                	and    %edx,%eax
 * 
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
  8069ed:	39 c2                	cmp    %eax,%edx
  8069ef:	0f 94 c0             	sete   %al
  8069f2:	eb 0e                	jmp    806a02 <ip_addr_isbroadcast+0x42>

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8069f4:	b0 01                	mov    $0x1,%al
  8069f6:	eb 0a                	jmp    806a02 <ip_addr_isbroadcast+0x42>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  8069f8:	b0 00                	mov    $0x0,%al
  8069fa:	eb 06                	jmp    806a02 <ip_addr_isbroadcast+0x42>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  8069fc:	b0 00                	mov    $0x0,%al
  8069fe:	eb 02                	jmp    806a02 <ip_addr_isbroadcast+0x42>
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806a00:	b0 00                	mov    $0x0,%al
}
  806a02:	5d                   	pop    %ebp
  806a03:	c3                   	ret    

00806a04 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806a04:	55                   	push   %ebp
  806a05:	89 e5                	mov    %esp,%ebp
  806a07:	56                   	push   %esi
  806a08:	53                   	push   %ebx
  806a09:	83 ec 10             	sub    $0x10,%esp
  806a0c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806a0f:	8b 1d 74 b2 b3 00    	mov    0xb3b274,%ebx
  806a15:	eb 18                	jmp    806a2f <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806a17:	89 1c 24             	mov    %ebx,(%esp)
  806a1a:	e8 62 e2 ff ff       	call   804c81 <netif_is_up>
  806a1f:	84 c0                	test   %al,%al
  806a21:	74 0a                	je     806a2d <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806a23:	8b 43 04             	mov    0x4(%ebx),%eax
  806a26:	33 06                	xor    (%esi),%eax
  806a28:	85 43 08             	test   %eax,0x8(%ebx)
  806a2b:	74 21                	je     806a4e <ip_route+0x4a>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806a2d:	8b 1b                	mov    (%ebx),%ebx
  806a2f:	85 db                	test   %ebx,%ebx
  806a31:	75 e4                	jne    806a17 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806a33:	a1 78 b2 b3 00       	mov    0xb3b278,%eax
  806a38:	85 c0                	test   %eax,%eax
  806a3a:	74 12                	je     806a4e <ip_route+0x4a>
  806a3c:	89 04 24             	mov    %eax,(%esp)
  806a3f:	e8 3d e2 ff ff       	call   804c81 <netif_is_up>
  806a44:	84 c0                	test   %al,%al
  806a46:	74 06                	je     806a4e <ip_route+0x4a>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806a48:	8b 1d 78 b2 b3 00    	mov    0xb3b278,%ebx
}
  806a4e:	89 d8                	mov    %ebx,%eax
  806a50:	83 c4 10             	add    $0x10,%esp
  806a53:	5b                   	pop    %ebx
  806a54:	5e                   	pop    %esi
  806a55:	5d                   	pop    %ebp
  806a56:	c3                   	ret    

00806a57 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806a57:	55                   	push   %ebp
  806a58:	89 e5                	mov    %esp,%ebp
  806a5a:	57                   	push   %edi
  806a5b:	56                   	push   %esi
  806a5c:	53                   	push   %ebx
  806a5d:	83 ec 2c             	sub    $0x2c,%esp
  806a60:	8b 7d 08             	mov    0x8(%ebp),%edi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806a63:	8b 77 04             	mov    0x4(%edi),%esi
  if (IPH_V(iphdr) != 4) {
  806a66:	0f b7 06             	movzwl (%esi),%eax
  806a69:	89 04 24             	mov    %eax,(%esp)
  806a6c:	e8 18 12 00 00       	call   807c89 <ntohs>
  806a71:	66 c1 e8 0c          	shr    $0xc,%ax
  806a75:	66 83 f8 04          	cmp    $0x4,%ax
  806a79:	74 0d                	je     806a88 <ip_input+0x31>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806a7b:	89 3c 24             	mov    %edi,(%esp)
  806a7e:	e8 f2 e2 ff ff       	call   804d75 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806a83:	e9 72 02 00 00       	jmp    806cfa <ip_input+0x2a3>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806a88:	0f b7 06             	movzwl (%esi),%eax
  806a8b:	89 04 24             	mov    %eax,(%esp)
  806a8e:	e8 f6 11 00 00       	call   807c89 <ntohs>
  806a93:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806a97:	83 e0 3c             	and    $0x3c,%eax
  806a9a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806a9e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806aa2:	89 04 24             	mov    %eax,(%esp)
  806aa5:	e8 df 11 00 00       	call   807c89 <ntohs>
  806aaa:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806aac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806aaf:	66 3b 47 0a          	cmp    0xa(%edi),%ax
  806ab3:	77 06                	ja     806abb <ip_input+0x64>
  806ab5:	66 3b 5f 08          	cmp    0x8(%edi),%bx
  806ab9:	76 0d                	jbe    806ac8 <ip_input+0x71>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806abb:	89 3c 24             	mov    %edi,(%esp)
  806abe:	e8 b2 e2 ff ff       	call   804d75 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806ac3:	e9 32 02 00 00       	jmp    806cfa <ip_input+0x2a3>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806ac8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806acc:	89 44 24 04          	mov    %eax,0x4(%esp)
  806ad0:	89 34 24             	mov    %esi,(%esp)
  806ad3:	e8 6f 10 00 00       	call   807b47 <inet_chksum>
  806ad8:	66 85 c0             	test   %ax,%ax
  806adb:	74 0d                	je     806aea <ip_input+0x93>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806add:	89 3c 24             	mov    %edi,(%esp)
  806ae0:	e8 90 e2 ff ff       	call   804d75 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806ae5:	e9 10 02 00 00       	jmp    806cfa <ip_input+0x2a3>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806aea:	0f b7 db             	movzwl %bx,%ebx
  806aed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806af1:	89 3c 24             	mov    %edi,(%esp)
  806af4:	e8 4e e3 ff ff       	call   804e47 <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806af9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806afc:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806b03:	8d 46 10             	lea    0x10(%esi),%eax
  806b06:	89 45 e0             	mov    %eax,-0x20(%ebp)
  806b09:	89 7d d8             	mov    %edi,-0x28(%ebp)
  806b0c:	89 f7                	mov    %esi,%edi
  806b0e:	be 01 00 00 00       	mov    $0x1,%esi
  806b13:	eb 05                	jmp    806b1a <ip_input+0xc3>
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  806b15:	be 00 00 00 00       	mov    $0x0,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806b1a:	89 1c 24             	mov    %ebx,(%esp)
  806b1d:	e8 5f e1 ff ff       	call   804c81 <netif_is_up>
  806b22:	84 c0                	test   %al,%al
  806b24:	74 24                	je     806b4a <ip_input+0xf3>
  806b26:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806b29:	74 1f                	je     806b4a <ip_input+0xf3>
  806b2b:	8b 43 04             	mov    0x4(%ebx),%eax
  806b2e:	85 c0                	test   %eax,%eax
  806b30:	74 18                	je     806b4a <ip_input+0xf3>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b32:	3b 47 10             	cmp    0x10(%edi),%eax
  806b35:	74 36                	je     806b6d <ip_input+0x116>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806b37:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806b3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b3e:	89 04 24             	mov    %eax,(%esp)
  806b41:	e8 7a fe ff ff       	call   8069c0 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b46:	84 c0                	test   %al,%al
  806b48:	75 2c                	jne    806b76 <ip_input+0x11f>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806b4a:	85 f6                	test   %esi,%esi
  806b4c:	74 08                	je     806b56 <ip_input+0xff>
        first = 0;
        netif = netif_list;
  806b4e:	8b 1d 74 b2 b3 00    	mov    0xb3b274,%ebx
  806b54:	eb 02                	jmp    806b58 <ip_input+0x101>
      } else {
        netif = netif->next;
  806b56:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806b58:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  806b5b:	75 05                	jne    806b62 <ip_input+0x10b>
        netif = netif->next;
  806b5d:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b60:	8b 18                	mov    (%eax),%ebx
      }
    } while(netif != NULL);
  806b62:	85 db                	test   %ebx,%ebx
  806b64:	75 af                	jne    806b15 <ip_input+0xbe>
  806b66:	89 fe                	mov    %edi,%esi
  806b68:	8b 7d d8             	mov    -0x28(%ebp),%edi
  806b6b:	eb 14                	jmp    806b81 <ip_input+0x12a>
  806b6d:	89 fe                	mov    %edi,%esi
  806b6f:	8b 7d d8             	mov    -0x28(%ebp),%edi
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806b72:	89 d8                	mov    %ebx,%eax
  806b74:	eb 07                	jmp    806b7d <ip_input+0x126>
  806b76:	89 fe                	mov    %edi,%esi
  806b78:	8b 7d d8             	mov    -0x28(%ebp),%edi
  806b7b:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806b7d:	85 c0                	test   %eax,%eax
  806b7f:	75 33                	jne    806bb4 <ip_input+0x15d>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806b81:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806b85:	89 04 24             	mov    %eax,(%esp)
  806b88:	e8 fc 10 00 00       	call   807c89 <ntohs>
  806b8d:	3c 11                	cmp    $0x11,%al
  806b8f:	75 1e                	jne    806baf <ip_input+0x158>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806b91:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806b95:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806b9a:	89 04 24             	mov    %eax,(%esp)
  806b9d:	e8 e7 10 00 00       	call   807c89 <ntohs>
  806ba2:	bb 00 00 00 00       	mov    $0x0,%ebx
  806ba7:	66 83 f8 44          	cmp    $0x44,%ax
  806bab:	75 07                	jne    806bb4 <ip_input+0x15d>
  806bad:	eb 51                	jmp    806c00 <ip_input+0x1a9>
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806baf:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  806bb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  806bbb:	8d 46 0c             	lea    0xc(%esi),%eax
  806bbe:	89 04 24             	mov    %eax,(%esp)
  806bc1:	e8 fa fd ff ff       	call   8069c0 <ip_addr_isbroadcast>
  806bc6:	84 c0                	test   %al,%al
  806bc8:	75 29                	jne    806bf3 <ip_input+0x19c>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806bca:	8b 46 0c             	mov    0xc(%esi),%eax
  806bcd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806bd0:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806bd7:	e8 17 13 00 00       	call   807ef3 <ntohl>
  806bdc:	23 45 e4             	and    -0x1c(%ebp),%eax
  806bdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806be2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806be9:	e8 05 13 00 00       	call   807ef3 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806bee:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  806bf1:	75 10                	jne    806c03 <ip_input+0x1ac>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806bf3:	89 3c 24             	mov    %edi,(%esp)
  806bf6:	e8 7a e1 ff ff       	call   804d75 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806bfb:	e9 fa 00 00 00       	jmp    806cfa <ip_input+0x2a3>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806c00:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806c03:	85 db                	test   %ebx,%ebx
  806c05:	75 0d                	jne    806c14 <ip_input+0x1bd>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806c07:	89 3c 24             	mov    %edi,(%esp)
  806c0a:	e8 66 e1 ff ff       	call   804d75 <pbuf_free>
    return ERR_OK;
  806c0f:	e9 e6 00 00 00       	jmp    806cfa <ip_input+0x2a3>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806c14:	66 8b 5e 06          	mov    0x6(%esi),%bx
  806c18:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806c1f:	e8 59 10 00 00       	call   807c7d <htons>
  806c24:	66 85 d8             	test   %bx,%ax
  806c27:	74 15                	je     806c3e <ip_input+0x1e7>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806c29:	89 3c 24             	mov    %edi,(%esp)
  806c2c:	e8 03 05 00 00       	call   807134 <ip_reass>
  806c31:	89 c7                	mov    %eax,%edi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806c33:	85 c0                	test   %eax,%eax
  806c35:	0f 84 bf 00 00 00    	je     806cfa <ip_input+0x2a3>
      return ERR_OK;
    }
    iphdr = p->payload;
  806c3b:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806c3e:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c41:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c45:	89 3c 24             	mov    %edi,(%esp)
  806c48:	e8 a3 79 00 00       	call   80e5f0 <raw_input>
  806c4d:	84 c0                	test   %al,%al
  806c4f:	0f 85 a5 00 00 00    	jne    806cfa <ip_input+0x2a3>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806c55:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806c59:	89 04 24             	mov    %eax,(%esp)
  806c5c:	e8 28 10 00 00       	call   807c89 <ntohs>
  806c61:	0f b6 c0             	movzbl %al,%eax
  806c64:	83 f8 06             	cmp    $0x6,%eax
  806c67:	74 1d                	je     806c86 <ip_input+0x22f>
  806c69:	83 f8 11             	cmp    $0x11,%eax
  806c6c:	74 07                	je     806c75 <ip_input+0x21e>
  806c6e:	83 f8 01             	cmp    $0x1,%eax
  806c71:	75 35                	jne    806ca8 <ip_input+0x251>
  806c73:	eb 22                	jmp    806c97 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806c75:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c78:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c7c:	89 3c 24             	mov    %edi,(%esp)
  806c7f:	e8 2c 23 00 00       	call   808fb0 <udp_input>
      break;
  806c84:	eb 74                	jmp    806cfa <ip_input+0x2a3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  806c86:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c89:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c8d:	89 3c 24             	mov    %edi,(%esp)
  806c90:	e8 2c 6c 00 00       	call   80d8c1 <tcp_input>
      break;
  806c95:	eb 63                	jmp    806cfa <ip_input+0x2a3>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806c97:	8b 45 0c             	mov    0xc(%ebp),%eax
  806c9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  806c9e:	89 3c 24             	mov    %edi,(%esp)
  806ca1:	e8 f2 7b 00 00       	call   80e898 <icmp_input>
      break;
  806ca6:	eb 52                	jmp    806cfa <ip_input+0x2a3>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806ca8:	8b 45 0c             	mov    0xc(%ebp),%eax
  806cab:	89 44 24 04          	mov    %eax,0x4(%esp)
  806caf:	8d 46 10             	lea    0x10(%esi),%eax
  806cb2:	89 04 24             	mov    %eax,(%esp)
  806cb5:	e8 06 fd ff ff       	call   8069c0 <ip_addr_isbroadcast>
  806cba:	84 c0                	test   %al,%al
  806cbc:	75 34                	jne    806cf2 <ip_input+0x29b>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806cbe:	8b 5e 10             	mov    0x10(%esi),%ebx
  806cc1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806cc8:	e8 26 12 00 00       	call   807ef3 <ntohl>
  806ccd:	21 c3                	and    %eax,%ebx
  806ccf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806cd6:	e8 18 12 00 00       	call   807ef3 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806cdb:	39 c3                	cmp    %eax,%ebx
  806cdd:	74 13                	je     806cf2 <ip_input+0x29b>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806cdf:	89 77 04             	mov    %esi,0x4(%edi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806ce2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  806ce9:	00 
  806cea:	89 3c 24             	mov    %edi,(%esp)
  806ced:	e8 05 7f 00 00       	call   80ebf7 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806cf2:	89 3c 24             	mov    %edi,(%esp)
  806cf5:	e8 7b e0 ff ff       	call   804d75 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806cfa:	b0 00                	mov    $0x0,%al
  806cfc:	83 c4 2c             	add    $0x2c,%esp
  806cff:	5b                   	pop    %ebx
  806d00:	5e                   	pop    %esi
  806d01:	5f                   	pop    %edi
  806d02:	5d                   	pop    %ebp
  806d03:	c3                   	ret    

00806d04 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806d04:	55                   	push   %ebp
  806d05:	89 e5                	mov    %esp,%ebp
  806d07:	57                   	push   %edi
  806d08:	56                   	push   %esi
  806d09:	53                   	push   %ebx
  806d0a:	83 ec 3c             	sub    $0x3c,%esp
  806d0d:	8b 75 08             	mov    0x8(%ebp),%esi
  806d10:	8b 7d 10             	mov    0x10(%ebp),%edi
  806d13:	8a 45 14             	mov    0x14(%ebp),%al
  806d16:	88 45 d8             	mov    %al,-0x28(%ebp)
  806d19:	8a 55 18             	mov    0x18(%ebp),%dl
  806d1c:	88 55 d7             	mov    %dl,-0x29(%ebp)
  806d1f:	8a 45 1c             	mov    0x1c(%ebp),%al
  806d22:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806d25:	85 ff                	test   %edi,%edi
  806d27:	0f 84 18 01 00 00    	je     806e45 <ip_output_if+0x141>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806d2d:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806d34:	00 
  806d35:	89 34 24             	mov    %esi,(%esp)
  806d38:	e8 53 df ff ff       	call   804c90 <pbuf_header>
  806d3d:	84 c0                	test   %al,%al
  806d3f:	0f 85 3c 01 00 00    	jne    806e81 <ip_output_if+0x17d>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806d45:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806d48:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806d4d:	77 1c                	ja     806d6b <ip_output_if+0x67>
  806d4f:	c7 44 24 08 dc 1a 81 	movl   $0x811adc,0x8(%esp)
  806d56:	00 
  806d57:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806d5e:	00 
  806d5f:	c7 04 24 09 1b 81 00 	movl   $0x811b09,(%esp)
  806d66:	e8 0d 81 00 00       	call   80ee78 <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806d6b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806d6f:	89 04 24             	mov    %eax,(%esp)
  806d72:	e8 12 0f 00 00       	call   807c89 <ntohs>
  806d77:	25 ff 00 00 00       	and    $0xff,%eax
  806d7c:	8a 55 d8             	mov    -0x28(%ebp),%dl
  806d7f:	c1 e2 08             	shl    $0x8,%edx
  806d82:	09 d0                	or     %edx,%eax
  806d84:	0f b7 c0             	movzwl %ax,%eax
  806d87:	89 04 24             	mov    %eax,(%esp)
  806d8a:	e8 ee 0e 00 00       	call   807c7d <htons>
  806d8f:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806d93:	0f b7 c0             	movzwl %ax,%eax
  806d96:	89 04 24             	mov    %eax,(%esp)
  806d99:	e8 eb 0e 00 00       	call   807c89 <ntohs>
  806d9e:	25 00 ff 00 00       	and    $0xff00,%eax
  806da3:	0f b6 55 d6          	movzbl -0x2a(%ebp),%edx
  806da7:	09 d0                	or     %edx,%eax
  806da9:	0f b7 c0             	movzwl %ax,%eax
  806dac:	89 04 24             	mov    %eax,(%esp)
  806daf:	e8 c9 0e 00 00       	call   807c7d <htons>
  806db4:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806db8:	8b 07                	mov    (%edi),%eax
  806dba:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806dbd:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  806dc1:	80 cc 45             	or     $0x45,%ah
  806dc4:	89 04 24             	mov    %eax,(%esp)
  806dc7:	e8 b1 0e 00 00       	call   807c7d <htons>
  806dcc:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806dcf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806dd3:	89 04 24             	mov    %eax,(%esp)
  806dd6:	e8 a2 0e 00 00       	call   807c7d <htons>
  806ddb:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806ddf:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806de5:	0f b7 05 20 44 b3 00 	movzwl 0xb34420,%eax
  806dec:	89 04 24             	mov    %eax,(%esp)
  806def:	e8 89 0e 00 00       	call   807c7d <htons>
  806df4:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806df8:	66 ff 05 20 44 b3 00 	incw   0xb34420

    if (ip_addr_isany(src)) {
  806dff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806e03:	74 09                	je     806e0e <ip_output_if+0x10a>
  806e05:	8b 55 0c             	mov    0xc(%ebp),%edx
  806e08:	8b 02                	mov    (%edx),%eax
  806e0a:	85 c0                	test   %eax,%eax
  806e0c:	75 18                	jne    806e26 <ip_output_if+0x122>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806e0e:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806e12:	74 08                	je     806e1c <ip_output_if+0x118>
  806e14:	8b 55 20             	mov    0x20(%ebp),%edx
  806e17:	8b 42 04             	mov    0x4(%edx),%eax
  806e1a:	eb 05                	jmp    806e21 <ip_output_if+0x11d>
  806e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  806e21:	89 43 0c             	mov    %eax,0xc(%ebx)
  806e24:	eb 03                	jmp    806e29 <ip_output_if+0x125>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806e26:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806e29:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806e2f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806e36:	00 
  806e37:	89 1c 24             	mov    %ebx,(%esp)
  806e3a:	e8 08 0d 00 00       	call   807b47 <inet_chksum>
  806e3f:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806e43:	eb 06                	jmp    806e4b <ip_output_if+0x147>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806e45:	8b 7e 04             	mov    0x4(%esi),%edi
  806e48:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806e4b:	8b 55 20             	mov    0x20(%ebp),%edx
  806e4e:	8b 42 2c             	mov    0x2c(%edx),%eax
  806e51:	66 85 c0             	test   %ax,%ax
  806e54:	74 18                	je     806e6e <ip_output_if+0x16a>
  806e56:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806e5a:	73 12                	jae    806e6e <ip_output_if+0x16a>
    return ip_frag(p,netif,dest);
  806e5c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806e60:	89 54 24 04          	mov    %edx,0x4(%esp)
  806e64:	89 34 24             	mov    %esi,(%esp)
  806e67:	e8 21 08 00 00       	call   80768d <ip_frag>
  806e6c:	eb 15                	jmp    806e83 <ip_output_if+0x17f>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806e6e:	89 7c 24 08          	mov    %edi,0x8(%esp)
  806e72:	89 74 24 04          	mov    %esi,0x4(%esp)
  806e76:	8b 45 20             	mov    0x20(%ebp),%eax
  806e79:	89 04 24             	mov    %eax,(%esp)
  806e7c:	ff 50 14             	call   *0x14(%eax)
  806e7f:	eb 02                	jmp    806e83 <ip_output_if+0x17f>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806e81:	b0 fe                	mov    $0xfe,%al
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806e83:	83 c4 3c             	add    $0x3c,%esp
  806e86:	5b                   	pop    %ebx
  806e87:	5e                   	pop    %esi
  806e88:	5f                   	pop    %edi
  806e89:	5d                   	pop    %ebp
  806e8a:	c3                   	ret    

00806e8b <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806e8b:	55                   	push   %ebp
  806e8c:	89 e5                	mov    %esp,%ebp
  806e8e:	57                   	push   %edi
  806e8f:	56                   	push   %esi
  806e90:	53                   	push   %ebx
  806e91:	83 ec 3c             	sub    $0x3c,%esp
  806e94:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806e97:	8a 45 14             	mov    0x14(%ebp),%al
  806e9a:	88 45 e7             	mov    %al,-0x19(%ebp)
  806e9d:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  806ea1:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806ea5:	89 1c 24             	mov    %ebx,(%esp)
  806ea8:	e8 57 fb ff ff       	call   806a04 <ip_route>
  806ead:	85 c0                	test   %eax,%eax
  806eaf:	74 38                	je     806ee9 <ip_output+0x5e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806eb1:	89 44 24 18          	mov    %eax,0x18(%esp)
  806eb5:	81 e6 ff 00 00 00    	and    $0xff,%esi
  806ebb:	89 74 24 14          	mov    %esi,0x14(%esp)
  806ebf:	81 e7 ff 00 00 00    	and    $0xff,%edi
  806ec5:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806ec9:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  806ecd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  806ed1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  806ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
  806ed8:	89 44 24 04          	mov    %eax,0x4(%esp)
  806edc:	8b 45 08             	mov    0x8(%ebp),%eax
  806edf:	89 04 24             	mov    %eax,(%esp)
  806ee2:	e8 1d fe ff ff       	call   806d04 <ip_output_if>
  806ee7:	eb 02                	jmp    806eeb <ip_output+0x60>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  806ee9:	b0 fc                	mov    $0xfc,%al
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806eeb:	83 c4 3c             	add    $0x3c,%esp
  806eee:	5b                   	pop    %ebx
  806eef:	5e                   	pop    %esi
  806ef0:	5f                   	pop    %edi
  806ef1:	5d                   	pop    %ebp
  806ef2:	c3                   	ret    
	...

00806ef4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806ef4:	55                   	push   %ebp
  806ef5:	89 e5                	mov    %esp,%ebp
  806ef7:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806efa:	8b 0d 40 44 b3 00    	mov    0xb34440,%ecx
  806f00:	39 c1                	cmp    %eax,%ecx
  806f02:	75 0a                	jne    806f0e <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  806f04:	8b 11                	mov    (%ecx),%edx
  806f06:	89 15 40 44 b3 00    	mov    %edx,0xb34440
  806f0c:	eb 24                	jmp    806f32 <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806f0e:	85 d2                	test   %edx,%edx
  806f10:	75 1c                	jne    806f2e <ip_reass_dequeue_datagram+0x3a>
  806f12:	c7 44 24 08 21 1b 81 	movl   $0x811b21,0x8(%esp)
  806f19:	00 
  806f1a:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  806f21:	00 
  806f22:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  806f29:	e8 4a 7f 00 00       	call   80ee78 <_panic>
    prev->next = ipr->next;
  806f2e:	8b 08                	mov    (%eax),%ecx
  806f30:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806f32:	89 44 24 04          	mov    %eax,0x4(%esp)
  806f36:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  806f3d:	e8 a8 da ff ff       	call   8049ea <memp_free>
}
  806f42:	c9                   	leave  
  806f43:	c3                   	ret    

00806f44 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806f44:	55                   	push   %ebp
  806f45:	89 e5                	mov    %esp,%ebp
  806f47:	57                   	push   %edi
  806f48:	56                   	push   %esi
  806f49:	53                   	push   %ebx
  806f4a:	83 ec 2c             	sub    $0x2c,%esp
  806f4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806f50:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  806f53:	39 c2                	cmp    %eax,%edx
  806f55:	75 1c                	jne    806f73 <ip_reass_free_complete_datagram+0x2f>
  806f57:	c7 44 24 08 57 1b 81 	movl   $0x811b57,0x8(%esp)
  806f5e:	00 
  806f5f:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  806f66:	00 
  806f67:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  806f6e:	e8 05 7f 00 00       	call   80ee78 <_panic>
  if (prev != NULL) {
  806f73:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  806f77:	74 26                	je     806f9f <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806f79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806f7c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f7f:	39 02                	cmp    %eax,(%edx)
  806f81:	74 1c                	je     806f9f <ip_reass_free_complete_datagram+0x5b>
  806f83:	c7 44 24 08 63 1b 81 	movl   $0x811b63,0x8(%esp)
  806f8a:	00 
  806f8b:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  806f92:	00 
  806f93:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  806f9a:	e8 d9 7e 00 00       	call   80ee78 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806f9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806fa2:	8b 58 04             	mov    0x4(%eax),%ebx
  806fa5:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  806fa8:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806fad:	75 49                	jne    806ff8 <ip_reass_free_complete_datagram+0xb4>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806faf:	8b 00                	mov    (%eax),%eax
  806fb1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806fb4:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806fb7:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  806fbe:	00 
  806fbf:	89 d0                	mov    %edx,%eax
  806fc1:	83 c0 08             	add    $0x8,%eax
  806fc4:	89 44 24 04          	mov    %eax,0x4(%esp)
  806fc8:	8b 43 04             	mov    0x4(%ebx),%eax
  806fcb:	89 04 24             	mov    %eax,(%esp)
  806fce:	e8 2b 87 00 00       	call   80f6fe <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806fd3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806fda:	00 
  806fdb:	89 1c 24             	mov    %ebx,(%esp)
  806fde:	e8 25 7d 00 00       	call   80ed08 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806fe3:	89 1c 24             	mov    %ebx,(%esp)
  806fe6:	e8 11 e2 ff ff       	call   8051fc <pbuf_clen>
  806feb:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  806fee:	89 1c 24             	mov    %ebx,(%esp)
  806ff1:	e8 7f dd ff ff       	call   804d75 <pbuf_free>
  806ff6:	eb 05                	jmp    806ffd <ip_reass_free_complete_datagram+0xb9>
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806ff8:	bf 00 00 00 00       	mov    $0x0,%edi
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806ffd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807000:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  807003:	eb 1c                	jmp    807021 <ip_reass_free_complete_datagram+0xdd>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  807005:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  807008:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  80700a:	89 1c 24             	mov    %ebx,(%esp)
  80700d:	e8 ea e1 ff ff       	call   8051fc <pbuf_clen>
  807012:	0f b6 c0             	movzbl %al,%eax
  807015:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  807017:	89 1c 24             	mov    %ebx,(%esp)
  80701a:	e8 56 dd ff ff       	call   804d75 <pbuf_free>
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80701f:	89 f3                	mov    %esi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  807021:	85 db                	test   %ebx,%ebx
  807023:	75 e0                	jne    807005 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  807025:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807028:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80702b:	e8 c4 fe ff ff       	call   806ef4 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  807030:	66 a1 44 44 b3 00    	mov    0xb34444,%ax
  807036:	0f b7 d0             	movzwl %ax,%edx
  807039:	39 fa                	cmp    %edi,%edx
  80703b:	7d 1c                	jge    807059 <ip_reass_free_complete_datagram+0x115>
  80703d:	c7 44 24 08 75 1b 81 	movl   $0x811b75,0x8(%esp)
  807044:	00 
  807045:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80704c:	00 
  80704d:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  807054:	e8 1f 7e 00 00       	call   80ee78 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  807059:	66 29 f8             	sub    %di,%ax
  80705c:	66 a3 44 44 b3 00    	mov    %ax,0xb34444

  return pbufs_freed;
}
  807062:	89 f8                	mov    %edi,%eax
  807064:	83 c4 2c             	add    $0x2c,%esp
  807067:	5b                   	pop    %ebx
  807068:	5e                   	pop    %esi
  807069:	5f                   	pop    %edi
  80706a:	5d                   	pop    %ebp
  80706b:	c3                   	ret    

0080706c <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80706c:	55                   	push   %ebp
  80706d:	89 e5                	mov    %esp,%ebp
  80706f:	57                   	push   %edi
  807070:	56                   	push   %esi
  807071:	53                   	push   %ebx
  807072:	83 ec 1c             	sub    $0x1c,%esp
  807075:	89 c3                	mov    %eax,%ebx
  807077:	89 55 e0             	mov    %edx,-0x20(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  80707a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  807081:	8b 0d 40 44 b3 00    	mov    0xb34440,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  807087:	be 00 00 00 00       	mov    $0x0,%esi

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  80708c:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  807091:	b8 00 00 00 00       	mov    $0x0,%eax
  807096:	89 55 dc             	mov    %edx,-0x24(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  807099:	eb 39                	jmp    8070d4 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80709b:	8b 53 0c             	mov    0xc(%ebx),%edx
  80709e:	39 51 14             	cmp    %edx,0x14(%ecx)
  8070a1:	75 11                	jne    8070b4 <ip_reass_remove_oldest_datagram+0x48>
  8070a3:	8b 7b 10             	mov    0x10(%ebx),%edi
  8070a6:	39 79 18             	cmp    %edi,0x18(%ecx)
  8070a9:	75 09                	jne    8070b4 <ip_reass_remove_oldest_datagram+0x48>
  8070ab:	8b 53 04             	mov    0x4(%ebx),%edx
  8070ae:	66 39 51 0c          	cmp    %dx,0xc(%ecx)
  8070b2:	74 15                	je     8070c9 <ip_reass_remove_oldest_datagram+0x5d>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8070b4:	46                   	inc    %esi
        if (oldest == NULL) {
  8070b5:	85 c0                	test   %eax,%eax
  8070b7:	74 0a                	je     8070c3 <ip_reass_remove_oldest_datagram+0x57>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  8070b9:	8a 50 1f             	mov    0x1f(%eax),%dl
  8070bc:	38 51 1f             	cmp    %dl,0x1f(%ecx)
  8070bf:	76 06                	jbe    8070c7 <ip_reass_remove_oldest_datagram+0x5b>
  8070c1:	eb 06                	jmp    8070c9 <ip_reass_remove_oldest_datagram+0x5d>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  8070c3:	89 c8                	mov    %ecx,%eax
  8070c5:	eb 02                	jmp    8070c9 <ip_reass_remove_oldest_datagram+0x5d>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  8070c7:	89 c8                	mov    %ecx,%eax
        }
      }
      if (r->next != NULL) {
  8070c9:	8b 39                	mov    (%ecx),%edi
  8070cb:	85 ff                	test   %edi,%edi
  8070cd:	74 03                	je     8070d2 <ip_reass_remove_oldest_datagram+0x66>
        prev = r;
  8070cf:	89 4d dc             	mov    %ecx,-0x24(%ebp)
      }
      r = r->next;
  8070d2:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8070d4:	85 c9                	test   %ecx,%ecx
  8070d6:	75 c3                	jne    80709b <ip_reass_remove_oldest_datagram+0x2f>
  8070d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8070db:	85 c0                	test   %eax,%eax
  8070dd:	74 08                	je     8070e7 <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  8070df:	e8 60 fe ff ff       	call   806f44 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  8070e4:	01 45 e4             	add    %eax,-0x1c(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8070e7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8070ea:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8070ed:	7d 05                	jge    8070f4 <ip_reass_remove_oldest_datagram+0x88>
  8070ef:	83 fe 01             	cmp    $0x1,%esi
  8070f2:	7f 8d                	jg     807081 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  8070f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070f7:	83 c4 1c             	add    $0x1c,%esp
  8070fa:	5b                   	pop    %ebx
  8070fb:	5e                   	pop    %esi
  8070fc:	5f                   	pop    %edi
  8070fd:	5d                   	pop    %ebp
  8070fe:	c3                   	ret    

008070ff <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  8070ff:	55                   	push   %ebp
  807100:	89 e5                	mov    %esp,%ebp
  807102:	56                   	push   %esi
  807103:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  807104:	a1 40 44 b3 00       	mov    0xb34440,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  807109:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  80710e:	eb 1c                	jmp    80712c <ip_reass_tmr+0x2d>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  807110:	8a 50 1f             	mov    0x1f(%eax),%dl
  807113:	84 d2                	test   %dl,%dl
  807115:	74 0a                	je     807121 <ip_reass_tmr+0x22>
      r->timer--;
  807117:	4a                   	dec    %edx
  807118:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  80711b:	89 c3                	mov    %eax,%ebx
      r = r->next;
  80711d:	8b 00                	mov    (%eax),%eax
  80711f:	eb 0b                	jmp    80712c <ip_reass_tmr+0x2d>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  807121:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  807123:	89 da                	mov    %ebx,%edx
  807125:	e8 1a fe ff ff       	call   806f44 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80712a:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80712c:	85 c0                	test   %eax,%eax
  80712e:	75 e0                	jne    807110 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  807130:	5b                   	pop    %ebx
  807131:	5e                   	pop    %esi
  807132:	5d                   	pop    %ebp
  807133:	c3                   	ret    

00807134 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  807134:	55                   	push   %ebp
  807135:	89 e5                	mov    %esp,%ebp
  807137:	57                   	push   %edi
  807138:	56                   	push   %esi
  807139:	53                   	push   %ebx
  80713a:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  80713d:	8b 45 08             	mov    0x8(%ebp),%eax
  807140:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  807143:	0f b7 03             	movzwl (%ebx),%eax
  807146:	89 04 24             	mov    %eax,(%esp)
  807149:	e8 3b 0b 00 00       	call   807c89 <ntohs>
  80714e:	c1 e8 06             	shr    $0x6,%eax
  807151:	83 e0 3c             	and    $0x3c,%eax
  807154:	83 f8 14             	cmp    $0x14,%eax
  807157:	0f 85 67 04 00 00    	jne    8075c4 <ip_reass+0x490>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80715d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807161:	89 04 24             	mov    %eax,(%esp)
  807164:	e8 20 0b 00 00       	call   807c89 <ntohs>
  807169:	89 c7                	mov    %eax,%edi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80716b:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80716f:	89 04 24             	mov    %eax,(%esp)
  807172:	e8 12 0b 00 00       	call   807c89 <ntohs>
  807177:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80717b:	0f b7 03             	movzwl (%ebx),%eax
  80717e:	89 04 24             	mov    %eax,(%esp)
  807181:	e8 03 0b 00 00       	call   807c89 <ntohs>
  807186:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  80718a:	8b 55 08             	mov    0x8(%ebp),%edx
  80718d:	89 14 24             	mov    %edx,(%esp)
  807190:	e8 67 e0 ff ff       	call   8051fc <pbuf_clen>
  807195:	88 45 e0             	mov    %al,-0x20(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  807198:	0f b6 c8             	movzbl %al,%ecx
  80719b:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80719e:	0f b7 05 44 44 b3 00 	movzwl 0xb34444,%eax
  8071a5:	01 c8                	add    %ecx,%eax
  8071a7:	83 f8 0a             	cmp    $0xa,%eax
  8071aa:	7e 24                	jle    8071d0 <ip_reass+0x9c>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8071ac:	89 ca                	mov    %ecx,%edx
  8071ae:	89 d8                	mov    %ebx,%eax
  8071b0:	e8 b7 fe ff ff       	call   80706c <ip_reass_remove_oldest_datagram>
  8071b5:	85 c0                	test   %eax,%eax
  8071b7:	0f 84 07 04 00 00    	je     8075c4 <ip_reass+0x490>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  8071bd:	0f b7 05 44 44 b3 00 	movzwl 0xb34444,%eax
  8071c4:	03 45 dc             	add    -0x24(%ebp),%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8071c7:	83 f8 0a             	cmp    $0xa,%eax
  8071ca:	0f 8f f4 03 00 00    	jg     8075c4 <ip_reass+0x490>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8071d0:	8b 35 40 44 b3 00    	mov    0xb34440,%esi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  8071d6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8071dd:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8071e2:	eb 21                	jmp    807205 <ip_reass+0xd1>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  8071e4:	8b 53 0c             	mov    0xc(%ebx),%edx
  8071e7:	39 56 14             	cmp    %edx,0x14(%esi)
  8071ea:	75 15                	jne    807201 <ip_reass+0xcd>
  8071ec:	8b 4b 10             	mov    0x10(%ebx),%ecx
  8071ef:	39 4e 18             	cmp    %ecx,0x18(%esi)
  8071f2:	75 0d                	jne    807201 <ip_reass+0xcd>
  8071f4:	8b 53 04             	mov    0x4(%ebx),%edx
  8071f7:	66 39 56 0c          	cmp    %dx,0xc(%esi)
  8071fb:	0f 84 88 00 00 00    	je     807289 <ip_reass+0x155>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  807201:	89 f0                	mov    %esi,%eax
  807203:	8b 36                	mov    (%esi),%esi
  807205:	85 f6                	test   %esi,%esi
  807207:	75 db                	jne    8071e4 <ip_reass+0xb0>
  807209:	89 45 d8             	mov    %eax,-0x28(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80720c:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807213:	e8 72 d7 ff ff       	call   80498a <memp_malloc>
  807218:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  80721a:	85 c0                	test   %eax,%eax
  80721c:	75 29                	jne    807247 <ip_reass+0x113>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80721e:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807221:	89 d8                	mov    %ebx,%eax
  807223:	e8 44 fe ff ff       	call   80706c <ip_reass_remove_oldest_datagram>
  807228:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  80722b:	0f 8f 93 03 00 00    	jg     8075c4 <ip_reass+0x490>
      ipr = memp_malloc(MEMP_REASSDATA);
  807231:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807238:	e8 4d d7 ff ff       	call   80498a <memp_malloc>
  80723d:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80723f:	85 c0                	test   %eax,%eax
  807241:	0f 84 7d 03 00 00    	je     8075c4 <ip_reass+0x490>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807247:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80724e:	00 
  80724f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807256:	00 
  807257:	89 34 24             	mov    %esi,(%esp)
  80725a:	e8 eb 83 00 00       	call   80f64a <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80725f:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  807263:	a1 40 44 b3 00       	mov    0xb34440,%eax
  807268:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80726a:	89 35 40 44 b3 00    	mov    %esi,0xb34440
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  807270:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807277:	00 
  807278:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80727c:	8d 46 08             	lea    0x8(%esi),%eax
  80727f:	89 04 24             	mov    %eax,(%esp)
  807282:	e8 77 84 00 00       	call   80f6fe <memcpy>
  807287:	eb 46                	jmp    8072cf <ip_reass+0x19b>
  807289:	89 45 d8             	mov    %eax,-0x28(%ebp)
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80728c:	89 75 dc             	mov    %esi,-0x24(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80728f:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807293:	89 04 24             	mov    %eax,(%esp)
  807296:	e8 ee 09 00 00       	call   807c89 <ntohs>
  80729b:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  8072a0:	75 2d                	jne    8072cf <ip_reass+0x19b>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8072a2:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  8072a6:	89 04 24             	mov    %eax,(%esp)
  8072a9:	e8 db 09 00 00       	call   807c89 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8072ae:	a9 ff 1f 00 00       	test   $0x1fff,%eax
  8072b3:	74 1a                	je     8072cf <ip_reass+0x19b>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  8072b5:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8072bc:	00 
  8072bd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8072c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8072c4:	83 c0 08             	add    $0x8,%eax
  8072c7:	89 04 24             	mov    %eax,(%esp)
  8072ca:	e8 2f 84 00 00       	call   80f6fe <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8072cf:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  8072d3:	66 01 05 44 44 b3 00 	add    %ax,0xb34444

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8072da:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8072de:	89 04 24             	mov    %eax,(%esp)
  8072e1:	e8 a3 09 00 00       	call   807c89 <ntohs>
  8072e6:	f6 c4 20             	test   $0x20,%ah
  8072e9:	75 1d                	jne    807308 <ip_reass+0x1d4>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8072eb:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8072ef:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  8072f2:	8d 04 f9             	lea    (%ecx,%edi,8),%eax
  8072f5:	8b 7d d0             	mov    -0x30(%ebp),%edi
  8072f8:	66 c1 ef 08          	shr    $0x8,%di
  8072fc:	83 e7 0f             	and    $0xf,%edi
  8072ff:	f7 df                	neg    %edi
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  807301:	8d 3c b8             	lea    (%eax,%edi,4),%edi
  807304:	66 89 7e 1c          	mov    %di,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  807308:	8b 45 08             	mov    0x8(%ebp),%eax
  80730b:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80730e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  807312:	89 04 24             	mov    %eax,(%esp)
  807315:	e8 6f 09 00 00       	call   807c89 <ntohs>
  80731a:	89 c7                	mov    %eax,%edi
  80731c:	0f b7 03             	movzwl (%ebx),%eax
  80731f:	89 04 24             	mov    %eax,(%esp)
  807322:	e8 62 09 00 00       	call   807c89 <ntohs>
  807327:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80732b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80732f:	89 04 24             	mov    %eax,(%esp)
  807332:	e8 52 09 00 00       	call   807c89 <ntohs>
  807337:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80733a:	8b 55 08             	mov    0x8(%ebp),%edx
  80733d:	8b 52 04             	mov    0x4(%edx),%edx
  807340:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  807343:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  807349:	66 89 42 04          	mov    %ax,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80734d:	01 c7                	add    %eax,%edi
  80734f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807352:	66 c1 ea 08          	shr    $0x8,%dx
  807356:	83 e2 0f             	and    $0xf,%edx
  807359:	f7 da                	neg    %edx
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  80735b:	8d 14 97             	lea    (%edi,%edx,4),%edx
  80735e:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
  807362:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807365:	66 89 51 06          	mov    %dx,0x6(%ecx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  807369:	8b 56 04             	mov    0x4(%esi),%edx
  80736c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80736f:	89 d3                	mov    %edx,%ebx
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  807371:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807376:	bf 00 00 00 00       	mov    $0x0,%edi
  80737b:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80737e:	89 ce                	mov    %ecx,%esi
  807380:	eb 71                	jmp    8073f3 <ip_reass+0x2bf>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807382:	8b 53 04             	mov    0x4(%ebx),%edx
    if (iprh->start < iprh_tmp->start) {
  807385:	8b 4a 04             	mov    0x4(%edx),%ecx
  807388:	66 39 c8             	cmp    %cx,%ax
  80738b:	73 40                	jae    8073cd <ip_reass+0x299>
  80738d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807390:	89 f1                	mov    %esi,%ecx
  807392:	8b 75 d0             	mov    -0x30(%ebp),%esi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  807395:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807398:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  80739a:	85 ff                	test   %edi,%edi
  80739c:	74 24                	je     8073c2 <ip_reass+0x28e>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80739e:	66 3b 47 06          	cmp    0x6(%edi),%ax
  8073a2:	0f 82 93 01 00 00    	jb     80753b <ip_reass+0x407>
  8073a8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8073ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8073ae:	66 3b 50 04          	cmp    0x4(%eax),%dx
  8073b2:	0f 87 83 01 00 00    	ja     80753b <ip_reass+0x407>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  8073b8:	8b 45 08             	mov    0x8(%ebp),%eax
  8073bb:	89 07                	mov    %eax,(%edi)
  8073bd:	e9 a2 00 00 00       	jmp    807464 <ip_reass+0x330>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  8073c2:	8b 55 08             	mov    0x8(%ebp),%edx
  8073c5:	89 56 04             	mov    %edx,0x4(%esi)
  8073c8:	e9 97 00 00 00       	jmp    807464 <ip_reass+0x330>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  8073cd:	66 39 c8             	cmp    %cx,%ax
  8073d0:	0f 84 65 01 00 00    	je     80753b <ip_reass+0x407>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8073d6:	66 3b 42 06          	cmp    0x6(%edx),%ax
  8073da:	0f 82 5b 01 00 00    	jb     80753b <ip_reass+0x407>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8073e0:	85 ff                	test   %edi,%edi
  8073e2:	74 0b                	je     8073ef <ip_reass+0x2bb>
        if (iprh_prev->end != iprh_tmp->start) {
  8073e4:	66 3b 4f 06          	cmp    0x6(%edi),%cx
  8073e8:	74 05                	je     8073ef <ip_reass+0x2bb>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  8073ea:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8073ef:	8b 1a                	mov    (%edx),%ebx
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8073f1:	89 d7                	mov    %edx,%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8073f3:	85 db                	test   %ebx,%ebx
  8073f5:	75 8b                	jne    807382 <ip_reass+0x24e>
  8073f7:	e9 09 02 00 00       	jmp    807605 <ip_reass+0x4d1>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8073fc:	66 8b 47 06          	mov    0x6(%edi),%ax
  807400:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807403:	66 3b 42 04          	cmp    0x4(%edx),%ax
  807407:	76 1c                	jbe    807425 <ip_reass+0x2f1>
  807409:	c7 44 24 08 90 1b 81 	movl   $0x811b90,0x8(%esp)
  807410:	00 
  807411:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  807418:	00 
  807419:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  807420:	e8 53 7a 00 00       	call   80ee78 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  807425:	8b 55 08             	mov    0x8(%ebp),%edx
  807428:	89 17                	mov    %edx,(%edi)
      if (iprh_prev->end != iprh->start) {
  80742a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80742d:	66 3b 42 04          	cmp    0x4(%edx),%ax
  807431:	75 2c                	jne    80745f <ip_reass+0x32b>
  807433:	eb 2f                	jmp    807464 <ip_reass+0x330>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807435:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807439:	74 1c                	je     807457 <ip_reass+0x323>
  80743b:	c7 44 24 08 bc 1b 81 	movl   $0x811bbc,0x8(%esp)
  807442:	00 
  807443:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80744a:	00 
  80744b:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  807452:	e8 21 7a 00 00       	call   80ee78 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807457:	8b 45 08             	mov    0x8(%ebp),%eax
  80745a:	89 46 04             	mov    %eax,0x4(%esi)
  80745d:	eb 05                	jmp    807464 <ip_reass+0x330>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
        valid = 0;
  80745f:	b9 00 00 00 00       	mov    $0x0,%ecx
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  807464:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  807468:	0f 84 6a 01 00 00    	je     8075d8 <ip_reass+0x4a4>
    /* and had no wholes so far */
    if (valid) {
  80746e:	85 c9                	test   %ecx,%ecx
  807470:	0f 84 6b 01 00 00    	je     8075e1 <ip_reass+0x4ad>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807476:	8b 4e 04             	mov    0x4(%esi),%ecx
  807479:	8b 59 04             	mov    0x4(%ecx),%ebx
  80747c:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  807481:	0f 85 63 01 00 00    	jne    8075ea <ip_reass+0x4b6>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807487:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80748a:	8b 10                	mov    (%eax),%edx
  80748c:	89 c7                	mov    %eax,%edi
  80748e:	eb 14                	jmp    8074a4 <ip_reass+0x370>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  807490:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  807493:	8b 50 04             	mov    0x4(%eax),%edx
  807496:	66 39 57 06          	cmp    %dx,0x6(%edi)
  80749a:	0f 85 53 01 00 00    	jne    8075f3 <ip_reass+0x4bf>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  8074a0:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  8074a2:	89 c7                	mov    %eax,%edi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  8074a4:	85 d2                	test   %edx,%edx
  8074a6:	75 e8                	jne    807490 <ip_reass+0x35c>
  8074a8:	e9 6a 01 00 00       	jmp    807617 <ip_reass+0x4e3>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8074ad:	c7 44 24 08 ae 1b 81 	movl   $0x811bae,0x8(%esp)
  8074b4:	00 
  8074b5:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  8074bc:	00 
  8074bd:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  8074c4:	e8 af 79 00 00       	call   80ee78 <_panic>
          LWIP_ASSERT("sanity check",
  8074c9:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  8074cc:	75 1c                	jne    8074ea <ip_reass+0x3b6>
  8074ce:	c7 44 24 08 ae 1b 81 	movl   $0x811bae,0x8(%esp)
  8074d5:	00 
  8074d6:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  8074dd:	00 
  8074de:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  8074e5:	e8 8e 79 00 00       	call   80ee78 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8074ea:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8074ed:	83 39 00             	cmpl   $0x0,(%ecx)
  8074f0:	74 1c                	je     80750e <ip_reass+0x3da>
  8074f2:	c7 44 24 08 f4 1b 81 	movl   $0x811bf4,0x8(%esp)
  8074f9:	00 
  8074fa:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  807501:	00 
  807502:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  807509:	e8 6a 79 00 00       	call   80ee78 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80750e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807511:	66 8b 42 06          	mov    0x6(%edx),%ax
  807515:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  807519:	0f 84 08 01 00 00    	je     807627 <ip_reass+0x4f3>
  80751f:	c7 44 24 08 18 1c 81 	movl   $0x811c18,0x8(%esp)
  807526:	00 
  807527:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80752e:	00 
  80752f:	c7 04 24 3a 1b 81 00 	movl   $0x811b3a,(%esp)
  807536:	e8 3d 79 00 00       	call   80ee78 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80753b:	66 8b 1d 44 44 b3 00 	mov    0xb34444,%bx
  807542:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807545:	89 0c 24             	mov    %ecx,(%esp)
  807548:	e8 af dc ff ff       	call   8051fc <pbuf_clen>
  80754d:	0f b6 c0             	movzbl %al,%eax
  807550:	66 29 c3             	sub    %ax,%bx
  807553:	66 89 1d 44 44 b3 00 	mov    %bx,0xb34444
  pbuf_free(new_p);
  80755a:	8b 45 08             	mov    0x8(%ebp),%eax
  80755d:	89 04 24             	mov    %eax,(%esp)
  807560:	e8 10 d8 ff ff       	call   804d75 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807565:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80756c:	e9 89 00 00 00       	jmp    8075fa <ip_reass+0x4c6>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  807571:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807574:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80757b:	ff 
  80757c:	89 3c 24             	mov    %edi,(%esp)
  80757f:	e8 0c d7 ff ff       	call   804c90 <pbuf_header>
      pbuf_cat(p, r);
  807584:	89 7c 24 04          	mov    %edi,0x4(%esp)
  807588:	89 34 24             	mov    %esi,(%esp)
  80758b:	e8 8f dc ff ff       	call   80521f <pbuf_cat>
      r = iprh->next_pbuf;
  807590:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807592:	85 ff                	test   %edi,%edi
  807594:	75 db                	jne    807571 <ip_reass+0x43d>
  807596:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807599:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80759c:	89 f0                	mov    %esi,%eax
  80759e:	e8 51 f9 ff ff       	call   806ef4 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8075a3:	66 8b 1d 44 44 b3 00 	mov    0xb34444,%bx
  8075aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8075ad:	89 04 24             	mov    %eax,(%esp)
  8075b0:	e8 47 dc ff ff       	call   8051fc <pbuf_clen>
  8075b5:	0f b6 c0             	movzbl %al,%eax
  8075b8:	66 29 c3             	sub    %ax,%bx
  8075bb:	66 89 1d 44 44 b3 00 	mov    %bx,0xb34444

    /* Return the pbuf chain */
    return p;
  8075c2:	eb 36                	jmp    8075fa <ip_reass+0x4c6>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8075c4:	8b 55 08             	mov    0x8(%ebp),%edx
  8075c7:	89 14 24             	mov    %edx,(%esp)
  8075ca:	e8 a6 d7 ff ff       	call   804d75 <pbuf_free>
  return NULL;
  8075cf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075d6:	eb 22                	jmp    8075fa <ip_reass+0x4c6>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8075d8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075df:	eb 19                	jmp    8075fa <ip_reass+0x4c6>
  8075e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075e8:	eb 10                	jmp    8075fa <ip_reass+0x4c6>
  8075ea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8075f1:	eb 07                	jmp    8075fa <ip_reass+0x4c6>
  8075f3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  8075fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8075fd:	83 c4 3c             	add    $0x3c,%esp
  807600:	5b                   	pop    %ebx
  807601:	5e                   	pop    %esi
  807602:	5f                   	pop    %edi
  807603:	5d                   	pop    %ebp
  807604:	c3                   	ret    
  807605:	89 f1                	mov    %esi,%ecx
  807607:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80760a:	85 ff                	test   %edi,%edi
  80760c:	0f 85 ea fd ff ff    	jne    8073fc <ip_reass+0x2c8>
  807612:	e9 1e fe ff ff       	jmp    807435 <ip_reass+0x301>
  807617:	89 7d e0             	mov    %edi,-0x20(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80761a:	85 c9                	test   %ecx,%ecx
  80761c:	0f 85 a7 fe ff ff    	jne    8074c9 <ip_reass+0x395>
  807622:	e9 86 fe ff ff       	jmp    8074ad <ip_reass+0x379>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  807627:	83 c0 14             	add    $0x14,%eax
  80762a:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80762e:	8b 46 04             	mov    0x4(%esi),%eax
  807631:	8b 58 04             	mov    0x4(%eax),%ebx
  807634:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807636:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80763d:	00 
  80763e:	8d 46 08             	lea    0x8(%esi),%eax
  807641:	89 44 24 04          	mov    %eax,0x4(%esp)
  807645:	89 1c 24             	mov    %ebx,(%esp)
  807648:	e8 b1 80 00 00       	call   80f6fe <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80764d:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  807651:	89 04 24             	mov    %eax,(%esp)
  807654:	e8 24 06 00 00       	call   807c7d <htons>
  807659:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80765d:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  807663:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807669:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807670:	00 
  807671:	89 1c 24             	mov    %ebx,(%esp)
  807674:	e8 ce 04 00 00       	call   807b47 <inet_chksum>
  807679:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80767d:	8b 46 04             	mov    0x4(%esi),%eax
  807680:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807683:	89 75 e0             	mov    %esi,-0x20(%ebp)
  807686:	89 c6                	mov    %eax,%esi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807688:	e9 05 ff ff ff       	jmp    807592 <ip_reass+0x45e>

0080768d <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  80768d:	55                   	push   %ebp
  80768e:	89 e5                	mov    %esp,%ebp
  807690:	57                   	push   %edi
  807691:	56                   	push   %esi
  807692:	53                   	push   %ebx
  807693:	83 ec 4c             	sub    $0x4c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807696:	8b 45 0c             	mov    0xc(%ebp),%eax
  807699:	8b 70 2c             	mov    0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  80769c:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8076a3:	00 
  8076a4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8076ab:	00 
  8076ac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8076b3:	e8 be d8 ff ff       	call   804f76 <pbuf_alloc>
  8076b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  8076bb:	85 c0                	test   %eax,%eax
  8076bd:	0f 84 d2 01 00 00    	je     807895 <ip_frag+0x208>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8076c3:	66 89 70 0a          	mov    %si,0xa(%eax)
  8076c7:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8076cb:	b8 63 44 b3 00       	mov    $0xb34463,%eax
  8076d0:	83 e0 fc             	and    $0xfffffffc,%eax
  8076d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8076d6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  8076d9:	89 42 04             	mov    %eax,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8076dc:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8076e3:	00 
  8076e4:	8b 55 08             	mov    0x8(%ebp),%edx
  8076e7:	8b 42 04             	mov    0x4(%edx),%eax
  8076ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8076ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8076f1:	89 04 24             	mov    %eax,(%esp)
  8076f4:	e8 05 80 00 00       	call   80f6fe <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8076f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8076fc:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  807700:	89 04 24             	mov    %eax,(%esp)
  807703:	e8 81 05 00 00       	call   807c89 <ntohs>
  ofo = tmp & IP_OFFMASK;
  807708:	89 c2                	mov    %eax,%edx
  80770a:	81 e2 ff 1f 00 00    	and    $0x1fff,%edx
  807710:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  omf = tmp & IP_MF;
  807714:	25 00 20 00 00       	and    $0x2000,%eax
  807719:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  80771d:	8b 45 08             	mov    0x8(%ebp),%eax
  807720:	8b 58 08             	mov    0x8(%eax),%ebx
  807723:	83 eb 14             	sub    $0x14,%ebx

  nfb = (mtu - IP_HLEN) / 8;
  807726:	0f b7 f6             	movzwl %si,%esi
  807729:	83 ee 14             	sub    $0x14,%esi
  80772c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80772f:	89 f0                	mov    %esi,%eax
  807731:	85 f6                	test   %esi,%esi
  807733:	79 03                	jns    807738 <ip_frag+0xab>
  807735:	8d 46 07             	lea    0x7(%esi),%eax
  807738:	c1 e8 03             	shr    $0x3,%eax
  80773b:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  80773f:	66 c7 45 e0 14 00    	movw   $0x14,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807745:	c1 e0 03             	shl    $0x3,%eax
  807748:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80774c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80774f:	83 c2 14             	add    $0x14,%edx
  807752:	89 55 cc             	mov    %edx,-0x34(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807755:	e9 23 01 00 00       	jmp    80787d <ip_frag+0x1f0>
    last = (left <= mtu - IP_HLEN);
  80775a:	0f b7 c3             	movzwl %bx,%eax
  80775d:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807760:	0f 9d c0             	setge  %al
  807763:	0f b6 f8             	movzbl %al,%edi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807766:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  80776a:	25 ff 1f 00 00       	and    $0x1fff,%eax
  80776f:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  807773:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    if (!last)
  807777:	66 85 ff             	test   %di,%di
  80777a:	75 0c                	jne    807788 <ip_frag+0xfb>
      tmp = tmp | IP_MF;
  80777c:	80 cc 20             	or     $0x20,%ah
  80777f:	66 89 45 de          	mov    %ax,-0x22(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807783:	8b 75 d0             	mov    -0x30(%ebp),%esi
  807786:	eb 02                	jmp    80778a <ip_frag+0xfd>
  807788:	89 de                	mov    %ebx,%esi

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80778a:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80778e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  807792:	0f b7 c6             	movzwl %si,%eax
  807795:	89 44 24 08          	mov    %eax,0x8(%esp)
  807799:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80779c:	89 44 24 04          	mov    %eax,0x4(%esp)
  8077a0:	8b 55 08             	mov    0x8(%ebp),%edx
  8077a3:	89 14 24             	mov    %edx,(%esp)
  8077a6:	e8 60 dd ff ff       	call   80550b <pbuf_copy_partial>
  8077ab:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8077af:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  8077b3:	89 04 24             	mov    %eax,(%esp)
  8077b6:	e8 c2 04 00 00       	call   807c7d <htons>
  8077bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077be:	66 89 42 06          	mov    %ax,0x6(%edx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8077c2:	8d 46 14             	lea    0x14(%esi),%eax
  8077c5:	0f b7 c0             	movzwl %ax,%eax
  8077c8:	89 04 24             	mov    %eax,(%esp)
  8077cb:	e8 ad 04 00 00       	call   807c7d <htons>
  8077d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077d3:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_CHKSUM_SET(iphdr, 0);
  8077d7:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8077dd:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8077e4:	00 
  8077e5:	89 14 24             	mov    %edx,(%esp)
  8077e8:	e8 5a 03 00 00       	call   807b47 <inet_chksum>
  8077ed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077f0:	66 89 42 0a          	mov    %ax,0xa(%edx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8077f4:	66 85 ff             	test   %di,%di
  8077f7:	74 15                	je     80780e <ip_frag+0x181>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8077f9:	8d 43 14             	lea    0x14(%ebx),%eax
  8077fc:	0f b7 c0             	movzwl %ax,%eax
  8077ff:	89 44 24 04          	mov    %eax,0x4(%esp)
  807803:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807806:	89 04 24             	mov    %eax,(%esp)
  807809:	e8 39 d6 ff ff       	call   804e47 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80780e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  807815:	00 
  807816:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80781d:	00 
  80781e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807825:	e8 4c d7 ff ff       	call   804f76 <pbuf_alloc>
  80782a:	89 c7                	mov    %eax,%edi
    if (header != NULL) {
  80782c:	85 c0                	test   %eax,%eax
  80782e:	74 3e                	je     80786e <ip_frag+0x1e1>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807830:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807833:	66 01 45 e0          	add    %ax,-0x20(%ebp)
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
  807837:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80783a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80783e:	89 3c 24             	mov    %edi,(%esp)
  807841:	e8 4d da ff ff       	call   805293 <pbuf_chain>
      netif->output(netif, header, dest);
  807846:	8b 55 10             	mov    0x10(%ebp),%edx
  807849:	89 54 24 08          	mov    %edx,0x8(%esp)
  80784d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  807851:	8b 45 0c             	mov    0xc(%ebp),%eax
  807854:	89 04 24             	mov    %eax,(%esp)
  807857:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80785a:	89 3c 24             	mov    %edi,(%esp)
  80785d:	e8 13 d5 ff ff       	call   804d75 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  807862:	66 29 f3             	sub    %si,%bx
    ofo += nfb;
  807865:	8b 45 b8             	mov    -0x48(%ebp),%eax
  807868:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
  80786c:	eb 0f                	jmp    80787d <ip_frag+0x1f0>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80786e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807871:	89 04 24             	mov    %eax,(%esp)
  807874:	e8 fc d4 ff ff       	call   804d75 <pbuf_free>
      return ERR_MEM;
  807879:	b0 ff                	mov    $0xff,%al
  80787b:	eb 1a                	jmp    807897 <ip_frag+0x20a>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80787d:	66 85 db             	test   %bx,%bx
  807880:	0f 85 d4 fe ff ff    	jne    80775a <ip_frag+0xcd>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807886:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807889:	89 04 24             	mov    %eax,(%esp)
  80788c:	e8 e4 d4 ff ff       	call   804d75 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807891:	b0 00                	mov    $0x0,%al
  807893:	eb 02                	jmp    807897 <ip_frag+0x20a>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  807895:	b0 ff                	mov    $0xff,%al
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  807897:	83 c4 4c             	add    $0x4c,%esp
  80789a:	5b                   	pop    %ebx
  80789b:	5e                   	pop    %esi
  80789c:	5f                   	pop    %edi
  80789d:	5d                   	pop    %ebp
  80789e:	c3                   	ret    
	...

008078a0 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8078a0:	55                   	push   %ebp
  8078a1:	89 e5                	mov    %esp,%ebp
  8078a3:	57                   	push   %edi
  8078a4:	56                   	push   %esi
  8078a5:	53                   	push   %ebx
  8078a6:	83 ec 2c             	sub    $0x2c,%esp
  8078a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  8078ac:	89 d0                	mov    %edx,%eax
  8078ae:	66 d1 e8             	shr    %ax
  8078b1:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8078b5:	0f b7 c0             	movzwl %ax,%eax
  8078b8:	d1 e0                	shl    %eax
  8078ba:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8078bd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8078c0:	01 c7                	add    %eax,%edi
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  8078c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8078c5:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8078ca:	eb 14                	jmp    8078e0 <lwip_standard_chksum+0x40>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8078cc:	0f b6 30             	movzbl (%eax),%esi
  8078cf:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8078d2:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  8078d6:	09 f3                	or     %esi,%ebx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  8078d8:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  8078db:	0f b7 db             	movzwl %bx,%ebx
  8078de:	01 d9                	add    %ebx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8078e0:	39 f8                	cmp    %edi,%eax
  8078e2:	75 e8                	jne    8078cc <lwip_standard_chksum+0x2c>
  8078e4:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8078e7:	03 5d dc             	add    -0x24(%ebp),%ebx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  8078ea:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  8078ee:	f7 d8                	neg    %eax
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8078f0:	8d 14 42             	lea    (%edx,%eax,2),%edx
  8078f3:	66 85 d2             	test   %dx,%dx
  8078f6:	74 0b                	je     807903 <lwip_standard_chksum+0x63>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8078f8:	0f b6 03             	movzbl (%ebx),%eax
  8078fb:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8078fe:	0f b7 c0             	movzwl %ax,%eax
  807901:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807903:	89 c8                	mov    %ecx,%eax
  807905:	c1 e8 10             	shr    $0x10,%eax
  807908:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80790e:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  807910:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  807916:	74 0d                	je     807925 <lwip_standard_chksum+0x85>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807918:	89 c8                	mov    %ecx,%eax
  80791a:	c1 e8 10             	shr    $0x10,%eax
  80791d:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  807923:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807925:	0f b7 c9             	movzwl %cx,%ecx
  807928:	89 0c 24             	mov    %ecx,(%esp)
  80792b:	e8 4d 03 00 00       	call   807c7d <htons>
}
  807930:	83 c4 2c             	add    $0x2c,%esp
  807933:	5b                   	pop    %ebx
  807934:	5e                   	pop    %esi
  807935:	5f                   	pop    %edi
  807936:	5d                   	pop    %ebp
  807937:	c3                   	ret    

00807938 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807938:	55                   	push   %ebp
  807939:	89 e5                	mov    %esp,%ebp
  80793b:	57                   	push   %edi
  80793c:	56                   	push   %esi
  80793d:	53                   	push   %ebx
  80793e:	83 ec 2c             	sub    $0x2c,%esp
  807941:	8a 45 14             	mov    0x14(%ebp),%al
  807944:	88 45 e6             	mov    %al,-0x1a(%ebp)
  807947:	8b 7d 18             	mov    0x18(%ebp),%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80794a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  80794d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807951:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807956:	eb 3f                	jmp    807997 <inet_chksum_pseudo+0x5f>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807958:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80795c:	8b 43 04             	mov    0x4(%ebx),%eax
  80795f:	e8 3c ff ff ff       	call   8078a0 <lwip_standard_chksum>
  807964:	0f b7 c0             	movzwl %ax,%eax
  807967:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807969:	89 f0                	mov    %esi,%eax
  80796b:	c1 e8 10             	shr    $0x10,%eax
  80796e:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807974:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807976:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80797a:	74 19                	je     807995 <inet_chksum_pseudo+0x5d>
      swapped = 1 - swapped;
  80797c:	b2 01                	mov    $0x1,%dl
  80797e:	2a 55 e7             	sub    -0x19(%ebp),%dl
  807981:	88 55 e7             	mov    %dl,-0x19(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807984:	89 f0                	mov    %esi,%eax
  807986:	c1 e0 08             	shl    $0x8,%eax
  807989:	25 ff ff 00 00       	and    $0xffff,%eax
  80798e:	89 f2                	mov    %esi,%edx
  807990:	0f b6 f6             	movzbl %dh,%esi
  807993:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807995:	8b 1b                	mov    (%ebx),%ebx
  807997:	85 db                	test   %ebx,%ebx
  807999:	75 bd                	jne    807958 <inet_chksum_pseudo+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80799b:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80799f:	74 11                	je     8079b2 <inet_chksum_pseudo+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  8079a1:	89 f0                	mov    %esi,%eax
  8079a3:	c1 e0 08             	shl    $0x8,%eax
  8079a6:	25 ff ff 00 00       	and    $0xffff,%eax
  8079ab:	89 f2                	mov    %esi,%edx
  8079ad:	0f b6 f6             	movzbl %dh,%esi
  8079b0:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  8079b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8079b5:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8079b7:	8b 45 10             	mov    0x10(%ebp),%eax
  8079ba:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  8079bc:	89 d1                	mov    %edx,%ecx
  8079be:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  8079c1:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  8079c7:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8079c9:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  8079cc:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  8079ce:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8079d1:	01 d0                	add    %edx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8079d3:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  8079d5:	0f b6 45 e6          	movzbl -0x1a(%ebp),%eax
  8079d9:	89 04 24             	mov    %eax,(%esp)
  8079dc:	e8 9c 02 00 00       	call   807c7d <htons>
  8079e1:	0f b7 c0             	movzwl %ax,%eax
  8079e4:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  8079e6:	0f b7 ff             	movzwl %di,%edi
  8079e9:	89 3c 24             	mov    %edi,(%esp)
  8079ec:	e8 8c 02 00 00       	call   807c7d <htons>
  8079f1:	0f b7 c0             	movzwl %ax,%eax
  8079f4:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8079f6:	89 f0                	mov    %esi,%eax
  8079f8:	c1 e8 10             	shr    $0x10,%eax
  8079fb:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807a01:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  807a03:	89 f0                	mov    %esi,%eax
  807a05:	c1 e8 10             	shr    $0x10,%eax
  807a08:	01 f0                	add    %esi,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807a0a:	f7 d0                	not    %eax
}
  807a0c:	83 c4 2c             	add    $0x2c,%esp
  807a0f:	5b                   	pop    %ebx
  807a10:	5e                   	pop    %esi
  807a11:	5f                   	pop    %edi
  807a12:	5d                   	pop    %ebp
  807a13:	c3                   	ret    

00807a14 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807a14:	55                   	push   %ebp
  807a15:	89 e5                	mov    %esp,%ebp
  807a17:	57                   	push   %edi
  807a18:	56                   	push   %esi
  807a19:	53                   	push   %ebx
  807a1a:	83 ec 2c             	sub    $0x2c,%esp
  807a1d:	8a 45 14             	mov    0x14(%ebp),%al
  807a20:	88 45 e2             	mov    %al,-0x1e(%ebp)
  807a23:	8b 4d 18             	mov    0x18(%ebp),%ecx
  807a26:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  807a2a:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807a2d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807a30:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  807a34:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807a3b:	eb 79                	jmp    807ab6 <inet_chksum_pseudo_partial+0xa2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807a3d:	66 8b 46 0a          	mov    0xa(%esi),%ax
  807a41:	89 df                	mov    %ebx,%edi
  807a43:	66 39 c3             	cmp    %ax,%bx
  807a46:	76 02                	jbe    807a4a <inet_chksum_pseudo_partial+0x36>
  807a48:	89 c7                	mov    %eax,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807a4a:	0f b7 d7             	movzwl %di,%edx
  807a4d:	8b 46 04             	mov    0x4(%esi),%eax
  807a50:	e8 4b fe ff ff       	call   8078a0 <lwip_standard_chksum>
    chksum_len -= chklen;
  807a55:	66 29 fb             	sub    %di,%bx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807a58:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807a5d:	76 1c                	jbe    807a7b <inet_chksum_pseudo_partial+0x67>
  807a5f:	c7 44 24 08 45 1c 81 	movl   $0x811c45,0x8(%esp)
  807a66:	00 
  807a67:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807a6e:	00 
  807a6f:	c7 04 24 50 1c 81 00 	movl   $0x811c50,(%esp)
  807a76:	e8 fd 73 00 00       	call   80ee78 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807a7b:	0f b7 c0             	movzwl %ax,%eax
  807a7e:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807a81:	89 c2                	mov    %eax,%edx
  807a83:	c1 ea 10             	shr    $0x10,%edx
  807a86:	25 ff ff 00 00       	and    $0xffff,%eax
  807a8b:	01 d0                	add    %edx,%eax
  807a8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807a90:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807a94:	74 1e                	je     807ab4 <inet_chksum_pseudo_partial+0xa0>
      swapped = 1 - swapped;
  807a96:	b0 01                	mov    $0x1,%al
  807a98:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807a9b:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807a9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807aa1:	c1 e0 08             	shl    $0x8,%eax
  807aa4:	25 ff ff 00 00       	and    $0xffff,%eax
  807aa9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807aac:	0f b6 d5             	movzbl %ch,%edx
  807aaf:	09 c2                	or     %eax,%edx
  807ab1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807ab4:	8b 36                	mov    (%esi),%esi
  807ab6:	85 f6                	test   %esi,%esi
  807ab8:	74 0e                	je     807ac8 <inet_chksum_pseudo_partial+0xb4>
  807aba:	66 85 db             	test   %bx,%bx
  807abd:	0f 85 7a ff ff ff    	jne    807a3d <inet_chksum_pseudo_partial+0x29>
  807ac3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ac6:	eb 03                	jmp    807acb <inet_chksum_pseudo_partial+0xb7>
  807ac8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807acb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807acf:	74 13                	je     807ae4 <inet_chksum_pseudo_partial+0xd0>
    acc = SWAP_BYTES_IN_WORD(acc);
  807ad1:	89 c2                	mov    %eax,%edx
  807ad3:	c1 e2 08             	shl    $0x8,%edx
  807ad6:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  807adc:	0f b6 c4             	movzbl %ah,%eax
  807adf:	09 d0                	or     %edx,%eax
  807ae1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
  807ae7:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807ae9:	8b 55 10             	mov    0x10(%ebp),%edx
  807aec:	8b 1a                	mov    (%edx),%ebx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807aee:	89 c2                	mov    %eax,%edx
  807af0:	c1 ea 10             	shr    $0x10,%edx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807af3:	25 ff ff 00 00       	and    $0xffff,%eax
  807af8:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807afa:	0f b7 d3             	movzwl %bx,%edx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807afd:	01 d0                	add    %edx,%eax
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807aff:	c1 eb 10             	shr    $0x10,%ebx
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807b02:	01 c3                	add    %eax,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807b04:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807b07:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  807b0b:	89 04 24             	mov    %eax,(%esp)
  807b0e:	e8 6a 01 00 00       	call   807c7d <htons>
  807b13:	0f b7 c0             	movzwl %ax,%eax
  807b16:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807b18:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807b1c:	89 04 24             	mov    %eax,(%esp)
  807b1f:	e8 59 01 00 00       	call   807c7d <htons>
  807b24:	0f b7 c0             	movzwl %ax,%eax
  807b27:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807b29:	89 d8                	mov    %ebx,%eax
  807b2b:	c1 e8 10             	shr    $0x10,%eax
  807b2e:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  807b34:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  807b36:	89 c2                	mov    %eax,%edx
  807b38:	c1 ea 10             	shr    $0x10,%edx
  807b3b:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807b3d:	f7 d0                	not    %eax
}
  807b3f:	83 c4 2c             	add    $0x2c,%esp
  807b42:	5b                   	pop    %ebx
  807b43:	5e                   	pop    %esi
  807b44:	5f                   	pop    %edi
  807b45:	5d                   	pop    %ebp
  807b46:	c3                   	ret    

00807b47 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807b47:	55                   	push   %ebp
  807b48:	89 e5                	mov    %esp,%ebp
  807b4a:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807b4d:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807b51:	8b 45 08             	mov    0x8(%ebp),%eax
  807b54:	e8 47 fd ff ff       	call   8078a0 <lwip_standard_chksum>
  807b59:	f7 d0                	not    %eax
}
  807b5b:	c9                   	leave  
  807b5c:	c3                   	ret    

00807b5d <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807b5d:	55                   	push   %ebp
  807b5e:	89 e5                	mov    %esp,%ebp
  807b60:	56                   	push   %esi
  807b61:	53                   	push   %ebx
  807b62:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b65:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807b68:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807b6c:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807b71:	eb 3f                	jmp    807bb2 <inet_chksum_pbuf+0x55>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807b73:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807b77:	8b 43 04             	mov    0x4(%ebx),%eax
  807b7a:	e8 21 fd ff ff       	call   8078a0 <lwip_standard_chksum>
  807b7f:	0f b7 c0             	movzwl %ax,%eax
  807b82:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  807b84:	89 f0                	mov    %esi,%eax
  807b86:	c1 e8 10             	shr    $0x10,%eax
  807b89:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  807b8f:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807b91:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807b95:	74 19                	je     807bb0 <inet_chksum_pbuf+0x53>
      swapped = 1 - swapped;
  807b97:	b0 01                	mov    $0x1,%al
  807b99:	2a 45 f7             	sub    -0x9(%ebp),%al
  807b9c:	88 45 f7             	mov    %al,-0x9(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807b9f:	89 f0                	mov    %esi,%eax
  807ba1:	c1 e0 08             	shl    $0x8,%eax
  807ba4:	25 ff ff 00 00       	and    $0xffff,%eax
  807ba9:	89 f2                	mov    %esi,%edx
  807bab:	0f b6 f6             	movzbl %dh,%esi
  807bae:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807bb0:	8b 1b                	mov    (%ebx),%ebx
  807bb2:	85 db                	test   %ebx,%ebx
  807bb4:	75 bd                	jne    807b73 <inet_chksum_pbuf+0x16>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807bb6:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  807bba:	74 11                	je     807bcd <inet_chksum_pbuf+0x70>
    acc = SWAP_BYTES_IN_WORD(acc);
  807bbc:	89 f0                	mov    %esi,%eax
  807bbe:	c1 e0 08             	shl    $0x8,%eax
  807bc1:	25 ff ff 00 00       	and    $0xffff,%eax
  807bc6:	89 f2                	mov    %esi,%edx
  807bc8:	0f b6 f6             	movzbl %dh,%esi
  807bcb:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  807bcd:	89 f0                	mov    %esi,%eax
  807bcf:	f7 d0                	not    %eax
}
  807bd1:	83 c4 10             	add    $0x10,%esp
  807bd4:	5b                   	pop    %ebx
  807bd5:	5e                   	pop    %esi
  807bd6:	5d                   	pop    %ebp
  807bd7:	c3                   	ret    

00807bd8 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807bd8:	55                   	push   %ebp
  807bd9:	89 e5                	mov    %esp,%ebp
  807bdb:	57                   	push   %edi
  807bdc:	56                   	push   %esi
  807bdd:	53                   	push   %ebx
  807bde:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807be1:	8b 45 08             	mov    0x8(%ebp),%eax
  807be4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807be7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807beb:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807bee:	c7 45 dc 3c 4a b3 00 	movl   $0xb34a3c,-0x24(%ebp)
 */
char *
inet_ntoa(struct in_addr addr)
{
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807bf5:	b2 00                	mov    $0x0,%dl
  807bf7:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807bfa:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807bfd:	8a 00                	mov    (%eax),%al
  807bff:	88 45 e2             	mov    %al,-0x1e(%ebp)
      *ap /= (u8_t)10;
  807c02:	0f b6 c0             	movzbl %al,%eax
  807c05:	8d 34 80             	lea    (%eax,%eax,4),%esi
  807c08:	8d 04 f0             	lea    (%eax,%esi,8),%eax
  807c0b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807c0e:	66 c1 e8 0b          	shr    $0xb,%ax
  807c12:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  807c15:	88 01                	mov    %al,(%ecx)
      inv[i++] = '0' + rem;
  807c17:	0f b6 f2             	movzbl %dl,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807c1a:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807c1d:	d1 e7                	shl    %edi
  807c1f:	8a 5d e2             	mov    -0x1e(%ebp),%bl
  807c22:	89 f9                	mov    %edi,%ecx
  807c24:	28 cb                	sub    %cl,%bl
  807c26:	89 df                	mov    %ebx,%edi
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807c28:	8d 4f 30             	lea    0x30(%edi),%ecx
  807c2b:	88 4c 35 ed          	mov    %cl,-0x13(%ebp,%esi,1)
  807c2f:	42                   	inc    %edx
    } while(*ap);
  807c30:	84 c0                	test   %al,%al
  807c32:	75 c6                	jne    807bfa <inet_ntoa+0x22>
  807c34:	88 d0                	mov    %dl,%al
  807c36:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807c39:	8b 7d d8             	mov    -0x28(%ebp),%edi
  807c3c:	eb 0b                	jmp    807c49 <inet_ntoa+0x71>
    while(i--)
  807c3e:	48                   	dec    %eax
      *rp++ = inv[i];
  807c3f:	0f b6 f0             	movzbl %al,%esi
  807c42:	8a 5c 35 ed          	mov    -0x13(%ebp,%esi,1),%bl
  807c46:	88 19                	mov    %bl,(%ecx)
  807c48:	41                   	inc    %ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807c49:	84 c0                	test   %al,%al
  807c4b:	75 f1                	jne    807c3e <inet_ntoa+0x66>
  807c4d:	89 7d d8             	mov    %edi,-0x28(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  807c50:	0f b6 d2             	movzbl %dl,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807c53:	03 55 dc             	add    -0x24(%ebp),%edx
      *rp++ = inv[i];
    *rp++ = '.';
  807c56:	c6 02 2e             	movb   $0x2e,(%edx)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807c59:	fe 45 e3             	incb   -0x1d(%ebp)
  807c5c:	80 7d e3 03          	cmpb   $0x3,-0x1d(%ebp)
  807c60:	77 0b                	ja     807c6d <inet_ntoa+0x95>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807c62:	42                   	inc    %edx
  807c63:	89 55 dc             	mov    %edx,-0x24(%ebp)
    ap++;
  807c66:	ff 45 d8             	incl   -0x28(%ebp)
  807c69:	88 c2                	mov    %al,%dl
  807c6b:	eb 8d                	jmp    807bfa <inet_ntoa+0x22>
  }
  *--rp = 0;
  807c6d:	c6 02 00             	movb   $0x0,(%edx)
  return str;
}
  807c70:	b8 3c 4a b3 00       	mov    $0xb34a3c,%eax
  807c75:	83 c4 1c             	add    $0x1c,%esp
  807c78:	5b                   	pop    %ebx
  807c79:	5e                   	pop    %esi
  807c7a:	5f                   	pop    %edi
  807c7b:	5d                   	pop    %ebp
  807c7c:	c3                   	ret    

00807c7d <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807c7d:	55                   	push   %ebp
  807c7e:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807c80:	8b 45 08             	mov    0x8(%ebp),%eax
  807c83:	66 c1 c0 08          	rol    $0x8,%ax
}
  807c87:	5d                   	pop    %ebp
  807c88:	c3                   	ret    

00807c89 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807c89:	55                   	push   %ebp
  807c8a:	89 e5                	mov    %esp,%ebp
  807c8c:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  807c8f:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807c93:	89 04 24             	mov    %eax,(%esp)
  807c96:	e8 e2 ff ff ff       	call   807c7d <htons>
}
  807c9b:	c9                   	leave  
  807c9c:	c3                   	ret    

00807c9d <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807c9d:	55                   	push   %ebp
  807c9e:	89 e5                	mov    %esp,%ebp
  807ca0:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807ca3:	89 d1                	mov    %edx,%ecx
  807ca5:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807ca8:	89 d0                	mov    %edx,%eax
  807caa:	c1 e0 18             	shl    $0x18,%eax
  807cad:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807caf:	89 d1                	mov    %edx,%ecx
  807cb1:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807cb7:	c1 e1 08             	shl    $0x8,%ecx
  807cba:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807cbc:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807cc2:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807cc5:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807cc7:	5d                   	pop    %ebp
  807cc8:	c3                   	ret    

00807cc9 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807cc9:	55                   	push   %ebp
  807cca:	89 e5                	mov    %esp,%ebp
  807ccc:	57                   	push   %edi
  807ccd:	56                   	push   %esi
  807cce:	53                   	push   %ebx
  807ccf:	83 ec 24             	sub    $0x24,%esp
  807cd2:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807cd5:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807cd8:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  807cdb:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807cde:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  807ce1:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807ce4:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807ce7:	80 f9 09             	cmp    $0x9,%cl
  807cea:	0f 87 8f 01 00 00    	ja     807e7f <inet_aton+0x1b6>
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  807cf0:	83 fa 30             	cmp    $0x30,%edx
  807cf3:	75 28                	jne    807d1d <inet_aton+0x54>
      c = *++cp;
  807cf5:	0f be 50 01          	movsbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807cf9:	83 fa 78             	cmp    $0x78,%edx
  807cfc:	74 0f                	je     807d0d <inet_aton+0x44>
  807cfe:	83 fa 58             	cmp    $0x58,%edx
  807d01:	74 0a                	je     807d0d <inet_aton+0x44>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807d03:	40                   	inc    %eax
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807d04:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  807d0b:	eb 17                	jmp    807d24 <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807d0d:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807d11:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807d14:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
        c = *++cp;
  807d1b:	eb 07                	jmp    807d24 <inet_aton+0x5b>
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
  807d1d:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  807d24:	40                   	inc    %eax
  807d25:	be 00 00 00 00       	mov    $0x0,%esi
  807d2a:	eb 01                	jmp    807d2d <inet_aton+0x64>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807d2c:	40                   	inc    %eax
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  807d2d:	8d 78 ff             	lea    -0x1(%eax),%edi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807d30:	88 d1                	mov    %dl,%cl
  807d32:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  807d35:	80 fb 09             	cmp    $0x9,%bl
  807d38:	77 0d                	ja     807d47 <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  807d3a:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  807d3e:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  807d42:	0f be 10             	movsbl (%eax),%edx
  807d45:	eb e5                	jmp    807d2c <inet_aton+0x63>
      } else if (base == 16 && isxdigit(c)) {
  807d47:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  807d4b:	75 30                	jne    807d7d <inet_aton+0xb4>
  807d4d:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  807d50:	88 5d da             	mov    %bl,-0x26(%ebp)
  807d53:	80 fb 05             	cmp    $0x5,%bl
  807d56:	76 08                	jbe    807d60 <inet_aton+0x97>
  807d58:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  807d5b:	80 fb 05             	cmp    $0x5,%bl
  807d5e:	77 23                	ja     807d83 <inet_aton+0xba>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807d60:	89 f1                	mov    %esi,%ecx
  807d62:	c1 e1 04             	shl    $0x4,%ecx
  807d65:	8d 72 0a             	lea    0xa(%edx),%esi
  807d68:	80 7d da 1a          	cmpb   $0x1a,-0x26(%ebp)
  807d6c:	19 d2                	sbb    %edx,%edx
  807d6e:	83 e2 20             	and    $0x20,%edx
  807d71:	83 c2 41             	add    $0x41,%edx
  807d74:	29 d6                	sub    %edx,%esi
  807d76:	09 ce                	or     %ecx,%esi
        c = *++cp;
  807d78:	0f be 10             	movsbl (%eax),%edx
  807d7b:	eb af                	jmp    807d2c <inet_aton+0x63>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  807d7d:	89 d0                	mov    %edx,%eax
  807d7f:	89 f3                	mov    %esi,%ebx
  807d81:	eb 04                	jmp    807d87 <inet_aton+0xbe>
  807d83:	89 d0                	mov    %edx,%eax
  807d85:	89 f3                	mov    %esi,%ebx
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
  807d87:	83 f8 2e             	cmp    $0x2e,%eax
  807d8a:	75 23                	jne    807daf <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807d8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807d8f:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807d92:	0f 83 ee 00 00 00    	jae    807e86 <inet_aton+0x1bd>
        return (0);
      *pp++ = val;
  807d98:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807d9b:	89 1a                	mov    %ebx,(%edx)
  807d9d:	83 c2 04             	add    $0x4,%edx
  807da0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      c = *++cp;
  807da3:	8d 47 01             	lea    0x1(%edi),%eax
  807da6:	0f be 57 01          	movsbl 0x1(%edi),%edx
    } else
      break;
  }
  807daa:	e9 35 ff ff ff       	jmp    807ce4 <inet_aton+0x1b>
  807daf:	89 f3                	mov    %esi,%ebx
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
  807db1:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807db3:	85 d2                	test   %edx,%edx
  807db5:	74 33                	je     807dea <inet_aton+0x121>
  807db7:	80 f9 1f             	cmp    $0x1f,%cl
  807dba:	0f 86 cd 00 00 00    	jbe    807e8d <inet_aton+0x1c4>
  807dc0:	84 d2                	test   %dl,%dl
  807dc2:	0f 88 cc 00 00 00    	js     807e94 <inet_aton+0x1cb>
  807dc8:	83 fa 20             	cmp    $0x20,%edx
  807dcb:	74 1d                	je     807dea <inet_aton+0x121>
  807dcd:	83 fa 0c             	cmp    $0xc,%edx
  807dd0:	74 18                	je     807dea <inet_aton+0x121>
  807dd2:	83 fa 0a             	cmp    $0xa,%edx
  807dd5:	74 13                	je     807dea <inet_aton+0x121>
  807dd7:	83 fa 0d             	cmp    $0xd,%edx
  807dda:	74 0e                	je     807dea <inet_aton+0x121>
  807ddc:	83 fa 09             	cmp    $0x9,%edx
  807ddf:	74 09                	je     807dea <inet_aton+0x121>
  807de1:	83 fa 0b             	cmp    $0xb,%edx
  807de4:	0f 85 b1 00 00 00    	jne    807e9b <inet_aton+0x1d2>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  807dea:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  807ded:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  807df0:	29 d1                	sub    %edx,%ecx
  807df2:	89 ca                	mov    %ecx,%edx
  807df4:	c1 fa 02             	sar    $0x2,%edx
  807df7:	42                   	inc    %edx
  switch (n) {
  807df8:	83 fa 02             	cmp    $0x2,%edx
  807dfb:	74 1b                	je     807e18 <inet_aton+0x14f>
  807dfd:	83 fa 02             	cmp    $0x2,%edx
  807e00:	7f 0a                	jg     807e0c <inet_aton+0x143>
  807e02:	85 d2                	test   %edx,%edx
  807e04:	0f 84 98 00 00 00    	je     807ea2 <inet_aton+0x1d9>
  807e0a:	eb 59                	jmp    807e65 <inet_aton+0x19c>
  807e0c:	83 fa 03             	cmp    $0x3,%edx
  807e0f:	74 1c                	je     807e2d <inet_aton+0x164>
  807e11:	83 fa 04             	cmp    $0x4,%edx
  807e14:	75 4f                	jne    807e65 <inet_aton+0x19c>
  807e16:	eb 2e                	jmp    807e46 <inet_aton+0x17d>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807e18:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  807e1d:	0f 87 86 00 00 00    	ja     807ea9 <inet_aton+0x1e0>
      return (0);
    val |= parts[0] << 24;
  807e23:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807e26:	c1 e3 18             	shl    $0x18,%ebx
  807e29:	09 c3                	or     %eax,%ebx
    break;
  807e2b:	eb 38                	jmp    807e65 <inet_aton+0x19c>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807e2d:	3d ff ff 00 00       	cmp    $0xffff,%eax
  807e32:	77 7c                	ja     807eb0 <inet_aton+0x1e7>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807e34:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  807e37:	c1 e3 10             	shl    $0x10,%ebx
  807e3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807e3d:	c1 e2 18             	shl    $0x18,%edx
  807e40:	09 d3                	or     %edx,%ebx
  807e42:	09 c3                	or     %eax,%ebx
    break;
  807e44:	eb 1f                	jmp    807e65 <inet_aton+0x19c>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807e46:	3d ff 00 00 00       	cmp    $0xff,%eax
  807e4b:	77 6a                	ja     807eb7 <inet_aton+0x1ee>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807e4d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  807e50:	c1 e3 10             	shl    $0x10,%ebx
  807e53:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807e56:	c1 e2 18             	shl    $0x18,%edx
  807e59:	09 d3                	or     %edx,%ebx
  807e5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
  807e5e:	c1 e2 08             	shl    $0x8,%edx
  807e61:	09 d3                	or     %edx,%ebx
  807e63:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  807e65:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807e69:	74 53                	je     807ebe <inet_aton+0x1f5>
    addr->s_addr = htonl(val);
  807e6b:	89 1c 24             	mov    %ebx,(%esp)
  807e6e:	e8 2a fe ff ff       	call   807c9d <htonl>
  807e73:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  807e76:	89 03                	mov    %eax,(%ebx)
  return (1);
  807e78:	b8 01 00 00 00       	mov    $0x1,%eax
  807e7d:	eb 44                	jmp    807ec3 <inet_aton+0x1fa>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807e7f:	b8 00 00 00 00       	mov    $0x0,%eax
  807e84:	eb 3d                	jmp    807ec3 <inet_aton+0x1fa>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807e86:	b8 00 00 00 00       	mov    $0x0,%eax
  807e8b:	eb 36                	jmp    807ec3 <inet_aton+0x1fa>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807e8d:	b8 00 00 00 00       	mov    $0x0,%eax
  807e92:	eb 2f                	jmp    807ec3 <inet_aton+0x1fa>
  807e94:	b8 00 00 00 00       	mov    $0x0,%eax
  807e99:	eb 28                	jmp    807ec3 <inet_aton+0x1fa>
  807e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  807ea0:	eb 21                	jmp    807ec3 <inet_aton+0x1fa>
   */
  n = pp - parts + 1;
  switch (n) {

  case 0:
    return (0);       /* initial nondigit */
  807ea2:	b8 00 00 00 00       	mov    $0x0,%eax
  807ea7:	eb 1a                	jmp    807ec3 <inet_aton+0x1fa>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  807eae:	eb 13                	jmp    807ec3 <inet_aton+0x1fa>
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807eb0:	b8 00 00 00 00       	mov    $0x0,%eax
  807eb5:	eb 0c                	jmp    807ec3 <inet_aton+0x1fa>
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807eb7:	b8 00 00 00 00       	mov    $0x0,%eax
  807ebc:	eb 05                	jmp    807ec3 <inet_aton+0x1fa>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807ebe:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807ec3:	83 c4 24             	add    $0x24,%esp
  807ec6:	5b                   	pop    %ebx
  807ec7:	5e                   	pop    %esi
  807ec8:	5f                   	pop    %edi
  807ec9:	5d                   	pop    %ebp
  807eca:	c3                   	ret    

00807ecb <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807ecb:	55                   	push   %ebp
  807ecc:	89 e5                	mov    %esp,%ebp
  807ece:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807ed1:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807ed4:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ed8:	8b 45 08             	mov    0x8(%ebp),%eax
  807edb:	89 04 24             	mov    %eax,(%esp)
  807ede:	e8 e6 fd ff ff       	call   807cc9 <inet_aton>
  807ee3:	85 c0                	test   %eax,%eax
  807ee5:	74 05                	je     807eec <inet_addr+0x21>
    return (val.s_addr);
  807ee7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  807eea:	eb 05                	jmp    807ef1 <inet_addr+0x26>
  }
  return (INADDR_NONE);
  807eec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807ef1:	c9                   	leave  
  807ef2:	c3                   	ret    

00807ef3 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807ef3:	55                   	push   %ebp
  807ef4:	89 e5                	mov    %esp,%ebp
  807ef6:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  807ef9:	8b 45 08             	mov    0x8(%ebp),%eax
  807efc:	89 04 24             	mov    %eax,(%esp)
  807eff:	e8 99 fd ff ff       	call   807c9d <htonl>
}
  807f04:	c9                   	leave  
  807f05:	c3                   	ret    
	...

00807f08 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807f08:	55                   	push   %ebp
  807f09:	89 e5                	mov    %esp,%ebp
  807f0b:	57                   	push   %edi
  807f0c:	56                   	push   %esi
  807f0d:	53                   	push   %ebx
  807f0e:	83 ec 4c             	sub    $0x4c,%esp
  807f11:	8b 45 10             	mov    0x10(%ebp),%eax
  807f14:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  807f18:	8a 55 14             	mov    0x14(%ebp),%dl
  807f1b:	88 55 e0             	mov    %dl,-0x20(%ebp)
  807f1e:	8a 4d 18             	mov    0x18(%ebp),%cl
  807f21:	88 4d b8             	mov    %cl,-0x48(%ebp)
  807f24:	8a 45 20             	mov    0x20(%ebp),%al
  807f27:	88 45 e1             	mov    %al,-0x1f(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807f2a:	66 83 7d cc 00       	cmpw   $0x0,-0x34(%ebp)
  807f2f:	74 20                	je     807f51 <tcp_enqueue+0x49>
  807f31:	84 c0                	test   %al,%al
  807f33:	74 1c                	je     807f51 <tcp_enqueue+0x49>
  807f35:	c7 44 24 08 74 1c 81 	movl   $0x811c74,0x8(%esp)
  807f3c:	00 
  807f3d:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  807f44:	00 
  807f45:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  807f4c:	e8 27 6f 00 00       	call   80ee78 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807f51:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807f55:	74 22                	je     807f79 <tcp_enqueue+0x71>
  807f57:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807f5b:	74 1c                	je     807f79 <tcp_enqueue+0x71>
  807f5d:	c7 44 24 08 b4 1c 81 	movl   $0x811cb4,0x8(%esp)
  807f64:	00 
  807f65:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  807f6c:	00 
  807f6d:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  807f74:	e8 ff 6e 00 00       	call   80ee78 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807f79:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  807f7c:	8b 55 08             	mov    0x8(%ebp),%edx
  807f7f:	66 3b 4a 6e          	cmp    0x6e(%edx),%cx
  807f83:	76 0b                	jbe    807f90 <tcp_enqueue+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  807f85:	80 4a 20 80          	orb    $0x80,0x20(%edx)
    return ERR_MEM;
  807f89:	b0 ff                	mov    $0xff,%al
  807f8b:	e9 cc 05 00 00       	jmp    80855c <tcp_enqueue+0x654>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807f90:	8b 45 08             	mov    0x8(%ebp),%eax
  807f93:	8b 40 68             	mov    0x68(%eax),%eax
  807f96:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807f99:	8b 55 08             	mov    0x8(%ebp),%edx
  807f9c:	8b 52 70             	mov    0x70(%edx),%edx
  807f9f:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807fa3:	66 83 fa 1f          	cmp    $0x1f,%dx
  807fa7:	76 0e                	jbe    807fb7 <tcp_enqueue+0xaf>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  807fa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807fac:	80 49 20 80          	orb    $0x80,0x20(%ecx)
    return ERR_MEM;
  807fb0:	b0 ff                	mov    $0xff,%al
  807fb2:	e9 a5 05 00 00       	jmp    80855c <tcp_enqueue+0x654>
  }
  if (queuelen != 0) {
  807fb7:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807fbc:	74 33                	je     807ff1 <tcp_enqueue+0xe9>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807fbe:	8b 45 08             	mov    0x8(%ebp),%eax
  807fc1:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  807fc5:	0f 85 a3 05 00 00    	jne    80856e <tcp_enqueue+0x666>
  807fcb:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  807fcf:	0f 85 99 05 00 00    	jne    80856e <tcp_enqueue+0x666>
  807fd5:	c7 44 24 08 fc 1c 81 	movl   $0x811cfc,0x8(%esp)
  807fdc:	00 
  807fdd:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  807fe4:	00 
  807fe5:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  807fec:	e8 87 6e 00 00       	call   80ee78 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807ff1:	8b 55 08             	mov    0x8(%ebp),%edx
  807ff4:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  807ff8:	75 0a                	jne    808004 <tcp_enqueue+0xfc>
  807ffa:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  807ffe:	0f 84 6a 05 00 00    	je     80856e <tcp_enqueue+0x666>
  808004:	c7 44 24 08 38 1d 81 	movl   $0x811d38,0x8(%esp)
  80800b:	00 
  80800c:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  808013:	00 
  808014:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  80801b:	e8 58 6e 00 00       	call   80ee78 <_panic>

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808020:	89 f7                	mov    %esi,%edi
  808022:	eb 02                	jmp    808026 <tcp_enqueue+0x11e>
  808024:	89 f7                	mov    %esi,%edi

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  808026:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808029:	8b 59 34             	mov    0x34(%ecx),%ebx

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80802c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808033:	e8 52 c9 ff ff       	call   80498a <memp_malloc>
  808038:	89 c6                	mov    %eax,%esi
    if (seg == NULL) {
  80803a:	85 c0                	test   %eax,%eax
  80803c:	0f 84 b6 04 00 00    	je     8084f8 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  808042:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  808048:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80804f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  808053:	74 24                	je     808079 <tcp_enqueue+0x171>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808055:	85 ff                	test   %edi,%edi
  808057:	75 1c                	jne    808075 <tcp_enqueue+0x16d>
  808059:	c7 44 24 08 2e 1e 81 	movl   $0x811e2e,0x8(%esp)
  808060:	00 
  808061:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  808068:	00 
  808069:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808070:	e8 03 6e 00 00       	call   80ee78 <_panic>
      useg->next = seg;
  808075:	89 07                	mov    %eax,(%edi)
  808077:	eb 03                	jmp    80807c <tcp_enqueue+0x174>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  808079:	89 45 d0             	mov    %eax,-0x30(%ebp)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80807c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80807f:	66 39 df             	cmp    %bx,%di
  808082:	76 02                	jbe    808086 <tcp_enqueue+0x17e>
  808084:	89 df                	mov    %ebx,%edi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  808086:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80808a:	74 6a                	je     8080f6 <tcp_enqueue+0x1ee>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80808c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808093:	00 
  808094:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  808098:	89 44 24 04          	mov    %eax,0x4(%esp)
  80809c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8080a3:	e8 ce ce ff ff       	call   804f76 <pbuf_alloc>
  8080a8:	89 46 04             	mov    %eax,0x4(%esi)
  8080ab:	85 c0                	test   %eax,%eax
  8080ad:	0f 84 45 04 00 00    	je     8084f8 <tcp_enqueue+0x5f0>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8080b3:	0f b6 55 e1          	movzbl -0x1f(%ebp),%edx
  8080b7:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8080bb:	73 1c                	jae    8080d9 <tcp_enqueue+0x1d1>
  8080bd:	c7 44 24 08 6c 1d 81 	movl   $0x811d6c,0x8(%esp)
  8080c4:	00 
  8080c5:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  8080cc:	00 
  8080cd:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  8080d4:	e8 9f 6d 00 00       	call   80ee78 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8080d9:	89 04 24             	mov    %eax,(%esp)
  8080dc:	e8 1b d1 ff ff       	call   8051fc <pbuf_clen>
  8080e1:	0f b6 c0             	movzbl %al,%eax
  8080e4:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  8080e8:	8b 46 04             	mov    0x4(%esi),%eax
  8080eb:	8b 40 04             	mov    0x4(%eax),%eax
  8080ee:	89 46 08             	mov    %eax,0x8(%esi)
  8080f1:	e9 15 01 00 00       	jmp    80820b <tcp_enqueue+0x303>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8080f6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  8080fa:	0f 84 87 00 00 00    	je     808187 <tcp_enqueue+0x27f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  808100:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808107:	00 
  808108:	0f b7 c7             	movzwl %di,%eax
  80810b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80810f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808116:	e8 5b ce ff ff       	call   804f76 <pbuf_alloc>
  80811b:	89 46 04             	mov    %eax,0x4(%esi)
  80811e:	85 c0                	test   %eax,%eax
  808120:	0f 84 d2 03 00 00    	je     8084f8 <tcp_enqueue+0x5f0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808126:	66 3b 78 0a          	cmp    0xa(%eax),%di
  80812a:	76 1c                	jbe    808148 <tcp_enqueue+0x240>
  80812c:	c7 44 24 08 94 1d 81 	movl   $0x811d94,0x8(%esp)
  808133:	00 
  808134:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80813b:	00 
  80813c:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808143:	e8 30 6d 00 00       	call   80ee78 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808148:	89 04 24             	mov    %eax,(%esp)
  80814b:	e8 ac d0 ff ff       	call   8051fc <pbuf_clen>
  808150:	0f b6 c0             	movzbl %al,%eax
  808153:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
  808157:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80815b:	74 1c                	je     808179 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  80815d:	0f b7 c7             	movzwl %di,%eax
  808160:	89 44 24 08          	mov    %eax,0x8(%esp)
  808164:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808167:	89 44 24 04          	mov    %eax,0x4(%esp)
  80816b:	8b 46 04             	mov    0x4(%esi),%eax
  80816e:	8b 40 04             	mov    0x4(%eax),%eax
  808171:	89 04 24             	mov    %eax,(%esp)
  808174:	e8 85 75 00 00       	call   80f6fe <memcpy>
      }
      seg->dataptr = seg->p->payload;
  808179:	8b 46 04             	mov    0x4(%esi),%eax
  80817c:	8b 40 04             	mov    0x4(%eax),%eax
  80817f:	89 46 08             	mov    %eax,0x8(%esi)
  808182:	e9 84 00 00 00       	jmp    80820b <tcp_enqueue+0x303>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808187:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80818e:	00 
  80818f:	0f b7 c7             	movzwl %di,%eax
  808192:	89 44 24 04          	mov    %eax,0x4(%esp)
  808196:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80819d:	e8 d4 cd ff ff       	call   804f76 <pbuf_alloc>
  8081a2:	89 c3                	mov    %eax,%ebx
  8081a4:	85 c0                	test   %eax,%eax
  8081a6:	0f 84 4c 03 00 00    	je     8084f8 <tcp_enqueue+0x5f0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8081ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8081af:	89 50 04             	mov    %edx,0x4(%eax)
      seg->dataptr = ptr;
  8081b2:	89 56 08             	mov    %edx,0x8(%esi)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8081b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8081bc:	00 
  8081bd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8081c4:	00 
  8081c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8081cc:	e8 a5 cd ff ff       	call   804f76 <pbuf_alloc>
  8081d1:	89 46 04             	mov    %eax,0x4(%esi)
  8081d4:	85 c0                	test   %eax,%eax
  8081d6:	75 0d                	jne    8081e5 <tcp_enqueue+0x2dd>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8081d8:	89 1c 24             	mov    %ebx,(%esp)
  8081db:	e8 95 cb ff ff       	call   804d75 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8081e0:	e9 13 03 00 00       	jmp    8084f8 <tcp_enqueue+0x5f0>
      }
      queuelen += pbuf_clen(seg->p);
  8081e5:	89 04 24             	mov    %eax,(%esp)
  8081e8:	e8 0f d0 ff ff       	call   8051fc <pbuf_clen>
  8081ed:	0f b6 c0             	movzbl %al,%eax
  8081f0:	66 8b 4d e2          	mov    -0x1e(%ebp),%cx
  8081f4:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  8081f8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8081fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808200:	8b 46 04             	mov    0x4(%esi),%eax
  808203:	89 04 24             	mov    %eax,(%esp)
  808206:	e8 14 d0 ff ff       	call   80521f <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80820b:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  808210:	0f 87 e2 02 00 00    	ja     8084f8 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  808216:	66 89 7e 0c          	mov    %di,0xc(%esi)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80821a:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808221:	00 
  808222:	8b 46 04             	mov    0x4(%esi),%eax
  808225:	89 04 24             	mov    %eax,(%esp)
  808228:	e8 63 ca ff ff       	call   804c90 <pbuf_header>
  80822d:	84 c0                	test   %al,%al
  80822f:	0f 85 c3 02 00 00    	jne    8084f8 <tcp_enqueue+0x5f0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  808235:	8b 46 04             	mov    0x4(%esi),%eax
  808238:	8b 58 04             	mov    0x4(%eax),%ebx
  80823b:	89 5e 10             	mov    %ebx,0x10(%esi)
    seg->tcphdr->src = htons(pcb->local_port);
  80823e:	8b 55 08             	mov    0x8(%ebp),%edx
  808241:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  808245:	89 04 24             	mov    %eax,(%esp)
  808248:	e8 30 fa ff ff       	call   807c7d <htons>
  80824d:	66 89 03             	mov    %ax,(%ebx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  808250:	8b 5e 10             	mov    0x10(%esi),%ebx
  808253:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808256:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
  80825a:	89 04 24             	mov    %eax,(%esp)
  80825d:	e8 1b fa ff ff       	call   807c7d <htons>
  808262:	66 89 43 02          	mov    %ax,0x2(%ebx)
    seg->tcphdr->seqno = htonl(seqno);
  808266:	8b 5e 10             	mov    0x10(%esi),%ebx
  808269:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80826c:	89 04 24             	mov    %eax,(%esp)
  80826f:	e8 29 fa ff ff       	call   807c9d <htonl>
  808274:	89 43 04             	mov    %eax,0x4(%ebx)
    seg->tcphdr->urgp = 0;
  808277:	8b 46 10             	mov    0x10(%esi),%eax
  80827a:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  808280:	8b 5e 10             	mov    0x10(%esi),%ebx
  808283:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808287:	89 04 24             	mov    %eax,(%esp)
  80828a:	e8 fa f9 ff ff       	call   807c89 <ntohs>
  80828f:	83 e0 c0             	and    $0xffffffc0,%eax
  808292:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  808296:	09 c2                	or     %eax,%edx
  808298:	0f b7 d2             	movzwl %dx,%edx
  80829b:	89 14 24             	mov    %edx,(%esp)
  80829e:	e8 da f9 ff ff       	call   807c7d <htons>
  8082a3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  8082a7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8082ab:	75 23                	jne    8082d0 <tcp_enqueue+0x3c8>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8082ad:	8b 5e 10             	mov    0x10(%esi),%ebx
  8082b0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082b4:	89 04 24             	mov    %eax,(%esp)
  8082b7:	e8 cd f9 ff ff       	call   807c89 <ntohs>
  8082bc:	83 e0 3f             	and    $0x3f,%eax
  8082bf:	80 cc 50             	or     $0x50,%ah
  8082c2:	89 04 24             	mov    %eax,(%esp)
  8082c5:	e8 b3 f9 ff ff       	call   807c7d <htons>
  8082ca:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  8082ce:	eb 3f                	jmp    80830f <tcp_enqueue+0x407>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8082d0:	8b 5e 10             	mov    0x10(%esi),%ebx
  8082d3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082d7:	89 04 24             	mov    %eax,(%esp)
  8082da:	e8 aa f9 ff ff       	call   807c89 <ntohs>
  8082df:	83 e0 3f             	and    $0x3f,%eax
  8082e2:	66 0b 45 ce          	or     -0x32(%ebp),%ax
  8082e6:	0f b7 c0             	movzwl %ax,%eax
  8082e9:	89 04 24             	mov    %eax,(%esp)
  8082ec:	e8 8c f9 ff ff       	call   807c7d <htons>
  8082f1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8082f5:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  8082f9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8082fd:	8b 55 1c             	mov    0x1c(%ebp),%edx
  808300:	89 54 24 04          	mov    %edx,0x4(%esp)
  808304:	8b 46 08             	mov    0x8(%esi),%eax
  808307:	89 04 24             	mov    %eax,(%esp)
  80830a:	e8 ef 73 00 00       	call   80f6fe <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80830f:	66 29 7d e4          	sub    %di,-0x1c(%ebp)
    seqno += seglen;
  808313:	0f b7 c7             	movzwl %di,%eax
  808316:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  808319:	01 45 d4             	add    %eax,-0x2c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80831c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  808320:	0f 84 fa fc ff ff    	je     808020 <tcp_enqueue+0x118>
  808326:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80832b:	0f 85 f3 fc ff ff    	jne    808024 <tcp_enqueue+0x11c>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  808331:	89 75 dc             	mov    %esi,-0x24(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  808334:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808337:	8b 59 74             	mov    0x74(%ecx),%ebx
  80833a:	85 db                	test   %ebx,%ebx
  80833c:	75 07                	jne    808345 <tcp_enqueue+0x43d>
  80833e:	e9 0b 01 00 00       	jmp    80844e <tcp_enqueue+0x546>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  808343:	89 c3                	mov    %eax,%ebx
  808345:	8b 03                	mov    (%ebx),%eax
  808347:	85 c0                	test   %eax,%eax
  808349:	75 f8                	jne    808343 <tcp_enqueue+0x43b>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80834b:	85 db                	test   %ebx,%ebx
  80834d:	0f 84 fb 00 00 00    	je     80844e <tcp_enqueue+0x546>
    TCP_TCPLEN(useg) != 0 &&
  808353:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808357:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80835a:	8b 43 10             	mov    0x10(%ebx),%eax
  80835d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808361:	89 04 24             	mov    %eax,(%esp)
  808364:	e8 20 f9 ff ff       	call   807c89 <ntohs>
  808369:	a8 01                	test   $0x1,%al
  80836b:	75 1a                	jne    808387 <tcp_enqueue+0x47f>
  80836d:	8b 43 10             	mov    0x10(%ebx),%eax
  808370:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808374:	89 04 24             	mov    %eax,(%esp)
  808377:	e8 0d f9 ff ff       	call   807c89 <ntohs>
  80837c:	83 e0 02             	and    $0x2,%eax
  80837f:	0f 95 c0             	setne  %al
  808382:	0f b6 c0             	movzbl %al,%eax
  808385:	eb 05                	jmp    80838c <tcp_enqueue+0x484>
  808387:	b8 01 00 00 00       	mov    $0x1,%eax
  80838c:	03 45 e4             	add    -0x1c(%ebp),%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80838f:	85 c0                	test   %eax,%eax
  808391:	0f 84 cd 01 00 00    	je     808564 <tcp_enqueue+0x65c>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  808397:	8b 43 10             	mov    0x10(%ebx),%eax
  80839a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80839e:	89 04 24             	mov    %eax,(%esp)
  8083a1:	e8 e3 f8 ff ff       	call   807c89 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  8083a6:	a8 03                	test   $0x3,%al
  8083a8:	0f 85 b6 01 00 00    	jne    808564 <tcp_enqueue+0x65c>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8083ae:	f6 45 e0 03          	testb  $0x3,-0x20(%ebp)
  8083b2:	0f 85 ac 01 00 00    	jne    808564 <tcp_enqueue+0x65c>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  8083b8:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083bc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  8083bf:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  8083c3:	01 c2                	add    %eax,%edx
  8083c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8083c8:	0f b7 41 34          	movzwl 0x34(%ecx),%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8083cc:	39 c2                	cmp    %eax,%edx
  8083ce:	0f 8f 90 01 00 00    	jg     808564 <tcp_enqueue+0x65c>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  8083d4:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8083db:	ff 
  8083dc:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8083df:	8b 42 04             	mov    0x4(%edx),%eax
  8083e2:	89 04 24             	mov    %eax,(%esp)
  8083e5:	e8 a6 c8 ff ff       	call   804c90 <pbuf_header>
  8083ea:	84 c0                	test   %al,%al
  8083ec:	74 1c                	je     80840a <tcp_enqueue+0x502>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8083ee:	c7 44 24 08 3b 1e 81 	movl   $0x811e3b,0x8(%esp)
  8083f5:	00 
  8083f6:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  8083fd:	00 
  8083fe:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808405:	e8 6e 6a 00 00       	call   80ee78 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80840a:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80840d:	8b 41 04             	mov    0x4(%ecx),%eax
  808410:	89 44 24 04          	mov    %eax,0x4(%esp)
  808414:	8b 43 04             	mov    0x4(%ebx),%eax
  808417:	89 04 24             	mov    %eax,(%esp)
  80841a:	e8 00 ce ff ff       	call   80521f <pbuf_cat>
    useg->len += queue->len;
  80841f:	8b 55 d0             	mov    -0x30(%ebp),%edx
  808422:	8b 42 0c             	mov    0xc(%edx),%eax
  808425:	66 01 43 0c          	add    %ax,0xc(%ebx)
    useg->next = queue->next;
  808429:	8b 02                	mov    (%edx),%eax
  80842b:	89 03                	mov    %eax,(%ebx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80842d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808430:	39 ca                	cmp    %ecx,%edx
  808432:	75 05                	jne    808439 <tcp_enqueue+0x531>
      seg = NULL;
  808434:	be 00 00 00 00       	mov    $0x0,%esi
    }
    memp_free(MEMP_TCP_SEG, queue);
  808439:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80843c:	89 44 24 04          	mov    %eax,0x4(%esp)
  808440:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808447:	e8 9e c5 ff ff       	call   8049ea <memp_free>
  80844c:	eb 09                	jmp    808457 <tcp_enqueue+0x54f>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80844e:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  808451:	8b 55 08             	mov    0x8(%ebp),%edx
  808454:	89 4a 74             	mov    %ecx,0x74(%edx)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  808457:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  80845b:	75 0c                	jne    808469 <tcp_enqueue+0x561>
  80845d:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  808461:	0f 85 40 01 00 00    	jne    8085a7 <tcp_enqueue+0x69f>
  808467:	eb 11                	jmp    80847a <tcp_enqueue+0x572>
    ++len;
  808469:	66 ff 45 cc          	incw   -0x34(%ebp)
  }
  if (flags & TCP_FIN) {
  80846d:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  808471:	74 07                	je     80847a <tcp_enqueue+0x572>
    pcb->flags |= TF_FIN;
  808473:	8b 45 08             	mov    0x8(%ebp),%eax
  808476:	80 48 20 20          	orb    $0x20,0x20(%eax)
  }
  pcb->snd_lbb += len;
  80847a:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  80847e:	8b 55 08             	mov    0x8(%ebp),%edx
  808481:	01 42 68             	add    %eax,0x68(%edx)

  pcb->snd_buf -= len;
  808484:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  808487:	66 29 4a 6e          	sub    %cx,0x6e(%edx)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80848b:	66 8b 45 e2          	mov    -0x1e(%ebp),%ax
  80848f:	66 89 42 70          	mov    %ax,0x70(%edx)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  808493:	66 85 c0             	test   %ax,%ax
  808496:	74 28                	je     8084c0 <tcp_enqueue+0x5b8>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808498:	83 7a 78 00          	cmpl   $0x0,0x78(%edx)
  80849c:	75 22                	jne    8084c0 <tcp_enqueue+0x5b8>
  80849e:	83 7a 74 00          	cmpl   $0x0,0x74(%edx)
  8084a2:	75 1c                	jne    8084c0 <tcp_enqueue+0x5b8>
  8084a4:	c7 44 24 08 c8 1d 81 	movl   $0x811dc8,0x8(%esp)
  8084ab:	00 
  8084ac:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  8084b3:	00 
  8084b4:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  8084bb:	e8 b8 69 00 00       	call   80ee78 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8084c0:	85 f6                	test   %esi,%esi
  8084c2:	74 7e                	je     808542 <tcp_enqueue+0x63a>
  8084c4:	66 85 ff             	test   %di,%di
  8084c7:	74 7d                	je     808546 <tcp_enqueue+0x63e>
  8084c9:	8b 5e 10             	mov    0x10(%esi),%ebx
  8084cc:	85 db                	test   %ebx,%ebx
  8084ce:	74 7a                	je     80854a <tcp_enqueue+0x642>
  8084d0:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8084d4:	75 78                	jne    80854e <tcp_enqueue+0x646>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8084d6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8084da:	89 04 24             	mov    %eax,(%esp)
  8084dd:	e8 a7 f7 ff ff       	call   807c89 <ntohs>
  8084e2:	83 c8 08             	or     $0x8,%eax
  8084e5:	0f b7 c0             	movzwl %ax,%eax
  8084e8:	89 04 24             	mov    %eax,(%esp)
  8084eb:	e8 8d f7 ff ff       	call   807c7d <htons>
  8084f0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  8084f4:	b0 00                	mov    $0x0,%al
  8084f6:	eb 64                	jmp    80855c <tcp_enqueue+0x654>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8084f8:	8b 55 08             	mov    0x8(%ebp),%edx
  8084fb:	80 4a 20 80          	orb    $0x80,0x20(%edx)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8084ff:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  808503:	74 0b                	je     808510 <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  808505:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  808508:	89 0c 24             	mov    %ecx,(%esp)
  80850b:	e8 20 d8 ff ff       	call   805d30 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  808510:	8b 45 08             	mov    0x8(%ebp),%eax
  808513:	66 83 78 70 00       	cmpw   $0x0,0x70(%eax)
  808518:	74 38                	je     808552 <tcp_enqueue+0x64a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80851a:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80851e:	75 36                	jne    808556 <tcp_enqueue+0x64e>
  808520:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  808524:	75 34                	jne    80855a <tcp_enqueue+0x652>
  808526:	c7 44 24 08 c8 1d 81 	movl   $0x811dc8,0x8(%esp)
  80852d:	00 
  80852e:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  808535:	00 
  808536:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  80853d:	e8 36 69 00 00       	call   80ee78 <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  808542:	b0 00                	mov    $0x0,%al
  808544:	eb 16                	jmp    80855c <tcp_enqueue+0x654>
  808546:	b0 00                	mov    $0x0,%al
  808548:	eb 12                	jmp    80855c <tcp_enqueue+0x654>
  80854a:	b0 00                	mov    $0x0,%al
  80854c:	eb 0e                	jmp    80855c <tcp_enqueue+0x654>
  80854e:	b0 00                	mov    $0x0,%al
  808550:	eb 0a                	jmp    80855c <tcp_enqueue+0x654>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  808552:	b0 ff                	mov    $0xff,%al
  808554:	eb 06                	jmp    80855c <tcp_enqueue+0x654>
  808556:	b0 ff                	mov    $0xff,%al
  808558:	eb 02                	jmp    80855c <tcp_enqueue+0x654>
  80855a:	b0 ff                	mov    $0xff,%al
}
  80855c:	83 c4 4c             	add    $0x4c,%esp
  80855f:	5b                   	pop    %ebx
  808560:	5e                   	pop    %esi
  808561:	5f                   	pop    %edi
  808562:	5d                   	pop    %ebp
  808563:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  808564:	8b 55 d0             	mov    -0x30(%ebp),%edx
  808567:	89 13                	mov    %edx,(%ebx)
  808569:	e9 e9 fe ff ff       	jmp    808457 <tcp_enqueue+0x54f>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80856e:	8a 45 e1             	mov    -0x1f(%ebp),%al
  808571:	c0 e8 02             	shr    $0x2,%al
  808574:	c1 e0 0c             	shl    $0xc,%eax
  808577:	05 00 50 00 00       	add    $0x5000,%eax
  80857c:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  808580:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  808583:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  808586:	8b 45 cc             	mov    -0x34(%ebp),%eax
  808589:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80858d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  808594:	bf 00 00 00 00       	mov    $0x0,%edi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  808599:	8a 55 b8             	mov    -0x48(%ebp),%dl
  80859c:	83 e2 01             	and    $0x1,%edx
  80859f:	89 55 c8             	mov    %edx,-0x38(%ebp)
  8085a2:	e9 7f fa ff ff       	jmp    808026 <tcp_enqueue+0x11e>
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  8085a7:	66 ff 45 cc          	incw   -0x34(%ebp)
  8085ab:	e9 c3 fe ff ff       	jmp    808473 <tcp_enqueue+0x56b>

008085b0 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8085b0:	55                   	push   %ebp
  8085b1:	89 e5                	mov    %esp,%ebp
  8085b3:	53                   	push   %ebx
  8085b4:	83 ec 24             	sub    $0x24,%esp
  8085b7:	8b 55 08             	mov    0x8(%ebp),%edx
  8085ba:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8085bd:	8a 5d 14             	mov    0x14(%ebp),%bl
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  8085c0:	8b 42 10             	mov    0x10(%edx),%eax
  8085c3:	83 f8 04             	cmp    $0x4,%eax
  8085c6:	74 0f                	je     8085d7 <tcp_write+0x27>
  8085c8:	83 f8 07             	cmp    $0x7,%eax
  8085cb:	74 0a                	je     8085d7 <tcp_write+0x27>
     pcb->state == CLOSE_WAIT ||
  8085cd:	83 f8 02             	cmp    $0x2,%eax
  8085d0:	74 05                	je     8085d7 <tcp_write+0x27>
     pcb->state == SYN_SENT ||
  8085d2:	83 f8 03             	cmp    $0x3,%eax
  8085d5:	75 3c                	jne    808613 <tcp_write+0x63>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  8085d7:	66 85 c9             	test   %cx,%cx
  8085da:	74 3b                	je     808617 <tcp_write+0x67>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8085dc:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  8085e3:	00 
  8085e4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8085eb:	00 
  8085ec:	0f b6 db             	movzbl %bl,%ebx
  8085ef:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  8085f3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8085fa:	00 
  8085fb:	0f b7 c9             	movzwl %cx,%ecx
  8085fe:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808602:	8b 45 0c             	mov    0xc(%ebp),%eax
  808605:	89 44 24 04          	mov    %eax,0x4(%esp)
  808609:	89 14 24             	mov    %edx,(%esp)
  80860c:	e8 f7 f8 ff ff       	call   807f08 <tcp_enqueue>
  808611:	eb 06                	jmp    808619 <tcp_write+0x69>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  808613:	b0 f8                	mov    $0xf8,%al
  808615:	eb 02                	jmp    808619 <tcp_write+0x69>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  808617:	b0 00                	mov    $0x0,%al
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  808619:	83 c4 24             	add    $0x24,%esp
  80861c:	5b                   	pop    %ebx
  80861d:	5d                   	pop    %ebp
  80861e:	c3                   	ret    

0080861f <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80861f:	55                   	push   %ebp
  808620:	89 e5                	mov    %esp,%ebp
  808622:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808625:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80862c:	00 
  80862d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808634:	00 
  808635:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80863c:	00 
  80863d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  808641:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808645:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80864c:	00 
  80864d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808654:	00 
  808655:	8b 45 08             	mov    0x8(%ebp),%eax
  808658:	89 04 24             	mov    %eax,(%esp)
  80865b:	e8 a8 f8 ff ff       	call   807f08 <tcp_enqueue>
}
  808660:	c9                   	leave  
  808661:	c3                   	ret    

00808662 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808662:	55                   	push   %ebp
  808663:	89 e5                	mov    %esp,%ebp
  808665:	57                   	push   %edi
  808666:	56                   	push   %esi
  808667:	53                   	push   %ebx
  808668:	83 ec 3c             	sub    $0x3c,%esp
  80866b:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80866e:	39 35 98 b2 b3 00    	cmp    %esi,0xb3b298
  808674:	0f 84 5a 04 00 00    	je     808ad4 <tcp_output+0x472>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80867a:	66 8b 56 4e          	mov    0x4e(%esi),%dx
  80867e:	8b 46 5c             	mov    0x5c(%esi),%eax
  808681:	66 39 d0             	cmp    %dx,%ax
  808684:	76 02                	jbe    808688 <tcp_output+0x26>
  808686:	89 d0                	mov    %edx,%eax
  808688:	0f b7 c0             	movzwl %ax,%eax
  80868b:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80868e:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808691:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  808694:	85 ff                	test   %edi,%edi
  808696:	75 04                	jne    80869c <tcp_output+0x3a>
  808698:	eb 08                	jmp    8086a2 <tcp_output+0x40>
    for (; useg->next != NULL; useg = useg->next);
  80869a:	89 c7                	mov    %eax,%edi
  80869c:	8b 07                	mov    (%edi),%eax
  80869e:	85 c0                	test   %eax,%eax
  8086a0:	75 f8                	jne    80869a <tcp_output+0x38>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  8086a2:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  8086a6:	0f 84 ba 03 00 00    	je     808a66 <tcp_output+0x404>
  8086ac:	85 db                	test   %ebx,%ebx
  8086ae:	74 20                	je     8086d0 <tcp_output+0x6e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  8086b0:	8b 43 10             	mov    0x10(%ebx),%eax
  8086b3:	8b 40 04             	mov    0x4(%eax),%eax
  8086b6:	89 04 24             	mov    %eax,(%esp)
  8086b9:	e8 35 f8 ff ff       	call   807ef3 <ntohl>
  8086be:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8086c2:	2b 56 48             	sub    0x48(%esi),%edx
  8086c5:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8086c7:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8086ca:	0f 83 96 03 00 00    	jae    808a66 <tcp_output+0x404>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8086d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8086d7:	00 
  8086d8:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8086df:	00 
  8086e0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8086e7:	e8 8a c8 ff ff       	call   804f76 <pbuf_alloc>
  8086ec:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  8086ee:	85 c0                	test   %eax,%eax
  8086f0:	0f 84 e2 03 00 00    	je     808ad8 <tcp_output+0x476>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8086f6:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  8086fa:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8086fd:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808701:	89 04 24             	mov    %eax,(%esp)
  808704:	e8 74 f5 ff ff       	call   807c7d <htons>
  808709:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80870c:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808710:	89 04 24             	mov    %eax,(%esp)
  808713:	e8 65 f5 ff ff       	call   807c7d <htons>
  808718:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80871c:	8b 46 54             	mov    0x54(%esi),%eax
  80871f:	89 04 24             	mov    %eax,(%esp)
  808722:	e8 76 f5 ff ff       	call   807c9d <htonl>
  808727:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80872a:	8b 46 24             	mov    0x24(%esi),%eax
  80872d:	89 04 24             	mov    %eax,(%esp)
  808730:	e8 68 f5 ff ff       	call   807c9d <htonl>
  808735:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808738:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80873c:	89 04 24             	mov    %eax,(%esp)
  80873f:	e8 45 f5 ff ff       	call   807c89 <ntohs>
  808744:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808749:	83 c8 10             	or     $0x10,%eax
  80874c:	89 04 24             	mov    %eax,(%esp)
  80874f:	e8 29 f5 ff ff       	call   807c7d <htons>
  808754:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808758:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80875c:	89 04 24             	mov    %eax,(%esp)
  80875f:	e8 19 f5 ff ff       	call   807c7d <htons>
  808764:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808768:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80876e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808772:	89 04 24             	mov    %eax,(%esp)
  808775:	e8 0f f5 ff ff       	call   807c89 <ntohs>
  80877a:	83 e0 3f             	and    $0x3f,%eax
  80877d:	80 cc 50             	or     $0x50,%ah
  808780:	89 04 24             	mov    %eax,(%esp)
  808783:	e8 f5 f4 ff ff       	call   807c7d <htons>
  808788:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80878c:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808792:	8d 46 04             	lea    0x4(%esi),%eax
  808795:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808798:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80879c:	89 44 24 10          	mov    %eax,0x10(%esp)
  8087a0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8087a7:	00 
  8087a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8087ab:	89 54 24 08          	mov    %edx,0x8(%esp)
  8087af:	89 74 24 04          	mov    %esi,0x4(%esp)
  8087b3:	89 3c 24             	mov    %edi,(%esp)
  8087b6:	e8 7d f1 ff ff       	call   807938 <inet_chksum_pseudo>
  8087bb:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8087bf:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8087c6:	00 
  8087c7:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  8087cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8087cf:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8087d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8087d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8087da:	89 44 24 08          	mov    %eax,0x8(%esp)
  8087de:	89 74 24 04          	mov    %esi,0x4(%esp)
  8087e2:	89 3c 24             	mov    %edi,(%esp)
  8087e5:	e8 a1 e6 ff ff       	call   806e8b <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8087ea:	89 3c 24             	mov    %edi,(%esp)
  8087ed:	e8 83 c5 ff ff       	call   804d75 <pbuf_free>

    return ERR_OK;
  8087f2:	b0 00                	mov    $0x0,%al
  8087f4:	e9 e1 02 00 00       	jmp    808ada <tcp_output+0x478>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8087f9:	8b 43 10             	mov    0x10(%ebx),%eax
  8087fc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808800:	89 04 24             	mov    %eax,(%esp)
  808803:	e8 81 f4 ff ff       	call   807c89 <ntohs>
  808808:	a8 04                	test   $0x4,%al
  80880a:	74 1c                	je     808828 <tcp_output+0x1c6>
  80880c:	c7 44 24 08 4f 1e 81 	movl   $0x811e4f,0x8(%esp)
  808813:	00 
  808814:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80881b:	00 
  80881c:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808823:	e8 50 66 00 00       	call   80ee78 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808828:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80882c:	74 1c                	je     80884a <tcp_output+0x1e8>
  80882e:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  808832:	a8 40                	test   $0x40,%al
  808834:	75 14                	jne    80884a <tcp_output+0x1e8>
  808836:	8b 56 74             	mov    0x74(%esi),%edx
  808839:	85 d2                	test   %edx,%edx
  80883b:	0f 84 a1 02 00 00    	je     808ae2 <tcp_output+0x480>
  808841:	83 3a 00             	cmpl   $0x0,(%edx)
  808844:	0f 84 98 02 00 00    	je     808ae2 <tcp_output+0x480>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80884a:	8b 03                	mov    (%ebx),%eax
  80884c:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80884f:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  808853:	74 25                	je     80887a <tcp_output+0x218>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808855:	8b 7b 10             	mov    0x10(%ebx),%edi
  808858:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80885c:	89 04 24             	mov    %eax,(%esp)
  80885f:	e8 25 f4 ff ff       	call   807c89 <ntohs>
  808864:	83 c8 10             	or     $0x10,%eax
  808867:	0f b7 c0             	movzwl %ax,%eax
  80886a:	89 04 24             	mov    %eax,(%esp)
  80886d:	e8 0b f4 ff ff       	call   807c7d <htons>
  808872:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808876:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80887a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80887d:	8b 46 24             	mov    0x24(%esi),%eax
  808880:	89 04 24             	mov    %eax,(%esp)
  808883:	e8 15 f4 ff ff       	call   807c9d <htonl>
  808888:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80888b:	8b 7b 10             	mov    0x10(%ebx),%edi
  80888e:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808892:	89 04 24             	mov    %eax,(%esp)
  808895:	e8 e3 f3 ff ff       	call   807c7d <htons>
  80889a:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80889e:	85 f6                	test   %esi,%esi
  8088a0:	74 05                	je     8088a7 <tcp_output+0x245>
  8088a2:	83 3e 00             	cmpl   $0x0,(%esi)
  8088a5:	75 24                	jne    8088cb <tcp_output+0x269>
    netif = ip_route(&(pcb->remote_ip));
  8088a7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8088aa:	89 14 24             	mov    %edx,(%esp)
  8088ad:	e8 52 e1 ff ff       	call   806a04 <ip_route>
    if (netif == NULL) {
  8088b2:	85 c0                	test   %eax,%eax
  8088b4:	0f 84 bf 00 00 00    	je     808979 <tcp_output+0x317>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8088ba:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8088bd:	74 05                	je     8088c4 <tcp_output+0x262>
  8088bf:	8b 40 04             	mov    0x4(%eax),%eax
  8088c2:	eb 05                	jmp    8088c9 <tcp_output+0x267>
  8088c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8088c9:	89 06                	mov    %eax,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8088cb:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  8088d0:	75 06                	jne    8088d8 <tcp_output+0x276>
    pcb->rtime = 0;
  8088d2:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  8088d8:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  8088dc:	75 19                	jne    8088f7 <tcp_output+0x295>
    pcb->rttest = tcp_ticks;
  8088de:	a1 80 b2 b3 00       	mov    0xb3b280,%eax
  8088e3:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8088e6:	8b 43 10             	mov    0x10(%ebx),%eax
  8088e9:	8b 40 04             	mov    0x4(%eax),%eax
  8088ec:	89 04 24             	mov    %eax,(%esp)
  8088ef:	e8 ff f5 ff ff       	call   807ef3 <ntohl>
  8088f4:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8088f7:	8b 43 04             	mov    0x4(%ebx),%eax
  8088fa:	8b 53 10             	mov    0x10(%ebx),%edx
  8088fd:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  808901:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  808905:	8b 43 04             	mov    0x4(%ebx),%eax
  808908:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80890c:	8b 43 04             	mov    0x4(%ebx),%eax
  80890f:	8b 53 10             	mov    0x10(%ebx),%edx
  808912:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  808915:	8b 43 10             	mov    0x10(%ebx),%eax
  808918:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80891e:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808921:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808924:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808928:	89 54 24 10          	mov    %edx,0x10(%esp)
  80892c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808933:	00 
  808934:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808937:	89 54 24 08          	mov    %edx,0x8(%esp)
  80893b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80893f:	89 04 24             	mov    %eax,(%esp)
  808942:	e8 f1 ef ff ff       	call   807938 <inet_chksum_pseudo>
  808947:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80894b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808952:	00 
  808953:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808957:	89 44 24 10          	mov    %eax,0x10(%esp)
  80895b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80895f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808963:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808966:	89 44 24 08          	mov    %eax,0x8(%esp)
  80896a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80896e:	8b 43 04             	mov    0x4(%ebx),%eax
  808971:	89 04 24             	mov    %eax,(%esp)
  808974:	e8 12 e5 ff ff       	call   806e8b <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808979:	8b 43 10             	mov    0x10(%ebx),%eax
  80897c:	8b 40 04             	mov    0x4(%eax),%eax
  80897f:	89 04 24             	mov    %eax,(%esp)
  808982:	e8 6c f5 ff ff       	call   807ef3 <ntohl>
  808987:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80898a:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80898e:	8b 43 10             	mov    0x10(%ebx),%eax
  808991:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808995:	89 04 24             	mov    %eax,(%esp)
  808998:	e8 ec f2 ff ff       	call   807c89 <ntohs>
  80899d:	a8 01                	test   $0x1,%al
  80899f:	75 1a                	jne    8089bb <tcp_output+0x359>
  8089a1:	8b 43 10             	mov    0x10(%ebx),%eax
  8089a4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8089a8:	89 04 24             	mov    %eax,(%esp)
  8089ab:	e8 d9 f2 ff ff       	call   807c89 <ntohs>
  8089b0:	83 e0 02             	and    $0x2,%eax
  8089b3:	0f 95 c0             	setne  %al
  8089b6:	0f b6 c0             	movzbl %al,%eax
  8089b9:	eb 05                	jmp    8089c0 <tcp_output+0x35e>
  8089bb:	b8 01 00 00 00       	mov    $0x1,%eax
  8089c0:	01 c7                	add    %eax,%edi
  8089c2:	03 7d e0             	add    -0x20(%ebp),%edi
  8089c5:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8089c8:	39 7e 58             	cmp    %edi,0x58(%esi)
  8089cb:	79 03                	jns    8089d0 <tcp_output+0x36e>
      pcb->snd_max = pcb->snd_nxt;
  8089cd:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  8089d0:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  8089d4:	8b 43 10             	mov    0x10(%ebx),%eax
  8089d7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8089db:	89 04 24             	mov    %eax,(%esp)
  8089de:	e8 a6 f2 ff ff       	call   807c89 <ntohs>
  8089e3:	a8 01                	test   $0x1,%al
  8089e5:	75 1a                	jne    808a01 <tcp_output+0x39f>
  8089e7:	8b 43 10             	mov    0x10(%ebx),%eax
  8089ea:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8089ee:	89 04 24             	mov    %eax,(%esp)
  8089f1:	e8 93 f2 ff ff       	call   807c89 <ntohs>
  8089f6:	83 e0 02             	and    $0x2,%eax
  8089f9:	0f 95 c0             	setne  %al
  8089fc:	0f b6 c0             	movzbl %al,%eax
  8089ff:	eb 05                	jmp    808a06 <tcp_output+0x3a4>
  808a01:	b8 01 00 00 00       	mov    $0x1,%eax
  808a06:	01 c7                	add    %eax,%edi
  808a08:	85 ff                	test   %edi,%edi
  808a0a:	7e 4d                	jle    808a59 <tcp_output+0x3f7>
      seg->next = NULL;
  808a0c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808a12:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  808a16:	75 08                	jne    808a20 <tcp_output+0x3be>
        pcb->unacked = seg;
  808a18:	89 5e 78             	mov    %ebx,0x78(%esi)
  808a1b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808a1e:	eb 41                	jmp    808a61 <tcp_output+0x3ff>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808a20:	8b 43 10             	mov    0x10(%ebx),%eax
  808a23:	8b 40 04             	mov    0x4(%eax),%eax
  808a26:	89 04 24             	mov    %eax,(%esp)
  808a29:	e8 c5 f4 ff ff       	call   807ef3 <ntohl>
  808a2e:	89 c7                	mov    %eax,%edi
  808a30:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808a33:	8b 42 10             	mov    0x10(%edx),%eax
  808a36:	8b 40 04             	mov    0x4(%eax),%eax
  808a39:	89 04 24             	mov    %eax,(%esp)
  808a3c:	e8 b2 f4 ff ff       	call   807ef3 <ntohl>
  808a41:	39 c7                	cmp    %eax,%edi
  808a43:	79 0a                	jns    808a4f <tcp_output+0x3ed>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808a45:	8b 46 78             	mov    0x78(%esi),%eax
  808a48:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808a4a:	89 5e 78             	mov    %ebx,0x78(%esi)
  808a4d:	eb 12                	jmp    808a61 <tcp_output+0x3ff>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808a4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808a52:	89 18                	mov    %ebx,(%eax)
  808a54:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808a57:	eb 08                	jmp    808a61 <tcp_output+0x3ff>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808a59:	89 1c 24             	mov    %ebx,(%esp)
  808a5c:	e8 88 d2 ff ff       	call   805ce9 <tcp_seg_free>
    }
    seg = pcb->unsent;
  808a61:	8b 5e 74             	mov    0x74(%esi),%ebx
  808a64:	eb 09                	jmp    808a6f <tcp_output+0x40d>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a66:	8d 56 04             	lea    0x4(%esi),%edx
  808a69:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808a6c:	89 7d dc             	mov    %edi,-0x24(%ebp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808a6f:	85 db                	test   %ebx,%ebx
  808a71:	74 59                	je     808acc <tcp_output+0x46a>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808a73:	8b 43 10             	mov    0x10(%ebx),%eax
  808a76:	8b 40 04             	mov    0x4(%eax),%eax
  808a79:	89 04 24             	mov    %eax,(%esp)
  808a7c:	e8 72 f4 ff ff       	call   807ef3 <ntohl>
  808a81:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808a85:	2b 56 48             	sub    0x48(%esi),%edx
  808a88:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808a8a:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808a8d:	0f 83 66 fd ff ff    	jae    8087f9 <tcp_output+0x197>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808a93:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  808a9a:	75 30                	jne    808acc <tcp_output+0x46a>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808a9c:	8b 43 10             	mov    0x10(%ebx),%eax
  808a9f:	8b 40 04             	mov    0x4(%eax),%eax
  808aa2:	89 04 24             	mov    %eax,(%esp)
  808aa5:	e8 49 f4 ff ff       	call   807ef3 <ntohl>
  808aaa:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808aae:	2b 56 48             	sub    0x48(%esi),%edx
  808ab1:	01 c2                	add    %eax,%edx
  808ab3:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808ab7:	39 c2                	cmp    %eax,%edx
  808ab9:	76 11                	jbe    808acc <tcp_output+0x46a>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808abb:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  808ac2:	00 00 00 
    pcb->persist_backoff = 1;
  808ac5:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808acc:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  return ERR_OK;
  808ad0:	b0 00                	mov    $0x0,%al
  808ad2:	eb 06                	jmp    808ada <tcp_output+0x478>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808ad4:	b0 00                	mov    $0x0,%al
  808ad6:	eb 02                	jmp    808ada <tcp_output+0x478>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808ad8:	b0 fe                	mov    $0xfe,%al
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808ada:	83 c4 3c             	add    $0x3c,%esp
  808add:	5b                   	pop    %ebx
  808ade:	5e                   	pop    %esi
  808adf:	5f                   	pop    %edi
  808ae0:	5d                   	pop    %ebp
  808ae1:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808ae2:	a8 a0                	test   $0xa0,%al
  808ae4:	0f 85 60 fd ff ff    	jne    80884a <tcp_output+0x1e8>
  808aea:	eb a7                	jmp    808a93 <tcp_output+0x431>

00808aec <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808aec:	55                   	push   %ebp
  808aed:	89 e5                	mov    %esp,%ebp
  808aef:	57                   	push   %edi
  808af0:	56                   	push   %esi
  808af1:	53                   	push   %ebx
  808af2:	83 ec 3c             	sub    $0x3c,%esp
  808af5:	8b 7d 18             	mov    0x18(%ebp),%edi
  808af8:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808afb:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808aff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808b06:	00 
  808b07:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808b0e:	00 
  808b0f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808b16:	e8 5b c4 ff ff       	call   804f76 <pbuf_alloc>
  808b1b:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808b1d:	85 c0                	test   %eax,%eax
  808b1f:	0f 84 1a 01 00 00    	je     808c3f <tcp_rst+0x153>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808b25:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808b2a:	77 1c                	ja     808b48 <tcp_rst+0x5c>
  808b2c:	c7 44 24 08 e8 1d 81 	movl   $0x811de8,0x8(%esp)
  808b33:	00 
  808b34:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  808b3b:	00 
  808b3c:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808b43:	e8 30 63 00 00       	call   80ee78 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808b48:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808b4b:	0f b7 ff             	movzwl %di,%edi
  808b4e:	89 3c 24             	mov    %edi,(%esp)
  808b51:	e8 27 f1 ff ff       	call   807c7d <htons>
  808b56:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808b59:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808b5d:	89 04 24             	mov    %eax,(%esp)
  808b60:	e8 18 f1 ff ff       	call   807c7d <htons>
  808b65:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808b69:	8b 45 08             	mov    0x8(%ebp),%eax
  808b6c:	89 04 24             	mov    %eax,(%esp)
  808b6f:	e8 29 f1 ff ff       	call   807c9d <htonl>
  808b74:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808b77:	8b 45 0c             	mov    0xc(%ebp),%eax
  808b7a:	89 04 24             	mov    %eax,(%esp)
  808b7d:	e8 1b f1 ff ff       	call   807c9d <htonl>
  808b82:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808b85:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b89:	89 04 24             	mov    %eax,(%esp)
  808b8c:	e8 f8 f0 ff ff       	call   807c89 <ntohs>
  808b91:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808b96:	83 c8 14             	or     $0x14,%eax
  808b99:	89 04 24             	mov    %eax,(%esp)
  808b9c:	e8 dc f0 ff ff       	call   807c7d <htons>
  808ba1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808ba5:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808bac:	e8 cc f0 ff ff       	call   807c7d <htons>
  808bb1:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808bb5:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808bbb:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808bbf:	89 04 24             	mov    %eax,(%esp)
  808bc2:	e8 c2 f0 ff ff       	call   807c89 <ntohs>
  808bc7:	83 e0 3f             	and    $0x3f,%eax
  808bca:	80 cc 50             	or     $0x50,%ah
  808bcd:	89 04 24             	mov    %eax,(%esp)
  808bd0:	e8 a8 f0 ff ff       	call   807c7d <htons>
  808bd5:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808bd9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808bdf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808be3:	89 44 24 10          	mov    %eax,0x10(%esp)
  808be7:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808bee:	00 
  808bef:	8b 45 14             	mov    0x14(%ebp),%eax
  808bf2:	89 44 24 08          	mov    %eax,0x8(%esp)
  808bf6:	8b 45 10             	mov    0x10(%ebp),%eax
  808bf9:	89 44 24 04          	mov    %eax,0x4(%esp)
  808bfd:	89 34 24             	mov    %esi,(%esp)
  808c00:	e8 33 ed ff ff       	call   807938 <inet_chksum_pseudo>
  808c05:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808c09:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808c10:	00 
  808c11:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808c18:	00 
  808c19:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  808c20:	00 
  808c21:	8b 45 14             	mov    0x14(%ebp),%eax
  808c24:	89 44 24 08          	mov    %eax,0x8(%esp)
  808c28:	8b 45 10             	mov    0x10(%ebp),%eax
  808c2b:	89 44 24 04          	mov    %eax,0x4(%esp)
  808c2f:	89 34 24             	mov    %esi,(%esp)
  808c32:	e8 54 e2 ff ff       	call   806e8b <ip_output>
  pbuf_free(p);
  808c37:	89 34 24             	mov    %esi,(%esp)
  808c3a:	e8 36 c1 ff ff       	call   804d75 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808c3f:	83 c4 3c             	add    $0x3c,%esp
  808c42:	5b                   	pop    %ebx
  808c43:	5e                   	pop    %esi
  808c44:	5f                   	pop    %edi
  808c45:	5d                   	pop    %ebp
  808c46:	c3                   	ret    

00808c47 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808c47:	55                   	push   %ebp
  808c48:	89 e5                	mov    %esp,%ebp
  808c4a:	53                   	push   %ebx
  808c4b:	83 ec 14             	sub    $0x14,%esp
  808c4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808c51:	8b 53 78             	mov    0x78(%ebx),%edx
  808c54:	85 d2                	test   %edx,%edx
  808c56:	75 04                	jne    808c5c <tcp_rexmit_rto+0x15>
  808c58:	eb 3d                	jmp    808c97 <tcp_rexmit_rto+0x50>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808c5a:	89 c2                	mov    %eax,%edx
  808c5c:	8b 02                	mov    (%edx),%eax
  808c5e:	85 c0                	test   %eax,%eax
  808c60:	75 f8                	jne    808c5a <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808c62:	8b 43 74             	mov    0x74(%ebx),%eax
  808c65:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808c67:	8b 43 78             	mov    0x78(%ebx),%eax
  808c6a:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808c6d:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808c74:	8b 40 10             	mov    0x10(%eax),%eax
  808c77:	8b 40 04             	mov    0x4(%eax),%eax
  808c7a:	89 04 24             	mov    %eax,(%esp)
  808c7d:	e8 71 f2 ff ff       	call   807ef3 <ntohl>
  808c82:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808c85:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808c88:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808c8f:	89 1c 24             	mov    %ebx,(%esp)
  808c92:	e8 cb f9 ff ff       	call   808662 <tcp_output>
}
  808c97:	83 c4 14             	add    $0x14,%esp
  808c9a:	5b                   	pop    %ebx
  808c9b:	5d                   	pop    %ebp
  808c9c:	c3                   	ret    

00808c9d <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808c9d:	55                   	push   %ebp
  808c9e:	89 e5                	mov    %esp,%ebp
  808ca0:	53                   	push   %ebx
  808ca1:	83 ec 14             	sub    $0x14,%esp
  808ca4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808ca7:	8b 43 78             	mov    0x78(%ebx),%eax
  808caa:	85 c0                	test   %eax,%eax
  808cac:	74 33                	je     808ce1 <tcp_rexmit+0x44>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808cae:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808cb0:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808cb3:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808cb5:	8b 43 78             	mov    0x78(%ebx),%eax
  808cb8:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808cbb:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808cbe:	8b 40 10             	mov    0x10(%eax),%eax
  808cc1:	8b 40 04             	mov    0x4(%eax),%eax
  808cc4:	89 04 24             	mov    %eax,(%esp)
  808cc7:	e8 27 f2 ff ff       	call   807ef3 <ntohl>
  808ccc:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808ccf:	fe 43 46             	incb   0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808cd2:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808cd9:	89 1c 24             	mov    %ebx,(%esp)
  808cdc:	e8 81 f9 ff ff       	call   808662 <tcp_output>
}
  808ce1:	83 c4 14             	add    $0x14,%esp
  808ce4:	5b                   	pop    %ebx
  808ce5:	5d                   	pop    %ebp
  808ce6:	c3                   	ret    

00808ce7 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808ce7:	55                   	push   %ebp
  808ce8:	89 e5                	mov    %esp,%ebp
  808cea:	57                   	push   %edi
  808ceb:	56                   	push   %esi
  808cec:	53                   	push   %ebx
  808ced:	83 ec 3c             	sub    $0x3c,%esp
  808cf0:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808cf3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808cfa:	00 
  808cfb:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808d02:	00 
  808d03:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808d0a:	e8 67 c2 ff ff       	call   804f76 <pbuf_alloc>
  808d0f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808d11:	85 c0                	test   %eax,%eax
  808d13:	0f 84 19 01 00 00    	je     808e32 <tcp_keepalive+0x14b>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808d19:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808d1e:	77 1c                	ja     808d3c <tcp_keepalive+0x55>
  808d20:	c7 44 24 08 e8 1d 81 	movl   $0x811de8,0x8(%esp)
  808d27:	00 
  808d28:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  808d2f:	00 
  808d30:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808d37:	e8 3c 61 00 00       	call   80ee78 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808d3c:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808d3f:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808d43:	89 04 24             	mov    %eax,(%esp)
  808d46:	e8 32 ef ff ff       	call   807c7d <htons>
  808d4b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808d4e:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808d52:	89 04 24             	mov    %eax,(%esp)
  808d55:	e8 23 ef ff ff       	call   807c7d <htons>
  808d5a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808d5e:	8b 46 54             	mov    0x54(%esi),%eax
  808d61:	48                   	dec    %eax
  808d62:	89 04 24             	mov    %eax,(%esp)
  808d65:	e8 33 ef ff ff       	call   807c9d <htonl>
  808d6a:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808d6d:	8b 46 24             	mov    0x24(%esi),%eax
  808d70:	89 04 24             	mov    %eax,(%esp)
  808d73:	e8 25 ef ff ff       	call   807c9d <htonl>
  808d78:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808d7b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808d7f:	89 04 24             	mov    %eax,(%esp)
  808d82:	e8 02 ef ff ff       	call   807c89 <ntohs>
  808d87:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808d8c:	89 04 24             	mov    %eax,(%esp)
  808d8f:	e8 e9 ee ff ff       	call   807c7d <htons>
  808d94:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808d98:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808d9c:	89 04 24             	mov    %eax,(%esp)
  808d9f:	e8 d9 ee ff ff       	call   807c7d <htons>
  808da4:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808da8:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808dae:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808db2:	89 04 24             	mov    %eax,(%esp)
  808db5:	e8 cf ee ff ff       	call   807c89 <ntohs>
  808dba:	83 e0 3f             	and    $0x3f,%eax
  808dbd:	80 cc 50             	or     $0x50,%ah
  808dc0:	89 04 24             	mov    %eax,(%esp)
  808dc3:	e8 b5 ee ff ff       	call   807c7d <htons>
  808dc8:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808dcc:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808dd2:	8d 46 04             	lea    0x4(%esi),%eax
  808dd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808dd8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808ddc:	89 44 24 10          	mov    %eax,0x10(%esp)
  808de0:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808de7:	00 
  808de8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808deb:	89 44 24 08          	mov    %eax,0x8(%esp)
  808def:	89 74 24 04          	mov    %esi,0x4(%esp)
  808df3:	89 3c 24             	mov    %edi,(%esp)
  808df6:	e8 3d eb ff ff       	call   807938 <inet_chksum_pseudo>
  808dfb:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808dff:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808e06:	00 
  808e07:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808e0e:	00 
  808e0f:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808e13:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808e17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808e1a:	89 44 24 08          	mov    %eax,0x8(%esp)
  808e1e:	89 74 24 04          	mov    %esi,0x4(%esp)
  808e22:	89 3c 24             	mov    %edi,(%esp)
  808e25:	e8 61 e0 ff ff       	call   806e8b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808e2a:	89 3c 24             	mov    %edi,(%esp)
  808e2d:	e8 43 bf ff ff       	call   804d75 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808e32:	83 c4 3c             	add    $0x3c,%esp
  808e35:	5b                   	pop    %ebx
  808e36:	5e                   	pop    %esi
  808e37:	5f                   	pop    %edi
  808e38:	5d                   	pop    %ebp
  808e39:	c3                   	ret    

00808e3a <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808e3a:	55                   	push   %ebp
  808e3b:	89 e5                	mov    %esp,%ebp
  808e3d:	57                   	push   %edi
  808e3e:	56                   	push   %esi
  808e3f:	53                   	push   %ebx
  808e40:	83 ec 3c             	sub    $0x3c,%esp
  808e43:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808e46:	8b 46 78             	mov    0x78(%esi),%eax
  808e49:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808e4c:	85 c0                	test   %eax,%eax
  808e4e:	75 0e                	jne    808e5e <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808e50:	8b 56 74             	mov    0x74(%esi),%edx
  808e53:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  808e56:	85 d2                	test   %edx,%edx
  808e58:	0f 84 4a 01 00 00    	je     808fa8 <tcp_zero_window_probe+0x16e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808e5e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808e65:	00 
  808e66:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  808e6d:	00 
  808e6e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808e75:	e8 fc c0 ff ff       	call   804f76 <pbuf_alloc>
  808e7a:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808e7c:	85 c0                	test   %eax,%eax
  808e7e:	0f 84 24 01 00 00    	je     808fa8 <tcp_zero_window_probe+0x16e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808e84:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808e89:	77 1c                	ja     808ea7 <tcp_zero_window_probe+0x6d>
  808e8b:	c7 44 24 08 e8 1d 81 	movl   $0x811de8,0x8(%esp)
  808e92:	00 
  808e93:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808e9a:	00 
  808e9b:	c7 04 24 16 1e 81 00 	movl   $0x811e16,(%esp)
  808ea2:	e8 d1 5f 00 00       	call   80ee78 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808ea7:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808eaa:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808eae:	89 04 24             	mov    %eax,(%esp)
  808eb1:	e8 c7 ed ff ff       	call   807c7d <htons>
  808eb6:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808eb9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808ebd:	89 04 24             	mov    %eax,(%esp)
  808ec0:	e8 b8 ed ff ff       	call   807c7d <htons>
  808ec5:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808ec9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808ecc:	8b 41 10             	mov    0x10(%ecx),%eax
  808ecf:	8b 40 04             	mov    0x4(%eax),%eax
  808ed2:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808ed5:	8b 46 24             	mov    0x24(%esi),%eax
  808ed8:	89 04 24             	mov    %eax,(%esp)
  808edb:	e8 bd ed ff ff       	call   807c9d <htonl>
  808ee0:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808ee3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ee7:	89 04 24             	mov    %eax,(%esp)
  808eea:	e8 9a ed ff ff       	call   807c89 <ntohs>
  808eef:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808ef4:	89 04 24             	mov    %eax,(%esp)
  808ef7:	e8 81 ed ff ff       	call   807c7d <htons>
  808efc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808f00:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808f04:	89 04 24             	mov    %eax,(%esp)
  808f07:	e8 71 ed ff ff       	call   807c7d <htons>
  808f0c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808f10:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808f16:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808f1a:	89 04 24             	mov    %eax,(%esp)
  808f1d:	e8 67 ed ff ff       	call   807c89 <ntohs>
  808f22:	83 e0 3f             	and    $0x3f,%eax
  808f25:	80 cc 50             	or     $0x50,%ah
  808f28:	89 04 24             	mov    %eax,(%esp)
  808f2b:	e8 4d ed ff ff       	call   807c7d <htons>
  808f30:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808f34:	8b 47 04             	mov    0x4(%edi),%eax
  808f37:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808f3a:	8b 51 08             	mov    0x8(%ecx),%edx
  808f3d:	8a 12                	mov    (%edx),%dl
  808f3f:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808f42:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808f48:	8d 46 04             	lea    0x4(%esi),%eax
  808f4b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808f4e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808f52:	89 44 24 10          	mov    %eax,0x10(%esp)
  808f56:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808f5d:	00 
  808f5e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808f61:	89 54 24 08          	mov    %edx,0x8(%esp)
  808f65:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f69:	89 3c 24             	mov    %edi,(%esp)
  808f6c:	e8 c7 e9 ff ff       	call   807938 <inet_chksum_pseudo>
  808f71:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808f75:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808f7c:	00 
  808f7d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808f84:	00 
  808f85:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808f89:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808f8d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808f90:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808f94:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f98:	89 3c 24             	mov    %edi,(%esp)
  808f9b:	e8 eb de ff ff       	call   806e8b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808fa0:	89 3c 24             	mov    %edi,(%esp)
  808fa3:	e8 cd bd ff ff       	call   804d75 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808fa8:	83 c4 3c             	add    $0x3c,%esp
  808fab:	5b                   	pop    %ebx
  808fac:	5e                   	pop    %esi
  808fad:	5f                   	pop    %edi
  808fae:	5d                   	pop    %ebp
  808faf:	c3                   	ret    

00808fb0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808fb0:	55                   	push   %ebp
  808fb1:	89 e5                	mov    %esp,%ebp
  808fb3:	57                   	push   %edi
  808fb4:	56                   	push   %esi
  808fb5:	53                   	push   %ebx
  808fb6:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808fb9:	8b 45 08             	mov    0x8(%ebp),%eax
  808fbc:	8b 40 04             	mov    0x4(%eax),%eax
  808fbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808fc2:	8b 55 08             	mov    0x8(%ebp),%edx
  808fc5:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  808fc9:	0f b7 00             	movzwl (%eax),%eax
  808fcc:	89 04 24             	mov    %eax,(%esp)
  808fcf:	e8 b5 ec ff ff       	call   807c89 <ntohs>
  808fd4:	0f b6 c4             	movzbl %ah,%eax
  808fd7:	83 e0 0f             	and    $0xf,%eax
  808fda:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808fe1:	39 c3                	cmp    %eax,%ebx
  808fe3:	7c 2b                	jl     809010 <udp_input+0x60>
  808fe5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808fe8:	0f b7 02             	movzwl (%edx),%eax
  808feb:	89 04 24             	mov    %eax,(%esp)
  808fee:	e8 96 ec ff ff       	call   807c89 <ntohs>
  808ff3:	66 c1 e8 06          	shr    $0x6,%ax
  808ff7:	83 e0 3c             	and    $0x3c,%eax
  808ffa:	f7 d8                	neg    %eax
  808ffc:	98                   	cwtl   
  808ffd:	89 44 24 04          	mov    %eax,0x4(%esp)
  809001:	8b 45 08             	mov    0x8(%ebp),%eax
  809004:	89 04 24             	mov    %eax,(%esp)
  809007:	e8 84 bc ff ff       	call   804c90 <pbuf_header>
  80900c:	84 c0                	test   %al,%al
  80900e:	74 10                	je     809020 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  809010:	8b 55 08             	mov    0x8(%ebp),%edx
  809013:	89 14 24             	mov    %edx,(%esp)
  809016:	e8 5a bd ff ff       	call   804d75 <pbuf_free>
    goto end;
  80901b:	e9 fa 02 00 00       	jmp    80931a <udp_input+0x36a>
  }

  udphdr = (struct udp_hdr *)p->payload;
  809020:	8b 45 08             	mov    0x8(%ebp),%eax
  809023:	8b 40 04             	mov    0x4(%eax),%eax
  809026:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  809029:	0f b7 00             	movzwl (%eax),%eax
  80902c:	89 04 24             	mov    %eax,(%esp)
  80902f:	e8 55 ec ff ff       	call   807c89 <ntohs>
  809034:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  809038:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80903b:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80903f:	89 04 24             	mov    %eax,(%esp)
  809042:	e8 42 ec ff ff       	call   807c89 <ntohs>
  809047:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809049:	66 83 f8 44          	cmp    $0x44,%ax
  80904d:	75 4e                	jne    80909d <udp_input+0xed>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80904f:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  809054:	0f 85 fa 00 00 00    	jne    809154 <udp_input+0x1a4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80905a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80905d:	8b 42 20             	mov    0x20(%edx),%eax
  809060:	85 c0                	test   %eax,%eax
  809062:	0f 84 f3 00 00 00    	je     80915b <udp_input+0x1ab>
  809068:	8b 58 08             	mov    0x8(%eax),%ebx
  80906b:	85 db                	test   %ebx,%ebx
  80906d:	0f 84 ed 00 00 00    	je     809160 <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  809073:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809076:	0f 84 fb 00 00 00    	je     809177 <udp_input+0x1c7>
  80907c:	8b 43 04             	mov    0x4(%ebx),%eax
  80907f:	85 c0                	test   %eax,%eax
  809081:	0f 84 f0 00 00 00    	je     809177 <udp_input+0x1c7>
  809087:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80908a:	3b 42 0c             	cmp    0xc(%edx),%eax
  80908d:	0f 84 e4 00 00 00    	je     809177 <udp_input+0x1c7>
  809093:	bb 00 00 00 00       	mov    $0x0,%ebx
  809098:	e9 c3 00 00 00       	jmp    809160 <udp_input+0x1b0>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80909d:	8b 1d 94 b2 b3 00    	mov    0xb3b294,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  8090a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  8090aa:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8090af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8090b2:	83 c0 10             	add    $0x10,%eax
  8090b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8090b8:	e9 84 00 00 00       	jmp    809141 <udp_input+0x191>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8090bd:	66 39 73 12          	cmp    %si,0x12(%ebx)
  8090c1:	75 79                	jne    80913c <udp_input+0x18c>
  8090c3:	85 db                	test   %ebx,%ebx
  8090c5:	74 24                	je     8090eb <udp_input+0x13b>
          (ip_addr_isany(&pcb->local_ip) ||
  8090c7:	8b 03                	mov    (%ebx),%eax
  8090c9:	85 c0                	test   %eax,%eax
  8090cb:	74 1e                	je     8090eb <udp_input+0x13b>
  8090cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8090d0:	3b 42 10             	cmp    0x10(%edx),%eax
  8090d3:	74 16                	je     8090eb <udp_input+0x13b>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8090d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8090d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8090dc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8090df:	89 14 24             	mov    %edx,(%esp)
  8090e2:	e8 d9 d8 ff ff       	call   8069c0 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8090e7:	84 c0                	test   %al,%al
  8090e9:	74 51                	je     80913c <udp_input+0x18c>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8090eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8090ef:	0f 85 0a 02 00 00    	jne    8092ff <udp_input+0x34f>
  8090f5:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  8090f9:	0f 84 fd 01 00 00    	je     8092fc <udp_input+0x34c>
  8090ff:	e9 fb 01 00 00       	jmp    8092ff <udp_input+0x34f>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  809104:	83 fb fc             	cmp    $0xfffffffc,%ebx
  809107:	74 13                	je     80911c <udp_input+0x16c>
          (ip_addr_isany(&pcb->remote_ip) ||
  809109:	8b 43 04             	mov    0x4(%ebx),%eax
  80910c:	85 c0                	test   %eax,%eax
  80910e:	74 10                	je     809120 <udp_input+0x170>
  809110:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809113:	3b 42 0c             	cmp    0xc(%edx),%eax
  809116:	75 24                	jne    80913c <udp_input+0x18c>
  809118:	89 d8                	mov    %ebx,%eax
  80911a:	eb 06                	jmp    809122 <udp_input+0x172>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80911c:	89 d8                	mov    %ebx,%eax
  80911e:	eb 02                	jmp    809122 <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  809120:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  809122:	85 ff                	test   %edi,%edi
  809124:	74 51                	je     809177 <udp_input+0x1c7>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  809126:	8b 50 0c             	mov    0xc(%eax),%edx
  809129:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80912c:	8b 15 94 b2 b3 00    	mov    0xb3b294,%edx
  809132:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  809135:	a3 94 b2 b3 00       	mov    %eax,0xb3b294
  80913a:	eb 3b                	jmp    809177 <udp_input+0x1c7>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80913c:	89 df                	mov    %ebx,%edi
  80913e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  809141:	85 db                	test   %ebx,%ebx
  809143:	0f 85 74 ff ff ff    	jne    8090bd <udp_input+0x10d>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809149:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80914d:	75 25                	jne    809174 <udp_input+0x1c4>
  80914f:	e9 be 01 00 00       	jmp    809312 <udp_input+0x362>
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  809154:	bb 00 00 00 00       	mov    $0x0,%ebx
  809159:	eb 05                	jmp    809160 <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80915b:	bb 00 00 00 00       	mov    $0x0,%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809160:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809163:	8b 50 10             	mov    0x10(%eax),%edx
  809166:	8b 45 0c             	mov    0xc(%ebp),%eax
  809169:	39 50 04             	cmp    %edx,0x4(%eax)
  80916c:	0f 85 7d 01 00 00    	jne    8092ef <udp_input+0x33f>
  809172:	eb 03                	jmp    809177 <udp_input+0x1c7>
  809174:	8b 5d e0             	mov    -0x20(%ebp),%ebx
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  809177:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80917a:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80917f:	74 44                	je     8091c5 <udp_input+0x215>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  809181:	8b 55 08             	mov    0x8(%ebp),%edx
  809184:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  809188:	89 44 24 10          	mov    %eax,0x10(%esp)
  80918c:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  809193:	00 
  809194:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809197:	83 c0 10             	add    $0x10,%eax
  80919a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80919e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8091a1:	83 c0 0c             	add    $0xc,%eax
  8091a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8091a8:	89 14 24             	mov    %edx,(%esp)
  8091ab:	e8 88 e7 ff ff       	call   807938 <inet_chksum_pseudo>
  8091b0:	66 85 c0             	test   %ax,%ax
  8091b3:	74 10                	je     8091c5 <udp_input+0x215>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8091b5:	8b 45 08             	mov    0x8(%ebp),%eax
  8091b8:	89 04 24             	mov    %eax,(%esp)
  8091bb:	e8 b5 bb ff ff       	call   804d75 <pbuf_free>
          goto end;
  8091c0:	e9 55 01 00 00       	jmp    80931a <udp_input+0x36a>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8091c5:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  8091cc:	ff 
  8091cd:	8b 55 08             	mov    0x8(%ebp),%edx
  8091d0:	89 14 24             	mov    %edx,(%esp)
  8091d3:	e8 b8 ba ff ff       	call   804c90 <pbuf_header>
  8091d8:	84 c0                	test   %al,%al
  8091da:	74 1c                	je     8091f8 <udp_input+0x248>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8091dc:	c7 44 24 08 3b 1e 81 	movl   $0x811e3b,0x8(%esp)
  8091e3:	00 
  8091e4:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  8091eb:	00 
  8091ec:	c7 04 24 66 1e 81 00 	movl   $0x811e66,(%esp)
  8091f3:	e8 80 5c 00 00       	call   80ee78 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8091f8:	85 db                	test   %ebx,%ebx
  8091fa:	74 41                	je     80923d <udp_input+0x28d>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8091fc:	8b 43 18             	mov    0x18(%ebx),%eax
  8091ff:	85 c0                	test   %eax,%eax
  809201:	74 2a                	je     80922d <udp_input+0x27d>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  809203:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  809207:	89 54 24 10          	mov    %edx,0x10(%esp)
  80920b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80920e:	83 c2 0c             	add    $0xc,%edx
  809211:	89 54 24 0c          	mov    %edx,0xc(%esp)
  809215:	8b 55 08             	mov    0x8(%ebp),%edx
  809218:	89 54 24 08          	mov    %edx,0x8(%esp)
  80921c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809220:	8b 53 1c             	mov    0x1c(%ebx),%edx
  809223:	89 14 24             	mov    %edx,(%esp)
  809226:	ff d0                	call   *%eax
  809228:	e9 ed 00 00 00       	jmp    80931a <udp_input+0x36a>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80922d:	8b 45 08             	mov    0x8(%ebp),%eax
  809230:	89 04 24             	mov    %eax,(%esp)
  809233:	e8 3d bb ff ff       	call   804d75 <pbuf_free>
        goto end;
  809238:	e9 dd 00 00 00       	jmp    80931a <udp_input+0x36a>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80923d:	8b 55 0c             	mov    0xc(%ebp),%edx
  809240:	89 54 24 04          	mov    %edx,0x4(%esp)
  809244:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809247:	83 c0 10             	add    $0x10,%eax
  80924a:	89 04 24             	mov    %eax,(%esp)
  80924d:	e8 6e d7 ff ff       	call   8069c0 <ip_addr_isbroadcast>
  809252:	84 c0                	test   %al,%al
  809254:	0f 85 88 00 00 00    	jne    8092e2 <udp_input+0x332>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80925a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80925d:	8b 58 10             	mov    0x10(%eax),%ebx
  809260:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809267:	e8 87 ec ff ff       	call   807ef3 <ntohl>
  80926c:	21 c3                	and    %eax,%ebx
  80926e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809275:	e8 79 ec ff ff       	call   807ef3 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80927a:	39 c3                	cmp    %eax,%ebx
  80927c:	74 64                	je     8092e2 <udp_input+0x332>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80927e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809281:	0f b7 02             	movzwl (%edx),%eax
  809284:	89 04 24             	mov    %eax,(%esp)
  809287:	e8 fd e9 ff ff       	call   807c89 <ntohs>
  80928c:	0f b6 c4             	movzbl %ah,%eax
  80928f:	83 e0 0f             	and    $0xf,%eax
  809292:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  809299:	89 44 24 04          	mov    %eax,0x4(%esp)
  80929d:	8b 45 08             	mov    0x8(%ebp),%eax
  8092a0:	89 04 24             	mov    %eax,(%esp)
  8092a3:	e8 e8 b9 ff ff       	call   804c90 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  8092a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8092ab:	8b 55 08             	mov    0x8(%ebp),%edx
  8092ae:	39 42 04             	cmp    %eax,0x4(%edx)
  8092b1:	74 1c                	je     8092cf <udp_input+0x31f>
  8092b3:	c7 44 24 08 7a 1e 81 	movl   $0x811e7a,0x8(%esp)
  8092ba:	00 
  8092bb:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8092c2:	00 
  8092c3:	c7 04 24 66 1e 81 00 	movl   $0x811e66,(%esp)
  8092ca:	e8 a9 5b 00 00       	call   80ee78 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8092cf:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  8092d6:	00 
  8092d7:	8b 55 08             	mov    0x8(%ebp),%edx
  8092da:	89 14 24             	mov    %edx,(%esp)
  8092dd:	e8 15 59 00 00       	call   80ebf7 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8092e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8092e5:	89 04 24             	mov    %eax,(%esp)
  8092e8:	e8 88 ba ff ff       	call   804d75 <pbuf_free>
  8092ed:	eb 2b                	jmp    80931a <udp_input+0x36a>
    }
  } else {
    pbuf_free(p);
  8092ef:	8b 55 08             	mov    0x8(%ebp),%edx
  8092f2:	89 14 24             	mov    %edx,(%esp)
  8092f5:	e8 7b ba ff ff       	call   804d75 <pbuf_free>
  8092fa:	eb 1e                	jmp    80931a <udp_input+0x36a>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8092fc:	89 5d e0             	mov    %ebx,-0x20(%ebp)
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8092ff:	66 8b 45 de          	mov    -0x22(%ebp),%ax
  809303:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  809307:	0f 85 2f fe ff ff    	jne    80913c <udp_input+0x18c>
  80930d:	e9 f2 fd ff ff       	jmp    809104 <udp_input+0x154>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809312:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  809315:	e9 46 fe ff ff       	jmp    809160 <udp_input+0x1b0>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80931a:	83 c4 4c             	add    $0x4c,%esp
  80931d:	5b                   	pop    %ebx
  80931e:	5e                   	pop    %esi
  80931f:	5f                   	pop    %edi
  809320:	5d                   	pop    %ebp
  809321:	c3                   	ret    

00809322 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809322:	55                   	push   %ebp
  809323:	89 e5                	mov    %esp,%ebp
  809325:	57                   	push   %edi
  809326:	56                   	push   %esi
  809327:	53                   	push   %ebx
  809328:	83 ec 1c             	sub    $0x1c,%esp
  80932b:	8b 55 08             	mov    0x8(%ebp),%edx
  80932e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809331:	8b 4d 10             	mov    0x10(%ebp),%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809334:	a1 94 b2 b3 00       	mov    0xb3b294,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  809339:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80933e:	eb 2e                	jmp    80936e <udp_bind+0x4c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  809340:	39 c2                	cmp    %eax,%edx
  809342:	75 27                	jne    80936b <udp_bind+0x49>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  809344:	89 f3                	mov    %esi,%ebx
  809346:	84 db                	test   %bl,%bl
  809348:	74 1c                	je     809366 <udp_bind+0x44>
  80934a:	c7 44 24 08 8e 1e 81 	movl   $0x811e8e,0x8(%esp)
  809351:	00 
  809352:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  809359:	00 
  80935a:	c7 04 24 66 1e 81 00 	movl   $0x811e66,(%esp)
  809361:	e8 12 5b 00 00       	call   80ee78 <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  809366:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80936b:	8b 40 0c             	mov    0xc(%eax),%eax
  80936e:	85 c0                	test   %eax,%eax
  809370:	75 ce                	jne    809340 <udp_bind+0x1e>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  809372:	85 ff                	test   %edi,%edi
  809374:	74 04                	je     80937a <udp_bind+0x58>
  809376:	8b 07                	mov    (%edi),%eax
  809378:	eb 05                	jmp    80937f <udp_bind+0x5d>
  80937a:	b8 00 00 00 00       	mov    $0x0,%eax
  80937f:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  809381:	66 85 c9             	test   %cx,%cx
  809384:	75 31                	jne    8093b7 <udp_bind+0x95>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  809386:	8b 3d 94 b2 b3 00    	mov    0xb3b294,%edi
  80938c:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  80938e:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  809393:	eb 13                	jmp    8093a8 <udp_bind+0x86>
      if (ipcb->local_port == port) {
  809395:	66 8b 58 12          	mov    0x12(%eax),%bx
  809399:	66 39 cb             	cmp    %cx,%bx
  80939c:	75 07                	jne    8093a5 <udp_bind+0x83>
        /* port is already used by another udp_pcb */
        port++;
  80939e:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  8093a1:	89 f8                	mov    %edi,%eax
  8093a3:	eb 03                	jmp    8093a8 <udp_bind+0x86>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8093a5:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8093a8:	85 c0                	test   %eax,%eax
  8093aa:	74 0b                	je     8093b7 <udp_bind+0x95>
  8093ac:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  8093b1:	75 e2                	jne    809395 <udp_bind+0x73>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8093b3:	b0 f5                	mov    $0xf5,%al
  8093b5:	eb 1e                	jmp    8093d5 <udp_bind+0xb3>
    }
  }
  pcb->local_port = port;
  8093b7:	66 89 4a 12          	mov    %cx,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8093bb:	89 f0                	mov    %esi,%eax
  8093bd:	84 c0                	test   %al,%al
  8093bf:	75 12                	jne    8093d3 <udp_bind+0xb1>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8093c1:	a1 94 b2 b3 00       	mov    0xb3b294,%eax
  8093c6:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  8093c9:	89 15 94 b2 b3 00    	mov    %edx,0xb3b294
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8093cf:	b0 00                	mov    $0x0,%al
  8093d1:	eb 02                	jmp    8093d5 <udp_bind+0xb3>
  8093d3:	b0 00                	mov    $0x0,%al
}
  8093d5:	83 c4 1c             	add    $0x1c,%esp
  8093d8:	5b                   	pop    %ebx
  8093d9:	5e                   	pop    %esi
  8093da:	5f                   	pop    %edi
  8093db:	5d                   	pop    %ebp
  8093dc:	c3                   	ret    

008093dd <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  8093dd:	55                   	push   %ebp
  8093de:	89 e5                	mov    %esp,%ebp
  8093e0:	57                   	push   %edi
  8093e1:	56                   	push   %esi
  8093e2:	53                   	push   %ebx
  8093e3:	83 ec 3c             	sub    $0x3c,%esp
  8093e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8093e9:	8b 45 14             	mov    0x14(%ebp),%eax
  8093ec:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  8093f0:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8093f5:	75 1e                	jne    809415 <udp_sendto_if+0x38>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8093f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8093fe:	00 
  8093ff:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809403:	89 1c 24             	mov    %ebx,(%esp)
  809406:	e8 17 ff ff ff       	call   809322 <udp_bind>
  80940b:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80940d:	84 c0                	test   %al,%al
  80940f:	0f 85 74 01 00 00    	jne    809589 <udp_sendto_if+0x1ac>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  809415:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80941c:	00 
  80941d:	8b 55 0c             	mov    0xc(%ebp),%edx
  809420:	89 14 24             	mov    %edx,(%esp)
  809423:	e8 68 b8 ff ff       	call   804c90 <pbuf_header>
  809428:	84 c0                	test   %al,%al
  80942a:	74 37                	je     809463 <udp_sendto_if+0x86>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80942c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809433:	00 
  809434:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80943b:	00 
  80943c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809443:	e8 2e bb ff ff       	call   804f76 <pbuf_alloc>
  809448:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80944a:	85 c0                	test   %eax,%eax
  80944c:	0f 84 2b 01 00 00    	je     80957d <udp_sendto_if+0x1a0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  809452:	8b 45 0c             	mov    0xc(%ebp),%eax
  809455:	89 44 24 04          	mov    %eax,0x4(%esp)
  809459:	89 34 24             	mov    %esi,(%esp)
  80945c:	e8 32 be ff ff       	call   805293 <pbuf_chain>
  809461:	eb 03                	jmp    809466 <udp_sendto_if+0x89>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  809463:	8b 75 0c             	mov    0xc(%ebp),%esi
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809466:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80946b:	77 1c                	ja     809489 <udp_sendto_if+0xac>
  80946d:	c7 44 24 08 9c 1e 81 	movl   $0x811e9c,0x8(%esp)
  809474:	00 
  809475:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80947c:	00 
  80947d:	c7 04 24 66 1e 81 00 	movl   $0x811e66,(%esp)
  809484:	e8 ef 59 00 00       	call   80ee78 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  809489:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80948c:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  809490:	89 04 24             	mov    %eax,(%esp)
  809493:	e8 e5 e7 ff ff       	call   807c7d <htons>
  809498:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80949b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80949f:	89 04 24             	mov    %eax,(%esp)
  8094a2:	e8 d6 e7 ff ff       	call   807c7d <htons>
  8094a7:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  8094ab:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  8094b1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8094b4:	85 db                	test   %ebx,%ebx
  8094b6:	74 06                	je     8094be <udp_sendto_if+0xe1>
  8094b8:	8b 03                	mov    (%ebx),%eax
  8094ba:	85 c0                	test   %eax,%eax
  8094bc:	75 0b                	jne    8094c9 <udp_sendto_if+0xec>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8094be:	8b 55 18             	mov    0x18(%ebp),%edx
  8094c1:	83 c2 04             	add    $0x4,%edx
  8094c4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8094c7:	eb 23                	jmp    8094ec <udp_sendto_if+0x10f>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8094c9:	8b 55 18             	mov    0x18(%ebp),%edx
  8094cc:	3b 42 04             	cmp    0x4(%edx),%eax
  8094cf:	74 1b                	je     8094ec <udp_sendto_if+0x10f>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8094d1:	3b 75 0c             	cmp    0xc(%ebp),%esi
  8094d4:	0f 84 aa 00 00 00    	je     809584 <udp_sendto_if+0x1a7>
        /* free the header pbuf */
        pbuf_free(q);
  8094da:	89 34 24             	mov    %esi,(%esp)
  8094dd:	e8 93 b8 ff ff       	call   804d75 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8094e2:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  8094e7:	e9 9d 00 00 00       	jmp    809589 <udp_sendto_if+0x1ac>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8094ec:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8094f0:	89 04 24             	mov    %eax,(%esp)
  8094f3:	e8 85 e7 ff ff       	call   807c7d <htons>
  8094f8:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8094fc:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  809500:	75 35                	jne    809537 <udp_sendto_if+0x15a>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809502:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809506:	89 44 24 10          	mov    %eax,0x10(%esp)
  80950a:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  809511:	00 
  809512:	8b 45 10             	mov    0x10(%ebp),%eax
  809515:	89 44 24 08          	mov    %eax,0x8(%esp)
  809519:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80951c:	89 54 24 04          	mov    %edx,0x4(%esp)
  809520:	89 34 24             	mov    %esi,(%esp)
  809523:	e8 10 e4 ff ff       	call   807938 <inet_chksum_pseudo>
  809528:	66 89 47 06          	mov    %ax,0x6(%edi)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80952c:	66 85 c0             	test   %ax,%ax
  80952f:	75 06                	jne    809537 <udp_sendto_if+0x15a>
  809531:	66 c7 47 06 ff ff    	movw   $0xffff,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809537:	8b 45 18             	mov    0x18(%ebp),%eax
  80953a:	89 44 24 18          	mov    %eax,0x18(%esp)
  80953e:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  809545:	00 
  809546:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80954a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80954e:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  809552:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809556:	8b 55 10             	mov    0x10(%ebp),%edx
  809559:	89 54 24 08          	mov    %edx,0x8(%esp)
  80955d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809560:	89 44 24 04          	mov    %eax,0x4(%esp)
  809564:	89 34 24             	mov    %esi,(%esp)
  809567:	e8 98 d7 ff ff       	call   806d04 <ip_output_if>
  80956c:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80956e:	3b 75 0c             	cmp    0xc(%ebp),%esi
  809571:	74 16                	je     809589 <udp_sendto_if+0x1ac>
    /* free the header pbuf */
    pbuf_free(q);
  809573:	89 34 24             	mov    %esi,(%esp)
  809576:	e8 fa b7 ff ff       	call   804d75 <pbuf_free>
  80957b:	eb 0c                	jmp    809589 <udp_sendto_if+0x1ac>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  80957d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  809582:	eb 05                	jmp    809589 <udp_sendto_if+0x1ac>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809584:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  809589:	89 f8                	mov    %edi,%eax
  80958b:	83 c4 3c             	add    $0x3c,%esp
  80958e:	5b                   	pop    %ebx
  80958f:	5e                   	pop    %esi
  809590:	5f                   	pop    %edi
  809591:	5d                   	pop    %ebp
  809592:	c3                   	ret    

00809593 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  809593:	55                   	push   %ebp
  809594:	89 e5                	mov    %esp,%ebp
  809596:	56                   	push   %esi
  809597:	53                   	push   %ebx
  809598:	83 ec 20             	sub    $0x20,%esp
  80959b:	8b 75 10             	mov    0x10(%ebp),%esi
  80959e:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8095a1:	89 34 24             	mov    %esi,(%esp)
  8095a4:	e8 5b d4 ff ff       	call   806a04 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  8095a9:	85 c0                	test   %eax,%eax
  8095ab:	74 23                	je     8095d0 <udp_sendto+0x3d>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  8095ad:	89 44 24 10          	mov    %eax,0x10(%esp)
  8095b1:	0f b7 db             	movzwl %bx,%ebx
  8095b4:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8095b8:	89 74 24 08          	mov    %esi,0x8(%esp)
  8095bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8095bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8095c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8095c6:	89 04 24             	mov    %eax,(%esp)
  8095c9:	e8 0f fe ff ff       	call   8093dd <udp_sendto_if>
  8095ce:	eb 02                	jmp    8095d2 <udp_sendto+0x3f>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  8095d0:	b0 fc                	mov    $0xfc,%al
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  8095d2:	83 c4 20             	add    $0x20,%esp
  8095d5:	5b                   	pop    %ebx
  8095d6:	5e                   	pop    %esi
  8095d7:	5d                   	pop    %ebp
  8095d8:	c3                   	ret    

008095d9 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  8095d9:	55                   	push   %ebp
  8095da:	89 e5                	mov    %esp,%ebp
  8095dc:	83 ec 18             	sub    $0x18,%esp
  8095df:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8095e2:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8095e6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8095ea:	8d 50 04             	lea    0x4(%eax),%edx
  8095ed:	89 54 24 08          	mov    %edx,0x8(%esp)
  8095f1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8095f4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8095f8:	89 04 24             	mov    %eax,(%esp)
  8095fb:	e8 93 ff ff ff       	call   809593 <udp_sendto>
}
  809600:	c9                   	leave  
  809601:	c3                   	ret    

00809602 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809602:	55                   	push   %ebp
  809603:	89 e5                	mov    %esp,%ebp
  809605:	57                   	push   %edi
  809606:	56                   	push   %esi
  809607:	53                   	push   %ebx
  809608:	83 ec 1c             	sub    $0x1c,%esp
  80960b:	8b 75 08             	mov    0x8(%ebp),%esi
  80960e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  809611:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809614:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  809619:	75 18                	jne    809633 <udp_connect+0x31>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80961b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809622:	00 
  809623:	89 74 24 04          	mov    %esi,0x4(%esp)
  809627:	89 34 24             	mov    %esi,(%esp)
  80962a:	e8 f3 fc ff ff       	call   809322 <udp_bind>
    if (err != ERR_OK)
  80962f:	84 c0                	test   %al,%al
  809631:	75 3a                	jne    80966d <udp_connect+0x6b>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  809633:	85 db                	test   %ebx,%ebx
  809635:	74 04                	je     80963b <udp_connect+0x39>
  809637:	8b 03                	mov    (%ebx),%eax
  809639:	eb 05                	jmp    809640 <udp_connect+0x3e>
  80963b:	b8 00 00 00 00       	mov    $0x0,%eax
  809640:	89 46 04             	mov    %eax,0x4(%esi)
  pcb->remote_port = port;
  809643:	66 89 7e 14          	mov    %di,0x14(%esi)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  809647:	80 4e 10 04          	orb    $0x4,0x10(%esi)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80964b:	8b 15 94 b2 b3 00    	mov    0xb3b294,%edx
  809651:	89 d0                	mov    %edx,%eax
  809653:	eb 07                	jmp    80965c <udp_connect+0x5a>
    if (pcb == ipcb) {
  809655:	39 c6                	cmp    %eax,%esi
  809657:	74 12                	je     80966b <udp_connect+0x69>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809659:	8b 40 0c             	mov    0xc(%eax),%eax
  80965c:	85 c0                	test   %eax,%eax
  80965e:	75 f5                	jne    809655 <udp_connect+0x53>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809660:	89 56 0c             	mov    %edx,0xc(%esi)
  udp_pcbs = pcb;
  809663:	89 35 94 b2 b3 00    	mov    %esi,0xb3b294
  return ERR_OK;
  809669:	eb 02                	jmp    80966d <udp_connect+0x6b>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  80966b:	b0 00                	mov    $0x0,%al
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  80966d:	83 c4 1c             	add    $0x1c,%esp
  809670:	5b                   	pop    %ebx
  809671:	5e                   	pop    %esi
  809672:	5f                   	pop    %edi
  809673:	5d                   	pop    %ebp
  809674:	c3                   	ret    

00809675 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  809675:	55                   	push   %ebp
  809676:	89 e5                	mov    %esp,%ebp
  809678:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80967b:	8b 15 d8 1a 81 00    	mov    0x811ad8,%edx
  809681:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809684:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80968a:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80968e:	5d                   	pop    %ebp
  80968f:	c3                   	ret    

00809690 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  809690:	55                   	push   %ebp
  809691:	89 e5                	mov    %esp,%ebp
  809693:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809696:	8b 55 0c             	mov    0xc(%ebp),%edx
  809699:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80969c:	8b 55 10             	mov    0x10(%ebp),%edx
  80969f:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  8096a2:	5d                   	pop    %ebp
  8096a3:	c3                   	ret    

008096a4 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  8096a4:	55                   	push   %ebp
  8096a5:	89 e5                	mov    %esp,%ebp
  8096a7:	83 ec 18             	sub    $0x18,%esp
  8096aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  8096ad:	a1 94 b2 b3 00       	mov    0xb3b294,%eax
  8096b2:	39 c8                	cmp    %ecx,%eax
  8096b4:	75 1e                	jne    8096d4 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8096b6:	8b 40 0c             	mov    0xc(%eax),%eax
  8096b9:	a3 94 b2 b3 00       	mov    %eax,0xb3b294
  8096be:	eb 18                	jmp    8096d8 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8096c0:	8b 50 0c             	mov    0xc(%eax),%edx
  8096c3:	85 d2                	test   %edx,%edx
  8096c5:	74 0a                	je     8096d1 <udp_remove+0x2d>
  8096c7:	39 d1                	cmp    %edx,%ecx
  8096c9:	75 06                	jne    8096d1 <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8096cb:	8b 51 0c             	mov    0xc(%ecx),%edx
  8096ce:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8096d1:	8b 40 0c             	mov    0xc(%eax),%eax
  8096d4:	85 c0                	test   %eax,%eax
  8096d6:	75 e8                	jne    8096c0 <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8096d8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8096dc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8096e3:	e8 02 b3 ff ff       	call   8049ea <memp_free>
}
  8096e8:	c9                   	leave  
  8096e9:	c3                   	ret    

008096ea <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8096ea:	55                   	push   %ebp
  8096eb:	89 e5                	mov    %esp,%ebp
  8096ed:	53                   	push   %ebx
  8096ee:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8096f1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8096f8:	e8 8d b2 ff ff       	call   80498a <memp_malloc>
  8096fd:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8096ff:	85 c0                	test   %eax,%eax
  809701:	74 1c                	je     80971f <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  809703:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80970a:	00 
  80970b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809712:	00 
  809713:	89 04 24             	mov    %eax,(%esp)
  809716:	e8 2f 5f 00 00       	call   80f64a <memset>
    pcb->ttl = UDP_TTL;
  80971b:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80971f:	89 d8                	mov    %ebx,%eax
  809721:	83 c4 14             	add    $0x14,%esp
  809724:	5b                   	pop    %ebx
  809725:	5d                   	pop    %ebp
  809726:	c3                   	ret    
	...

00809728 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809728:	55                   	push   %ebp
  809729:	89 e5                	mov    %esp,%ebp
  80972b:	57                   	push   %edi
  80972c:	56                   	push   %esi
  80972d:	53                   	push   %ebx
  80972e:	83 ec 2c             	sub    $0x2c,%esp
  809731:	89 c6                	mov    %eax,%esi
  809733:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  809736:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809739:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80973c:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809740:	74 1c                	je     80975e <etharp_send_ip+0x36>
  809742:	c7 44 24 08 cc 1e 81 	movl   $0x811ecc,0x8(%esp)
  809749:	00 
  80974a:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  809751:	00 
  809752:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809759:	e8 1a 57 00 00       	call   80ee78 <_panic>
  80975e:	b2 06                	mov    $0x6,%dl
  809760:	89 4d e0             	mov    %ecx,-0x20(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  809763:	4a                   	dec    %edx
    ethhdr->dest.addr[k] = dst->addr[k];
  809764:	0f b6 c2             	movzbl %dl,%eax
  809767:	8a 0c 07             	mov    (%edi,%eax,1),%cl
  80976a:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80976d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809770:	8a 0c 01             	mov    (%ecx,%eax,1),%cl
  809773:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809777:	84 d2                	test   %dl,%dl
  809779:	75 e8                	jne    809763 <etharp_send_ip+0x3b>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80977b:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809782:	e8 f6 e4 ff ff       	call   807c7d <htons>
  809787:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80978b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80978e:	89 44 24 04          	mov    %eax,0x4(%esp)
  809792:	89 34 24             	mov    %esi,(%esp)
  809795:	ff 56 18             	call   *0x18(%esi)
}
  809798:	83 c4 2c             	add    $0x2c,%esp
  80979b:	5b                   	pop    %ebx
  80979c:	5e                   	pop    %esi
  80979d:	5f                   	pop    %edi
  80979e:	5d                   	pop    %ebp
  80979f:	c3                   	ret    

008097a0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8097a0:	55                   	push   %ebp
  8097a1:	89 e5                	mov    %esp,%ebp
  8097a3:	56                   	push   %esi
  8097a4:	53                   	push   %ebx
  8097a5:	83 ec 10             	sub    $0x10,%esp
  8097a8:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8097aa:	85 c0                	test   %eax,%eax
  8097ac:	75 1c                	jne    8097ca <free_etharp_q+0x2a>
  8097ae:	c7 44 24 08 96 15 81 	movl   $0x811596,0x8(%esp)
  8097b5:	00 
  8097b6:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  8097bd:	00 
  8097be:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  8097c5:	e8 ae 56 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8097ca:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8097ce:	75 1e                	jne    8097ee <free_etharp_q+0x4e>
  8097d0:	c7 44 24 08 cd 1f 81 	movl   $0x811fcd,0x8(%esp)
  8097d7:	00 
  8097d8:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  8097df:	00 
  8097e0:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  8097e7:	e8 8c 56 00 00       	call   80ee78 <_panic>
  while (q) {
    r = q;
    q = q->next;
  8097ec:	89 f3                	mov    %esi,%ebx
  8097ee:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8097f0:	8b 43 04             	mov    0x4(%ebx),%eax
  8097f3:	85 c0                	test   %eax,%eax
  8097f5:	75 1c                	jne    809813 <free_etharp_q+0x73>
  8097f7:	c7 44 24 08 da 1f 81 	movl   $0x811fda,0x8(%esp)
  8097fe:	00 
  8097ff:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  809806:	00 
  809807:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  80980e:	e8 65 56 00 00       	call   80ee78 <_panic>
    pbuf_free(r->p);
  809813:	89 04 24             	mov    %eax,(%esp)
  809816:	e8 5a b5 ff ff       	call   804d75 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80981b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80981f:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809826:	e8 bf b1 ff ff       	call   8049ea <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80982b:	85 f6                	test   %esi,%esi
  80982d:	75 bd                	jne    8097ec <free_etharp_q+0x4c>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80982f:	83 c4 10             	add    $0x10,%esp
  809832:	5b                   	pop    %ebx
  809833:	5e                   	pop    %esi
  809834:	5d                   	pop    %ebp
  809835:	c3                   	ret    

00809836 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809836:	55                   	push   %ebp
  809837:	89 e5                	mov    %esp,%ebp
  809839:	57                   	push   %edi
  80983a:	56                   	push   %esi
  80983b:	53                   	push   %ebx
  80983c:	83 ec 2c             	sub    $0x2c,%esp
  80983f:	89 c6                	mov    %eax,%esi
  809841:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809844:	85 c0                	test   %eax,%eax
  809846:	74 2f                	je     809877 <find_entry+0x41>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809848:	a0 78 4b b3 00       	mov    0xb34b78,%al
  80984d:	0f b6 c8             	movzbl %al,%ecx
  809850:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
  809857:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  80985e:	29 d3                	sub    %edx,%ebx
  809860:	83 bb 70 4a b3 00 02 	cmpl   $0x2,0xb34a70(%ebx)
  809867:	75 0e                	jne    809877 <find_entry+0x41>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809869:	8b 8b 64 4a b3 00    	mov    0xb34a64(%ebx),%ecx
  80986f:	39 0e                	cmp    %ecx,(%esi)
  809871:	0f 84 d4 01 00 00    	je     809a4b <find_entry+0x215>
  809877:	ba 74 4a b3 00       	mov    $0xb34a74,%edx
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80987c:	bf 00 00 00 00       	mov    $0x0,%edi
  809881:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809885:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809889:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  80988d:	b0 00                	mov    $0x0,%al
  80988f:	c6 45 e7 0a          	movb   $0xa,-0x19(%ebp)
  809893:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809897:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80989b:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  80989f:	75 0b                	jne    8098ac <find_entry+0x76>
  8098a1:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  8098a5:	75 05                	jne    8098ac <find_entry+0x76>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8098a7:	88 45 e7             	mov    %al,-0x19(%ebp)
  8098aa:	eb 6a                	jmp    809916 <find_entry+0xe0>
 */
static s8_t
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
  8098ac:	89 d3                	mov    %edx,%ebx
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8098ae:	8b 4a fc             	mov    -0x4(%edx),%ecx
  8098b1:	83 f9 01             	cmp    $0x1,%ecx
  8098b4:	75 39                	jne    8098ef <find_entry+0xb9>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8098b6:	85 f6                	test   %esi,%esi
  8098b8:	74 11                	je     8098cb <find_entry+0x95>
  8098ba:	8b 4a f0             	mov    -0x10(%edx),%ecx
  8098bd:	39 0e                	cmp    %ecx,(%esi)
  8098bf:	75 0a                	jne    8098cb <find_entry+0x95>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8098c1:	a2 78 4b b3 00       	mov    %al,0xb34b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8098c6:	e9 80 01 00 00       	jmp    809a4b <find_entry+0x215>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8098cb:	83 7b ec 00          	cmpl   $0x0,-0x14(%ebx)
  8098cf:	74 0f                	je     8098e0 <find_entry+0xaa>
        if (arp_table[i].ctime >= age_queue) {
  8098d1:	8a 0b                	mov    (%ebx),%cl
  8098d3:	89 fb                	mov    %edi,%ebx
  8098d5:	38 cb                	cmp    %cl,%bl
  8098d7:	77 3d                	ja     809916 <find_entry+0xe0>
          old_queue = i;
  8098d9:	88 45 e3             	mov    %al,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8098dc:	89 cf                	mov    %ecx,%edi
  8098de:	eb 36                	jmp    809916 <find_entry+0xe0>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  8098e0:	8a 0b                	mov    (%ebx),%cl
  8098e2:	38 4d e2             	cmp    %cl,-0x1e(%ebp)
  8098e5:	77 2f                	ja     809916 <find_entry+0xe0>
          old_pending = i;
  8098e7:	88 45 e1             	mov    %al,-0x1f(%ebp)
          age_pending = arp_table[i].ctime;
  8098ea:	88 4d e2             	mov    %cl,-0x1e(%ebp)
  8098ed:	eb 27                	jmp    809916 <find_entry+0xe0>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8098ef:	83 f9 02             	cmp    $0x2,%ecx
  8098f2:	75 22                	jne    809916 <find_entry+0xe0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8098f4:	85 f6                	test   %esi,%esi
  8098f6:	74 11                	je     809909 <find_entry+0xd3>
  8098f8:	8b 4a f0             	mov    -0x10(%edx),%ecx
  8098fb:	39 0e                	cmp    %ecx,(%esi)
  8098fd:	75 0a                	jne    809909 <find_entry+0xd3>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8098ff:	a2 78 4b b3 00       	mov    %al,0xb34b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809904:	e9 42 01 00 00       	jmp    809a4b <find_entry+0x215>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809909:	8a 0b                	mov    (%ebx),%cl
  80990b:	38 4d e6             	cmp    %cl,-0x1a(%ebp)
  80990e:	77 06                	ja     809916 <find_entry+0xe0>
        old_stable = i;
  809910:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809913:	88 4d e6             	mov    %cl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809916:	40                   	inc    %eax
  809917:	83 c2 1c             	add    $0x1c,%edx
  80991a:	3c 0a                	cmp    $0xa,%al
  80991c:	0f 85 79 ff ff ff    	jne    80989b <find_entry+0x65>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809922:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  809926:	75 0a                	jne    809932 <find_entry+0xfc>
  809928:	f6 45 e4 01          	testb  $0x1,-0x1c(%ebp)
  80992c:	0f 84 0f 01 00 00    	je     809a41 <find_entry+0x20b>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809932:	f6 45 e4 02          	testb  $0x2,-0x1c(%ebp)
  809936:	0f 85 09 01 00 00    	jne    809a45 <find_entry+0x20f>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80993c:	80 7d e7 09          	cmpb   $0x9,-0x19(%ebp)
  809940:	7f 06                	jg     809948 <find_entry+0x112>
    i = empty;
  809942:	0f b6 7d e7          	movzbl -0x19(%ebp),%edi
  809946:	eb 7e                	jmp    8099c6 <find_entry+0x190>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809948:	80 7d e5 09          	cmpb   $0x9,-0x1b(%ebp)
  80994c:	7f 39                	jg     809987 <find_entry+0x151>
    /* recycle oldest stable*/
    i = old_stable;
  80994e:	0f b6 7d e5          	movzbl -0x1b(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809952:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809956:	c1 e0 02             	shl    $0x2,%eax
  809959:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  809960:	29 c2                	sub    %eax,%edx
  809962:	83 ba 60 4a b3 00 00 	cmpl   $0x0,0xb34a60(%edx)
  809969:	74 5b                	je     8099c6 <find_entry+0x190>
  80996b:	c7 44 24 08 e7 1f 81 	movl   $0x811fe7,0x8(%esp)
  809972:	00 
  809973:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80997a:	00 
  80997b:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809982:	e8 f1 54 00 00       	call   80ee78 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809987:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  80998b:	7f 06                	jg     809993 <find_entry+0x15d>
    /* recycle oldest pending */
    i = old_pending;
  80998d:	0f b6 7d e1          	movzbl -0x1f(%ebp),%edi
  809991:	eb 33                	jmp    8099c6 <find_entry+0x190>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809993:	80 7d e3 09          	cmpb   $0x9,-0x1d(%ebp)
  809997:	0f 8f ac 00 00 00    	jg     809a49 <find_entry+0x213>
    /* recycle oldest pending */
    i = old_queue;
  80999d:	0f b6 7d e3          	movzbl -0x1d(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8099a1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  8099a5:	c1 e0 02             	shl    $0x2,%eax
  8099a8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  8099af:	29 c3                	sub    %eax,%ebx
  8099b1:	8b 83 60 4a b3 00    	mov    0xb34a60(%ebx),%eax
  8099b7:	e8 e4 fd ff ff       	call   8097a0 <free_etharp_q>
    arp_table[i].q = NULL;
  8099bc:	c7 83 60 4a b3 00 00 	movl   $0x0,0xb34a60(%ebx)
  8099c3:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8099c6:	89 fb                	mov    %edi,%ebx
  8099c8:	80 fb 09             	cmp    $0x9,%bl
  8099cb:	76 1c                	jbe    8099e9 <find_entry+0x1b3>
  8099cd:	c7 44 24 08 fe 1f 81 	movl   $0x811ffe,0x8(%esp)
  8099d4:	00 
  8099d5:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  8099dc:	00 
  8099dd:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  8099e4:	e8 8f 54 00 00       	call   80ee78 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8099e9:	0f b6 c3             	movzbl %bl,%eax
  8099ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  8099f3:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  8099fa:	29 d1                	sub    %edx,%ecx
  8099fc:	c7 81 70 4a b3 00 00 	movl   $0x0,0xb34a70(%ecx)
  809a03:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809a06:	85 f6                	test   %esi,%esi
  809a08:	74 18                	je     809a22 <find_entry+0x1ec>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809a0a:	8b 0e                	mov    (%esi),%ecx
  809a0c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809a13:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  809a1a:	29 d3                	sub    %edx,%ebx
  809a1c:	89 8b 64 4a b3 00    	mov    %ecx,0xb34a64(%ebx)
  }
  arp_table[i].ctime = 0;
  809a22:	c1 e0 02             	shl    $0x2,%eax
  809a25:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  809a2c:	29 c2                	sub    %eax,%edx
  809a2e:	c6 82 74 4a b3 00 00 	movb   $0x0,0xb34a74(%edx)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809a35:	89 f9                	mov    %edi,%ecx
  809a37:	88 0d 78 4b b3 00    	mov    %cl,0xb34b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809a3d:	89 f8                	mov    %edi,%eax
  809a3f:	eb 0a                	jmp    809a4b <find_entry+0x215>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809a41:	b0 ff                	mov    $0xff,%al
  809a43:	eb 06                	jmp    809a4b <find_entry+0x215>
  809a45:	b0 ff                	mov    $0xff,%al
  809a47:	eb 02                	jmp    809a4b <find_entry+0x215>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809a49:	b0 ff                	mov    $0xff,%al
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809a4b:	83 c4 2c             	add    $0x2c,%esp
  809a4e:	5b                   	pop    %ebx
  809a4f:	5e                   	pop    %esi
  809a50:	5f                   	pop    %edi
  809a51:	5d                   	pop    %ebp
  809a52:	c3                   	ret    

00809a53 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809a53:	55                   	push   %ebp
  809a54:	89 e5                	mov    %esp,%ebp
  809a56:	57                   	push   %edi
  809a57:	56                   	push   %esi
  809a58:	53                   	push   %ebx
  809a59:	83 ec 2c             	sub    $0x2c,%esp
  809a5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809a5f:	89 d3                	mov    %edx,%ebx
  809a61:	89 ce                	mov    %ecx,%esi
  809a63:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809a67:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809a6b:	74 1c                	je     809a89 <update_arp_entry+0x36>
  809a6d:	c7 44 24 08 10 1f 81 	movl   $0x811f10,0x8(%esp)
  809a74:	00 
  809a75:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  809a7c:	00 
  809a7d:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809a84:	e8 ef 53 00 00       	call   80ee78 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809a89:	85 d2                	test   %edx,%edx
  809a8b:	0f 84 0e 01 00 00    	je     809b9f <update_arp_entry+0x14c>
  809a91:	83 3a 00             	cmpl   $0x0,(%edx)
  809a94:	0f 84 09 01 00 00    	je     809ba3 <update_arp_entry+0x150>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809a9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809a9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  809aa1:	89 14 24             	mov    %edx,(%esp)
  809aa4:	e8 17 cf ff ff       	call   8069c0 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809aa9:	84 c0                	test   %al,%al
  809aab:	0f 85 f6 00 00 00    	jne    809ba7 <update_arp_entry+0x154>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809ab1:	8b 0b                	mov    (%ebx),%ecx
  809ab3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  809ab6:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809abd:	e8 31 e4 ff ff       	call   807ef3 <ntohl>
  809ac2:	23 45 e4             	and    -0x1c(%ebp),%eax
  809ac5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809ac8:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809acf:	e8 1f e4 ff ff       	call   807ef3 <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809ad4:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  809ad7:	0f 84 ce 00 00 00    	je     809bab <update_arp_entry+0x158>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809add:	89 f8                	mov    %edi,%eax
  809adf:	0f b6 d0             	movzbl %al,%edx
  809ae2:	89 d8                	mov    %ebx,%eax
  809ae4:	e8 4d fd ff ff       	call   809836 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809ae9:	84 c0                	test   %al,%al
  809aeb:	0f 88 bc 00 00 00    	js     809bad <update_arp_entry+0x15a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809af1:	0f be c0             	movsbl %al,%eax
  809af4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  809afb:	8d 14 cd 00 00 00 00 	lea    0x0(,%ecx,8),%edx
  809b02:	29 ca                	sub    %ecx,%edx
  809b04:	c7 82 70 4a b3 00 02 	movl   $0x2,0xb34a70(%edx)
  809b0b:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809b0e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809b11:	89 8a 78 4a b3 00    	mov    %ecx,0xb34a78(%edx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809b17:	b2 06                	mov    $0x6,%dl
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809b19:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  809b20:	8d 1c cd 00 00 00 00 	lea    0x0(,%ecx,8),%ebx
  809b27:	29 cb                	sub    %ecx,%ebx
  809b29:	89 c7                	mov    %eax,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  809b2b:	4a                   	dec    %edx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809b2c:	0f b6 ca             	movzbl %dl,%ecx
  809b2f:	8a 04 0e             	mov    (%esi,%ecx,1),%al
  809b32:	88 84 19 68 4a b3 00 	mov    %al,0xb34a68(%ecx,%ebx,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809b39:	84 d2                	test   %dl,%dl
  809b3b:	75 ee                	jne    809b2b <update_arp_entry+0xd8>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809b3d:	8d 14 bd 00 00 00 00 	lea    0x0(,%edi,4),%edx
  809b44:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  809b4b:	29 d1                	sub    %edx,%ecx
  809b4d:	c6 81 74 4a b3 00 00 	movb   $0x0,0xb34a74(%ecx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809b54:	89 cf                	mov    %ecx,%edi
  809b56:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  809b59:	8b 75 e0             	mov    -0x20(%ebp),%esi
  809b5c:	eb 35                	jmp    809b93 <update_arp_entry+0x140>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809b5e:	8b 10                	mov    (%eax),%edx
  809b60:	89 97 60 4a b3 00    	mov    %edx,0xb34a60(%edi)
    /* get the packet pointer */
    p = q->p;
  809b66:	8b 58 04             	mov    0x4(%eax),%ebx
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809b69:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b6d:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809b74:	e8 71 ae ff ff       	call   8049ea <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809b79:	8d 4e 25             	lea    0x25(%esi),%ecx
  809b7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809b7f:	89 04 24             	mov    %eax,(%esp)
  809b82:	89 da                	mov    %ebx,%edx
  809b84:	89 f0                	mov    %esi,%eax
  809b86:	e8 9d fb ff ff       	call   809728 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809b8b:	89 1c 24             	mov    %ebx,(%esp)
  809b8e:	e8 e2 b1 ff ff       	call   804d75 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809b93:	8b 87 60 4a b3 00    	mov    0xb34a60(%edi),%eax
  809b99:	85 c0                	test   %eax,%eax
  809b9b:	75 c1                	jne    809b5e <update_arp_entry+0x10b>
  809b9d:	eb 0e                	jmp    809bad <update_arp_entry+0x15a>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809b9f:	b0 f6                	mov    $0xf6,%al
  809ba1:	eb 0a                	jmp    809bad <update_arp_entry+0x15a>
  809ba3:	b0 f6                	mov    $0xf6,%al
  809ba5:	eb 06                	jmp    809bad <update_arp_entry+0x15a>
  809ba7:	b0 f6                	mov    $0xf6,%al
  809ba9:	eb 02                	jmp    809bad <update_arp_entry+0x15a>
  809bab:	b0 f6                	mov    $0xf6,%al
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809bad:	83 c4 2c             	add    $0x2c,%esp
  809bb0:	5b                   	pop    %ebx
  809bb1:	5e                   	pop    %esi
  809bb2:	5f                   	pop    %edi
  809bb3:	5d                   	pop    %ebp
  809bb4:	c3                   	ret    

00809bb5 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809bb5:	55                   	push   %ebp
  809bb6:	89 e5                	mov    %esp,%ebp
  809bb8:	57                   	push   %edi
  809bb9:	56                   	push   %esi
  809bba:	53                   	push   %ebx
  809bbb:	83 ec 0c             	sub    $0xc,%esp
  809bbe:	bb 74 4a b3 00       	mov    $0xb34a74,%ebx
 *
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
  809bc3:	bf 8c 4b b3 00       	mov    $0xb34b8c,%edi
  809bc8:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809bca:	8a 13                	mov    (%ebx),%dl
  809bcc:	42                   	inc    %edx
  809bcd:	88 13                	mov    %dl,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809bcf:	8b 43 fc             	mov    -0x4(%ebx),%eax
  809bd2:	83 f8 02             	cmp    $0x2,%eax
  809bd5:	75 07                	jne    809bde <etharp_tmr+0x29>
  809bd7:	80 fa ef             	cmp    $0xef,%dl
  809bda:	77 0c                	ja     809be8 <etharp_tmr+0x33>
  809bdc:	eb 24                	jmp    809c02 <etharp_tmr+0x4d>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  809bde:	83 f8 01             	cmp    $0x1,%eax
  809be1:	75 1f                	jne    809c02 <etharp_tmr+0x4d>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809be3:	80 fa 01             	cmp    $0x1,%dl
  809be6:	76 1a                	jbe    809c02 <etharp_tmr+0x4d>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809be8:	8b 46 ec             	mov    -0x14(%esi),%eax
  809beb:	85 c0                	test   %eax,%eax
  809bed:	74 0c                	je     809bfb <etharp_tmr+0x46>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809bef:	e8 ac fb ff ff       	call   8097a0 <free_etharp_q>
        arp_table[i].q = NULL;
  809bf4:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809bfb:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809c02:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809c05:	39 fb                	cmp    %edi,%ebx
  809c07:	75 bf                	jne    809bc8 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809c09:	83 c4 0c             	add    $0xc,%esp
  809c0c:	5b                   	pop    %ebx
  809c0d:	5e                   	pop    %esi
  809c0e:	5f                   	pop    %edi
  809c0f:	5d                   	pop    %ebp
  809c10:	c3                   	ret    

00809c11 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809c11:	55                   	push   %ebp
  809c12:	89 e5                	mov    %esp,%ebp
  809c14:	53                   	push   %ebx
  809c15:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809c18:	ba 02 00 00 00       	mov    $0x2,%edx
  809c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809c20:	e8 11 fc ff ff       	call   809836 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809c25:	84 c0                	test   %al,%al
  809c27:	78 36                	js     809c5f <etharp_find_addr+0x4e>
  809c29:	0f be c8             	movsbl %al,%ecx
  809c2c:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
  809c33:	8d 1c d5 00 00 00 00 	lea    0x0(,%edx,8),%ebx
  809c3a:	29 d3                	sub    %edx,%ebx
  809c3c:	83 bb 70 4a b3 00 02 	cmpl   $0x2,0xb34a70(%ebx)
  809c43:	75 1e                	jne    809c63 <etharp_find_addr+0x52>
      *eth_ret = &arp_table[i].ethaddr;
  809c45:	89 da                	mov    %ebx,%edx
  809c47:	8d 9b 68 4a b3 00    	lea    0xb34a68(%ebx),%ebx
  809c4d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809c50:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809c52:	81 c2 64 4a b3 00    	add    $0xb34a64,%edx
  809c58:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809c5b:	89 11                	mov    %edx,(%ecx)
      return i;
  809c5d:	eb 06                	jmp    809c65 <etharp_find_addr+0x54>
  }
  return -1;
  809c5f:	b0 ff                	mov    $0xff,%al
  809c61:	eb 02                	jmp    809c65 <etharp_find_addr+0x54>
  809c63:	b0 ff                	mov    $0xff,%al
}
  809c65:	83 c4 04             	add    $0x4,%esp
  809c68:	5b                   	pop    %ebx
  809c69:	5d                   	pop    %ebp
  809c6a:	c3                   	ret    

00809c6b <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809c6b:	55                   	push   %ebp
  809c6c:	89 e5                	mov    %esp,%ebp
  809c6e:	83 ec 18             	sub    $0x18,%esp
  809c71:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809c74:	85 c0                	test   %eax,%eax
  809c76:	75 1c                	jne    809c94 <etharp_ip_input+0x29>
  809c78:	c7 44 24 08 22 12 81 	movl   $0x811222,0x8(%esp)
  809c7f:	00 
  809c80:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  809c87:	00 
  809c88:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809c8f:	e8 e4 51 00 00       	call   80ee78 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809c94:	8b 55 0c             	mov    0xc(%ebp),%edx
  809c97:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809c9a:	8b 48 04             	mov    0x4(%eax),%ecx
  809c9d:	33 4a 1c             	xor    0x1c(%edx),%ecx
  809ca0:	85 48 08             	test   %ecx,0x8(%eax)
  809ca3:	75 12                	jne    809cb7 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809ca5:	8d 4a 06             	lea    0x6(%edx),%ecx
  809ca8:	83 c2 1c             	add    $0x1c,%edx
  809cab:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809cb2:	e8 9c fd ff ff       	call   809a53 <update_arp_entry>
}
  809cb7:	c9                   	leave  
  809cb8:	c3                   	ret    

00809cb9 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809cb9:	55                   	push   %ebp
  809cba:	89 e5                	mov    %esp,%ebp
  809cbc:	57                   	push   %edi
  809cbd:	56                   	push   %esi
  809cbe:	53                   	push   %ebx
  809cbf:	83 ec 2c             	sub    $0x2c,%esp
  809cc2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809cc5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809cc9:	75 1c                	jne    809ce7 <etharp_arp_input+0x2e>
  809ccb:	c7 44 24 08 22 12 81 	movl   $0x811222,0x8(%esp)
  809cd2:	00 
  809cd3:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  809cda:	00 
  809cdb:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809ce2:	e8 91 51 00 00       	call   80ee78 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809ce7:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809cec:	77 0d                	ja     809cfb <etharp_arp_input+0x42>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809cee:	89 1c 24             	mov    %ebx,(%esp)
  809cf1:	e8 7f b0 ff ff       	call   804d75 <pbuf_free>
    return;
  809cf6:	e9 9b 01 00 00       	jmp    809e96 <etharp_arp_input+0x1dd>
  }

  hdr = p->payload;
  809cfb:	8b 7b 04             	mov    0x4(%ebx),%edi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809cfe:	66 8b 77 0e          	mov    0xe(%edi),%si
  809d02:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809d09:	e8 6f df ff ff       	call   807c7d <htons>
  809d0e:	66 39 c6             	cmp    %ax,%si
  809d11:	75 3f                	jne    809d52 <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809d13:	66 8b 77 12          	mov    0x12(%edi),%si
  809d17:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809d1e:	e8 5a df ff ff       	call   807c7d <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809d23:	66 39 c6             	cmp    %ax,%si
  809d26:	75 2a                	jne    809d52 <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809d28:	66 8b 77 10          	mov    0x10(%edi),%si
  809d2c:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809d33:	e8 45 df ff ff       	call   807c7d <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809d38:	66 39 c6             	cmp    %ax,%si
  809d3b:	75 15                	jne    809d52 <etharp_arp_input+0x99>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809d3d:	66 8b 77 0c          	mov    0xc(%edi),%si
  809d41:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809d48:	e8 30 df ff ff       	call   807c7d <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809d4d:	66 39 c6             	cmp    %ax,%si
  809d50:	74 0d                	je     809d5f <etharp_arp_input+0xa6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809d52:	89 1c 24             	mov    %ebx,(%esp)
  809d55:	e8 1b b0 ff ff       	call   804d75 <pbuf_free>
    return;
  809d5a:	e9 37 01 00 00       	jmp    809e96 <etharp_arp_input+0x1dd>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809d5f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809d66:	00 
  809d67:	8d 47 1c             	lea    0x1c(%edi),%eax
  809d6a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d6e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809d71:	89 04 24             	mov    %eax,(%esp)
  809d74:	e8 85 59 00 00       	call   80f6fe <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809d79:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809d80:	00 
  809d81:	8d 47 26             	lea    0x26(%edi),%eax
  809d84:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d88:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809d8b:	89 04 24             	mov    %eax,(%esp)
  809d8e:	e8 6b 59 00 00       	call   80f6fe <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809d93:	8b 55 08             	mov    0x8(%ebp),%edx
  809d96:	8b 42 04             	mov    0x4(%edx),%eax
  809d99:	85 c0                	test   %eax,%eax
  809d9b:	74 21                	je     809dbe <etharp_arp_input+0x105>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  809d9d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  809da0:	0f 94 c0             	sete   %al
  809da3:	89 c6                	mov    %eax,%esi
  809da5:	75 1c                	jne    809dc3 <etharp_arp_input+0x10a>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809da7:	8d 4f 16             	lea    0x16(%edi),%ecx
  809daa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809db1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809db4:	8b 45 08             	mov    0x8(%ebp),%eax
  809db7:	e8 97 fc ff ff       	call   809a53 <update_arp_entry>
  809dbc:	eb 1a                	jmp    809dd8 <etharp_arp_input+0x11f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  809dbe:	be 00 00 00 00       	mov    $0x0,%esi
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809dc3:	8d 4f 16             	lea    0x16(%edi),%ecx
  809dc6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809dcd:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809dd0:	8b 45 08             	mov    0x8(%ebp),%eax
  809dd3:	e8 7b fc ff ff       	call   809a53 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809dd8:	0f b7 47 14          	movzwl 0x14(%edi),%eax
  809ddc:	89 04 24             	mov    %eax,(%esp)
  809ddf:	e8 99 de ff ff       	call   807c7d <htons>
  809de4:	66 83 f8 01          	cmp    $0x1,%ax
  809de8:	74 0f                	je     809df9 <etharp_arp_input+0x140>
  809dea:	66 83 f8 02          	cmp    $0x2,%ax
  809dee:	0f 85 9a 00 00 00    	jne    809e8e <etharp_arp_input+0x1d5>
  809df4:	e9 83 00 00 00       	jmp    809e7c <etharp_arp_input+0x1c3>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  809df9:	89 f2                	mov    %esi,%edx
  809dfb:	84 d2                	test   %dl,%dl
  809dfd:	0f 84 8b 00 00 00    	je     809e8e <etharp_arp_input+0x1d5>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809e03:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809e0a:	e8 6e de ff ff       	call   807c7d <htons>
  809e0f:	66 89 47 14          	mov    %ax,0x14(%edi)

      hdr->dipaddr = hdr->sipaddr;
  809e13:	8b 47 1c             	mov    0x1c(%edi),%eax
  809e16:	89 47 26             	mov    %eax,0x26(%edi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809e19:	8b 55 08             	mov    0x8(%ebp),%edx
  809e1c:	8b 42 04             	mov    0x4(%edx),%eax
  809e1f:	89 47 1c             	mov    %eax,0x1c(%edi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809e22:	b2 06                	mov    $0x6,%dl
  809e24:	8b 45 08             	mov    0x8(%ebp),%eax
  809e27:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809e2b:	74 1c                	je     809e49 <etharp_arp_input+0x190>
  809e2d:	c7 44 24 08 cc 1e 81 	movl   $0x811ecc,0x8(%esp)
  809e34:	00 
  809e35:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  809e3c:	00 
  809e3d:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809e44:	e8 2f 50 00 00       	call   80ee78 <_panic>
  809e49:	8b 75 0c             	mov    0xc(%ebp),%esi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809e4c:	4a                   	dec    %edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809e4d:	0f b6 c2             	movzbl %dl,%eax
  809e50:	8a 4c 07 16          	mov    0x16(%edi,%eax,1),%cl
  809e54:	88 4c 07 20          	mov    %cl,0x20(%edi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809e58:	88 0c 07             	mov    %cl,(%edi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809e5b:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809e5e:	88 4c 07 16          	mov    %cl,0x16(%edi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809e62:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809e65:	88 4c 07 06          	mov    %cl,0x6(%edi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809e69:	84 d2                	test   %dl,%dl
  809e6b:	75 df                	jne    809e4c <etharp_arp_input+0x193>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809e6d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809e71:	8b 55 08             	mov    0x8(%ebp),%edx
  809e74:	89 14 24             	mov    %edx,(%esp)
  809e77:	ff 52 18             	call   *0x18(%edx)
  809e7a:	eb 12                	jmp    809e8e <etharp_arp_input+0x1d5>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809e7c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809e7f:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e83:	8b 45 08             	mov    0x8(%ebp),%eax
  809e86:	89 04 24             	mov    %eax,(%esp)
  809e89:	e8 ea 9e ff ff       	call   803d78 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809e8e:	89 1c 24             	mov    %ebx,(%esp)
  809e91:	e8 df ae ff ff       	call   804d75 <pbuf_free>
}
  809e96:	83 c4 2c             	add    $0x2c,%esp
  809e99:	5b                   	pop    %ebx
  809e9a:	5e                   	pop    %esi
  809e9b:	5f                   	pop    %edi
  809e9c:	5d                   	pop    %ebp
  809e9d:	c3                   	ret    

00809e9e <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809e9e:	55                   	push   %ebp
  809e9f:	89 e5                	mov    %esp,%ebp
  809ea1:	57                   	push   %edi
  809ea2:	56                   	push   %esi
  809ea3:	53                   	push   %ebx
  809ea4:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809ea7:	8b 75 08             	mov    0x8(%ebp),%esi
  809eaa:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809ead:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809eb4:	00 
  809eb5:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  809ebc:	00 
  809ebd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809ec4:	e8 ad b0 ff ff       	call   804f76 <pbuf_alloc>
  809ec9:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809ecb:	85 c0                	test   %eax,%eax
  809ecd:	0f 84 f0 00 00 00    	je     809fc3 <etharp_request+0x125>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809ed3:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809ed8:	77 1c                	ja     809ef6 <etharp_request+0x58>
  809eda:	c7 44 24 08 38 1f 81 	movl   $0x811f38,0x8(%esp)
  809ee1:	00 
  809ee2:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  809ee9:	00 
  809eea:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809ef1:	e8 82 4f 00 00       	call   80ee78 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  809ef6:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  809ef9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809f00:	e8 78 dd ff ff       	call   807c7d <htons>
  809f05:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809f09:	8b 45 08             	mov    0x8(%ebp),%eax
  809f0c:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809f10:	74 1c                	je     809f2e <etharp_request+0x90>
  809f12:	c7 44 24 08 cc 1e 81 	movl   $0x811ecc,0x8(%esp)
  809f19:	00 
  809f1a:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  809f21:	00 
  809f22:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  809f29:	e8 4a 4f 00 00       	call   80ee78 <_panic>
  809f2e:	b2 06                	mov    $0x6,%dl
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  809f30:	4a                   	dec    %edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809f31:	0f b6 c2             	movzbl %dl,%eax
  809f34:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809f37:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809f3b:	8a 88 2b 20 81 00    	mov    0x81202b(%eax),%cl
  809f41:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809f45:	8a 88 31 20 81 00    	mov    0x812031(%eax),%cl
  809f4b:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809f4e:	8a 0c 06             	mov    (%esi,%eax,1),%cl
  809f51:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  809f55:	84 d2                	test   %dl,%dl
  809f57:	75 d7                	jne    809f30 <etharp_request+0x92>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809f59:	8b 55 08             	mov    0x8(%ebp),%edx
  809f5c:	8b 42 04             	mov    0x4(%edx),%eax
  809f5f:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809f62:	8b 45 0c             	mov    0xc(%ebp),%eax
  809f65:	8b 00                	mov    (%eax),%eax
  809f67:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809f6a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809f71:	e8 07 dd ff ff       	call   807c7d <htons>
  809f76:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809f7a:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809f81:	e8 f7 dc ff ff       	call   807c7d <htons>
  809f86:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809f8a:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809f91:	e8 e7 dc ff ff       	call   807c7d <htons>
  809f96:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809f9a:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809fa1:	e8 d7 dc ff ff       	call   807c7d <htons>
  809fa6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  809faa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809fae:	8b 45 08             	mov    0x8(%ebp),%eax
  809fb1:	89 04 24             	mov    %eax,(%esp)
  809fb4:	ff 50 18             	call   *0x18(%eax)
  809fb7:	88 c3                	mov    %al,%bl
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  809fb9:	89 3c 24             	mov    %edi,(%esp)
  809fbc:	e8 b4 ad ff ff       	call   804d75 <pbuf_free>
  809fc1:	eb 02                	jmp    809fc5 <etharp_request+0x127>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  809fc3:	b3 ff                	mov    $0xff,%bl
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809fc5:	88 d8                	mov    %bl,%al
  809fc7:	83 c4 1c             	add    $0x1c,%esp
  809fca:	5b                   	pop    %ebx
  809fcb:	5e                   	pop    %esi
  809fcc:	5f                   	pop    %edi
  809fcd:	5d                   	pop    %ebp
  809fce:	c3                   	ret    

00809fcf <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809fcf:	55                   	push   %ebp
  809fd0:	89 e5                	mov    %esp,%ebp
  809fd2:	57                   	push   %edi
  809fd3:	56                   	push   %esi
  809fd4:	53                   	push   %ebx
  809fd5:	83 ec 1c             	sub    $0x1c,%esp
  809fd8:	8b 7d 08             	mov    0x8(%ebp),%edi
  809fdb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809fde:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809fe2:	89 1c 24             	mov    %ebx,(%esp)
  809fe5:	e8 d6 c9 ff ff       	call   8069c0 <ip_addr_isbroadcast>
  809fea:	84 c0                	test   %al,%al
  809fec:	0f 85 f9 01 00 00    	jne    80a1eb <etharp_query+0x21c>
      ip_addr_ismulticast(ipaddr) ||
  809ff2:	8b 33                	mov    (%ebx),%esi
  809ff4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809ffb:	e8 f3 de ff ff       	call   807ef3 <ntohl>
  80a000:	21 c6                	and    %eax,%esi
  80a002:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a009:	e8 e5 de ff ff       	call   807ef3 <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a00e:	39 c6                	cmp    %eax,%esi
  80a010:	0f 84 d9 01 00 00    	je     80a1ef <etharp_query+0x220>
      ip_addr_ismulticast(ipaddr) ||
  80a016:	85 db                	test   %ebx,%ebx
  80a018:	0f 84 d5 01 00 00    	je     80a1f3 <etharp_query+0x224>
      ip_addr_isany(ipaddr)) {
  80a01e:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a021:	0f 84 d0 01 00 00    	je     80a1f7 <etharp_query+0x228>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80a027:	ba 01 00 00 00       	mov    $0x1,%edx
  80a02c:	89 d8                	mov    %ebx,%eax
  80a02e:	e8 03 f8 ff ff       	call   809836 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80a033:	84 c0                	test   %al,%al
  80a035:	0f 88 c6 01 00 00    	js     80a201 <etharp_query+0x232>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80a03b:	0f be f0             	movsbl %al,%esi
  80a03e:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a045:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a04c:	29 c2                	sub    %eax,%edx
  80a04e:	8b 82 70 4a b3 00    	mov    0xb34a70(%edx),%eax
  80a054:	85 c0                	test   %eax,%eax
  80a056:	75 1c                	jne    80a074 <etharp_query+0xa5>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80a058:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a05f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a066:	29 c2                	sub    %eax,%edx
  80a068:	c7 82 70 4a b3 00 01 	movl   $0x1,0xb34a70(%edx)
  80a06f:	00 00 00 
  80a072:	eb 37                	jmp    80a0ab <etharp_query+0xdc>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80a074:	8d 50 ff             	lea    -0x1(%eax),%edx
  80a077:	83 fa 01             	cmp    $0x1,%edx
  80a07a:	76 1c                	jbe    80a098 <etharp_query+0xc9>
  80a07c:	c7 44 24 08 6c 1f 81 	movl   $0x811f6c,0x8(%esp)
  80a083:	00 
  80a084:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80a08b:	00 
  80a08c:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  80a093:	e8 e0 4d 00 00       	call   80ee78 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80a098:	83 f8 01             	cmp    $0x1,%eax
  80a09b:	74 0e                	je     80a0ab <etharp_query+0xdc>
  80a09d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a0a1:	0f 84 75 01 00 00    	je     80a21c <etharp_query+0x24d>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80a0a7:	b3 ff                	mov    $0xff,%bl
  80a0a9:	eb 18                	jmp    80a0c3 <etharp_query+0xf4>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a0ab:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a0af:	89 3c 24             	mov    %edi,(%esp)
  80a0b2:	e8 e7 fd ff ff       	call   809e9e <etharp_request>
  80a0b7:	88 c3                	mov    %al,%bl
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80a0b9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a0bd:	0f 84 3e 01 00 00    	je     80a201 <etharp_query+0x232>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a0c3:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
  80a0ca:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  80a0d1:	29 c2                	sub    %eax,%edx
  80a0d3:	8b 82 70 4a b3 00    	mov    0xb34a70(%edx),%eax
  80a0d9:	83 f8 02             	cmp    $0x2,%eax
  80a0dc:	75 1c                	jne    80a0fa <etharp_query+0x12b>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80a0de:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80a0e1:	89 d0                	mov    %edx,%eax
  80a0e3:	05 68 4a b3 00       	add    $0xb34a68,%eax
  80a0e8:	89 04 24             	mov    %eax,(%esp)
  80a0eb:	8b 55 10             	mov    0x10(%ebp),%edx
  80a0ee:	89 f8                	mov    %edi,%eax
  80a0f0:	e8 33 f6 ff ff       	call   809728 <etharp_send_ip>
  80a0f5:	e9 07 01 00 00       	jmp    80a201 <etharp_query+0x232>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a0fa:	83 f8 01             	cmp    $0x1,%eax
  80a0fd:	0f 85 f8 00 00 00    	jne    80a1fb <etharp_query+0x22c>
  80a103:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80a106:	8b 50 08             	mov    0x8(%eax),%edx
  80a109:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80a10d:	75 21                	jne    80a130 <etharp_query+0x161>
  80a10f:	83 38 00             	cmpl   $0x0,(%eax)
  80a112:	74 1c                	je     80a130 <etharp_query+0x161>
  80a114:	c7 44 24 08 11 20 81 	movl   $0x812011,0x8(%esp)
  80a11b:	00 
  80a11c:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80a123:	00 
  80a124:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  80a12b:	e8 48 4d 00 00       	call   80ee78 <_panic>
        if(p->type != PBUF_ROM) {
  80a130:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80a134:	75 0b                	jne    80a141 <etharp_query+0x172>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80a136:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80a138:	85 c0                	test   %eax,%eax
  80a13a:	75 ca                	jne    80a106 <etharp_query+0x137>
  80a13c:	e9 c8 00 00 00       	jmp    80a209 <etharp_query+0x23a>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a141:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80a145:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a14c:	00 
  80a14d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a151:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a158:	e8 19 ae ff ff       	call   804f76 <pbuf_alloc>
  80a15d:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  80a15f:	85 c0                	test   %eax,%eax
  80a161:	0f 84 98 00 00 00    	je     80a1ff <etharp_query+0x230>
          if (pbuf_copy(p, q) != ERR_OK) {
  80a167:	8b 55 10             	mov    0x10(%ebp),%edx
  80a16a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80a16e:	89 04 24             	mov    %eax,(%esp)
  80a171:	e8 e7 b1 ff ff       	call   80535d <pbuf_copy>
  80a176:	84 c0                	test   %al,%al
  80a178:	74 0c                	je     80a186 <etharp_query+0x1b7>
            pbuf_free(p);
  80a17a:	89 3c 24             	mov    %edi,(%esp)
  80a17d:	e8 f3 ab ff ff       	call   804d75 <pbuf_free>
  80a182:	88 d8                	mov    %bl,%al
  80a184:	eb 7b                	jmp    80a201 <etharp_query+0x232>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80a186:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a18d:	e8 f8 a7 ff ff       	call   80498a <memp_malloc>
        if (new_entry != NULL) {
  80a192:	85 c0                	test   %eax,%eax
  80a194:	74 49                	je     80a1df <etharp_query+0x210>
          new_entry->next = 0;
  80a196:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80a19c:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80a19f:	8d 14 b5 00 00 00 00 	lea    0x0(,%esi,4),%edx
  80a1a6:	8d 0c d5 00 00 00 00 	lea    0x0(,%edx,8),%ecx
  80a1ad:	29 d1                	sub    %edx,%ecx
  80a1af:	8b 89 60 4a b3 00    	mov    0xb34a60(%ecx),%ecx
  80a1b5:	85 c9                	test   %ecx,%ecx
  80a1b7:	75 04                	jne    80a1bd <etharp_query+0x1ee>
  80a1b9:	eb 0e                	jmp    80a1c9 <etharp_query+0x1fa>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  80a1bb:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80a1bd:	8b 11                	mov    (%ecx),%edx
  80a1bf:	85 d2                	test   %edx,%edx
  80a1c1:	75 f8                	jne    80a1bb <etharp_query+0x1ec>
              r = r->next;
            }
            r->next = new_entry;
  80a1c3:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a1c5:	b0 00                	mov    $0x0,%al
  80a1c7:	eb 38                	jmp    80a201 <etharp_query+0x232>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80a1c9:	c1 e6 02             	shl    $0x2,%esi
  80a1cc:	8d 14 f5 00 00 00 00 	lea    0x0(,%esi,8),%edx
  80a1d3:	29 f2                	sub    %esi,%edx
  80a1d5:	89 82 60 4a b3 00    	mov    %eax,0xb34a60(%edx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a1db:	b0 00                	mov    $0x0,%al
  80a1dd:	eb 22                	jmp    80a201 <etharp_query+0x232>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80a1df:	89 3c 24             	mov    %edi,(%esp)
  80a1e2:	e8 8e ab ff ff       	call   804d75 <pbuf_free>
  80a1e7:	88 d8                	mov    %bl,%al
  80a1e9:	eb 16                	jmp    80a201 <etharp_query+0x232>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80a1eb:	b0 f6                	mov    $0xf6,%al
  80a1ed:	eb 12                	jmp    80a201 <etharp_query+0x232>
  80a1ef:	b0 f6                	mov    $0xf6,%al
  80a1f1:	eb 0e                	jmp    80a201 <etharp_query+0x232>
  80a1f3:	b0 f6                	mov    $0xf6,%al
  80a1f5:	eb 0a                	jmp    80a201 <etharp_query+0x232>
  80a1f7:	b0 f6                	mov    $0xf6,%al
  80a1f9:	eb 06                	jmp    80a201 <etharp_query+0x232>
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a1fb:	88 d8                	mov    %bl,%al
  80a1fd:	eb 02                	jmp    80a201 <etharp_query+0x232>
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
  80a1ff:	88 d8                	mov    %bl,%al
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80a201:	83 c4 1c             	add    $0x1c,%esp
  80a204:	5b                   	pop    %ebx
  80a205:	5e                   	pop    %esi
  80a206:	5f                   	pop    %edi
  80a207:	5d                   	pop    %ebp
  80a208:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80a209:	8b 55 10             	mov    0x10(%ebp),%edx
  80a20c:	89 14 24             	mov    %edx,(%esp)
  80a20f:	e8 fb af ff ff       	call   80520f <pbuf_ref>
            p = NULL;
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  80a214:	8b 7d 10             	mov    0x10(%ebp),%edi
  80a217:	e9 6a ff ff ff       	jmp    80a186 <etharp_query+0x1b7>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a21c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a220:	89 3c 24             	mov    %edi,(%esp)
  80a223:	e8 76 fc ff ff       	call   809e9e <etharp_request>
  80a228:	eb d7                	jmp    80a201 <etharp_query+0x232>

0080a22a <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80a22a:	55                   	push   %ebp
  80a22b:	89 e5                	mov    %esp,%ebp
  80a22d:	57                   	push   %edi
  80a22e:	56                   	push   %esi
  80a22f:	53                   	push   %ebx
  80a230:	83 ec 3c             	sub    $0x3c,%esp
  80a233:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a236:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80a239:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80a23c:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80a243:	00 
  80a244:	89 3c 24             	mov    %edi,(%esp)
  80a247:	e8 44 aa ff ff       	call   804c90 <pbuf_header>
  80a24c:	84 c0                	test   %al,%al
  80a24e:	0f 85 b8 00 00 00    	jne    80a30c <etharp_output+0xe2>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80a254:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a258:	89 34 24             	mov    %esi,(%esp)
  80a25b:	e8 60 c7 ff ff       	call   8069c0 <ip_addr_isbroadcast>
  80a260:	84 c0                	test   %al,%al
  80a262:	0f 85 8e 00 00 00    	jne    80a2f6 <etharp_output+0xcc>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a268:	8b 06                	mov    (%esi),%eax
  80a26a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80a26d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a274:	e8 7a dc ff ff       	call   807ef3 <ntohl>
  80a279:	23 45 d4             	and    -0x2c(%ebp),%eax
  80a27c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80a27f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a286:	e8 68 dc ff ff       	call   807ef3 <ntohl>
  80a28b:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80a28e:	75 41                	jne    80a2d1 <etharp_output+0xa7>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a290:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a294:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a298:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a29c:	8b 06                	mov    (%esi),%eax
  80a29e:	89 04 24             	mov    %eax,(%esp)
  80a2a1:	e8 4d dc ff ff       	call   807ef3 <ntohl>
  80a2a6:	c1 e8 10             	shr    $0x10,%eax
  80a2a9:	83 e0 7f             	and    $0x7f,%eax
  80a2ac:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a2af:	8b 06                	mov    (%esi),%eax
  80a2b1:	89 04 24             	mov    %eax,(%esp)
  80a2b4:	e8 3a dc ff ff       	call   807ef3 <ntohl>
  80a2b9:	c1 e8 08             	shr    $0x8,%eax
  80a2bc:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a2bf:	8b 06                	mov    (%esi),%eax
  80a2c1:	89 04 24             	mov    %eax,(%esp)
  80a2c4:	e8 2a dc ff ff       	call   807ef3 <ntohl>
  80a2c9:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80a2cc:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80a2cf:	eb 2a                	jmp    80a2fb <etharp_output+0xd1>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a2d1:	8b 43 04             	mov    0x4(%ebx),%eax
  80a2d4:	33 06                	xor    (%esi),%eax
  80a2d6:	85 43 08             	test   %eax,0x8(%ebx)
  80a2d9:	74 09                	je     80a2e4 <etharp_output+0xba>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a2db:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a2df:	74 2f                	je     80a310 <etharp_output+0xe6>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a2e1:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a2e4:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80a2e8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a2ec:	89 1c 24             	mov    %ebx,(%esp)
  80a2ef:	e8 db fc ff ff       	call   809fcf <etharp_query>
  80a2f4:	eb 1c                	jmp    80a312 <etharp_output+0xe8>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80a2f6:	b8 31 20 81 00       	mov    $0x812031,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a2fb:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a2fe:	89 04 24             	mov    %eax,(%esp)
  80a301:	89 fa                	mov    %edi,%edx
  80a303:	89 d8                	mov    %ebx,%eax
  80a305:	e8 1e f4 ff ff       	call   809728 <etharp_send_ip>
  80a30a:	eb 06                	jmp    80a312 <etharp_output+0xe8>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80a30c:	b0 fe                	mov    $0xfe,%al
  80a30e:	eb 02                	jmp    80a312 <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80a310:	b0 fc                	mov    $0xfc,%al

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  80a312:	83 c4 3c             	add    $0x3c,%esp
  80a315:	5b                   	pop    %ebx
  80a316:	5e                   	pop    %esi
  80a317:	5f                   	pop    %edi
  80a318:	5d                   	pop    %ebp
  80a319:	c3                   	ret    

0080a31a <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a31a:	55                   	push   %ebp
  80a31b:	89 e5                	mov    %esp,%ebp
  80a31d:	56                   	push   %esi
  80a31e:	53                   	push   %ebx
  80a31f:	83 ec 10             	sub    $0x10,%esp
  80a322:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a325:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a328:	8b 43 04             	mov    0x4(%ebx),%eax
  80a32b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a32f:	89 04 24             	mov    %eax,(%esp)
  80a332:	e8 46 d9 ff ff       	call   807c7d <htons>
  80a337:	66 3d 00 08          	cmp    $0x800,%ax
  80a33b:	74 08                	je     80a345 <ethernet_input+0x2b>
  80a33d:	66 3d 06 08          	cmp    $0x806,%ax
  80a341:	75 61                	jne    80a3a4 <ethernet_input+0x8a>
  80a343:	eb 4a                	jmp    80a38f <ethernet_input+0x75>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a345:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a349:	89 34 24             	mov    %esi,(%esp)
  80a34c:	e8 1a f9 ff ff       	call   809c6b <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a351:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a358:	ff 
  80a359:	89 1c 24             	mov    %ebx,(%esp)
  80a35c:	e8 2f a9 ff ff       	call   804c90 <pbuf_header>
  80a361:	84 c0                	test   %al,%al
  80a363:	74 1c                	je     80a381 <ethernet_input+0x67>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a365:	c7 44 24 08 94 1f 81 	movl   $0x811f94,0x8(%esp)
  80a36c:	00 
  80a36d:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a374:	00 
  80a375:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  80a37c:	e8 f7 4a 00 00       	call   80ee78 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a381:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a385:	89 1c 24             	mov    %ebx,(%esp)
  80a388:	e8 ca c6 ff ff       	call   806a57 <ip_input>
      }
      break;
  80a38d:	eb 1d                	jmp    80a3ac <ethernet_input+0x92>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a38f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a393:	8d 46 25             	lea    0x25(%esi),%eax
  80a396:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a39a:	89 34 24             	mov    %esi,(%esp)
  80a39d:	e8 17 f9 ff ff       	call   809cb9 <etharp_arp_input>
      break;
  80a3a2:	eb 08                	jmp    80a3ac <ethernet_input+0x92>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a3a4:	89 1c 24             	mov    %ebx,(%esp)
  80a3a7:	e8 c9 a9 ff ff       	call   804d75 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a3ac:	b0 00                	mov    $0x0,%al
  80a3ae:	83 c4 10             	add    $0x10,%esp
  80a3b1:	5b                   	pop    %ebx
  80a3b2:	5e                   	pop    %esi
  80a3b3:	5d                   	pop    %ebp
  80a3b4:	c3                   	ret    
  80a3b5:	00 00                	add    %al,(%eax)
	...

0080a3b8 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a3b8:	55                   	push   %ebp
  80a3b9:	89 e5                	mov    %esp,%ebp
  80a3bb:	53                   	push   %ebx
  80a3bc:	83 ec 14             	sub    $0x14,%esp
  80a3bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3c2:	bb 01 01 00 00       	mov    $0x101,%ebx
  80a3c7:	89 c8                	mov    %ecx,%eax
  80a3c9:	ba 00 00 00 00       	mov    $0x0,%edx
  80a3ce:	f7 f3                	div    %ebx
  80a3d0:	8b 04 95 c0 ad b3 00 	mov    0xb3adc0(,%edx,4),%eax
  80a3d7:	eb 26                	jmp    80a3ff <timeout_cleanup+0x47>
	if (t->tid == tid) {
  80a3d9:	39 08                	cmp    %ecx,(%eax)
  80a3db:	75 1f                	jne    80a3fc <timeout_cleanup+0x44>
	    LIST_REMOVE(t, link);
  80a3dd:	8b 50 08             	mov    0x8(%eax),%edx
  80a3e0:	85 d2                	test   %edx,%edx
  80a3e2:	74 06                	je     80a3ea <timeout_cleanup+0x32>
  80a3e4:	8b 48 0c             	mov    0xc(%eax),%ecx
  80a3e7:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a3ea:	8b 50 0c             	mov    0xc(%eax),%edx
  80a3ed:	8b 48 08             	mov    0x8(%eax),%ecx
  80a3f0:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80a3f2:	89 04 24             	mov    %eax,(%esp)
  80a3f5:	e8 c6 5f 00 00       	call   8103c0 <free>
	    goto done;
  80a3fa:	eb 07                	jmp    80a403 <timeout_cleanup+0x4b>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3fc:	8b 40 08             	mov    0x8(%eax),%eax
  80a3ff:	85 c0                	test   %eax,%eax
  80a401:	75 d6                	jne    80a3d9 <timeout_cleanup+0x21>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a403:	83 c4 14             	add    $0x14,%esp
  80a406:	5b                   	pop    %ebx
  80a407:	5d                   	pop    %ebp
  80a408:	c3                   	ret    

0080a409 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a409:	55                   	push   %ebp
  80a40a:	89 e5                	mov    %esp,%ebp
  80a40c:	53                   	push   %ebx
  80a40d:	83 ec 14             	sub    $0x14,%esp
  80a410:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a413:	8b 43 04             	mov    0x4(%ebx),%eax
  80a416:	89 04 24             	mov    %eax,(%esp)
  80a419:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a41b:	89 1c 24             	mov    %ebx,(%esp)
  80a41e:	e8 9d 5f 00 00       	call   8103c0 <free>
}
  80a423:	83 c4 14             	add    $0x14,%esp
  80a426:	5b                   	pop    %ebx
  80a427:	5d                   	pop    %ebp
  80a428:	c3                   	ret    

0080a429 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a429:	55                   	push   %ebp
  80a42a:	89 e5                	mov    %esp,%ebp
  80a42c:	56                   	push   %esi
  80a42d:	53                   	push   %ebx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a42e:	8b 0d 80 5f b3 00    	mov    0xb35f80,%ecx
  80a434:	bb 80 4b b3 00       	mov    $0xb34b80,%ebx
  80a439:	b8 00 00 00 00       	mov    $0x0,%eax
  80a43e:	eb 02                	jmp    80a442 <sys_init+0x19>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a440:	89 d1                	mov    %edx,%ecx
void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a442:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a448:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a44b:	8d 14 95 80 4b b3 00 	lea    0xb34b80(,%edx,4),%edx
  80a452:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a455:	85 c9                	test   %ecx,%ecx
  80a457:	74 06                	je     80a45f <sys_init+0x36>
  80a459:	8d 72 0c             	lea    0xc(%edx),%esi
  80a45c:	89 71 10             	mov    %esi,0x10(%ecx)
  80a45f:	c7 42 10 80 5f b3 00 	movl   $0xb35f80,0x10(%edx)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a466:	40                   	inc    %eax
  80a467:	83 c3 14             	add    $0x14,%ebx
  80a46a:	3d 00 01 00 00       	cmp    $0x100,%eax
  80a46f:	75 cf                	jne    80a440 <sys_init+0x17>
  80a471:	89 15 80 5f b3 00    	mov    %edx,0xb35f80
  80a477:	8b 0d a0 ad b3 00    	mov    0xb3ada0,%ecx
  80a47d:	bb a0 5f b3 00       	mov    $0xb35fa0,%ebx
  80a482:	66 b8 00 00          	mov    $0x0,%ax
  80a486:	eb 02                	jmp    80a48a <sys_init+0x61>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a488:	89 d1                	mov    %edx,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a48a:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a490:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a493:	c1 e2 03             	shl    $0x3,%edx
  80a496:	29 c2                	sub    %eax,%edx
  80a498:	8d 14 95 a0 5f b3 00 	lea    0xb35fa0(,%edx,4),%edx
  80a49f:	89 8a 94 00 00 00    	mov    %ecx,0x94(%edx)
  80a4a5:	85 c9                	test   %ecx,%ecx
  80a4a7:	74 0c                	je     80a4b5 <sys_init+0x8c>
  80a4a9:	8d b2 94 00 00 00    	lea    0x94(%edx),%esi
  80a4af:	89 b1 98 00 00 00    	mov    %esi,0x98(%ecx)
  80a4b5:	c7 82 98 00 00 00 a0 	movl   $0xb3ada0,0x98(%edx)
  80a4bc:	ad b3 00 
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a4bf:	40                   	inc    %eax
  80a4c0:	81 c3 9c 00 00 00    	add    $0x9c,%ebx
  80a4c6:	3d 80 00 00 00       	cmp    $0x80,%eax
  80a4cb:	75 bb                	jne    80a488 <sys_init+0x5f>
  80a4cd:	89 15 a0 ad b3 00    	mov    %edx,0xb3ada0
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80a4d3:	5b                   	pop    %ebx
  80a4d4:	5e                   	pop    %esi
  80a4d5:	5d                   	pop    %ebp
  80a4d6:	c3                   	ret    

0080a4d7 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80a4d7:	55                   	push   %ebp
  80a4d8:	89 e5                	mov    %esp,%ebp
  80a4da:	53                   	push   %ebx
  80a4db:	83 ec 14             	sub    $0x14,%esp
  80a4de:	8a 4d 08             	mov    0x8(%ebp),%cl
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a4e1:	a1 80 5f b3 00       	mov    0xb35f80,%eax
    if (!se) {
  80a4e6:	85 c0                	test   %eax,%eax
  80a4e8:	75 13                	jne    80a4fd <sys_sem_new+0x26>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a4ea:	c7 04 24 38 20 81 00 	movl   $0x812038,(%esp)
  80a4f1:	e8 7a 4a 00 00       	call   80ef70 <cprintf>
	return SYS_SEM_NULL;
  80a4f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a4fb:	eb 70                	jmp    80a56d <sys_sem_new+0x96>
    }
    LIST_REMOVE(se, link);
  80a4fd:	8b 50 0c             	mov    0xc(%eax),%edx
  80a500:	85 d2                	test   %edx,%edx
  80a502:	74 06                	je     80a50a <sys_sem_new+0x33>
  80a504:	8b 58 10             	mov    0x10(%eax),%ebx
  80a507:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a50a:	8b 50 10             	mov    0x10(%eax),%edx
  80a50d:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a510:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80a512:	83 38 00             	cmpl   $0x0,(%eax)
  80a515:	75 24                	jne    80a53b <sys_sem_new+0x64>
  80a517:	c7 44 24 0c ad 21 81 	movl   $0x8121ad,0xc(%esp)
  80a51e:	00 
  80a51f:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a526:	00 
  80a527:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80a52e:	00 
  80a52f:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a536:	e8 3d 49 00 00       	call   80ee78 <_panic>
    se->freed = 0;
  80a53b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80a541:	0f b6 c9             	movzbl %cl,%ecx
  80a544:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80a548:	ff 40 04             	incl   0x4(%eax)
    return se - &sems[0];
  80a54b:	2d 80 4b b3 00       	sub    $0xb34b80,%eax
  80a550:	c1 f8 02             	sar    $0x2,%eax
  80a553:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a556:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a559:	8d 14 50             	lea    (%eax,%edx,2),%edx
  80a55c:	89 d1                	mov    %edx,%ecx
  80a55e:	c1 e1 08             	shl    $0x8,%ecx
  80a561:	01 ca                	add    %ecx,%edx
  80a563:	89 d1                	mov    %edx,%ecx
  80a565:	c1 e1 10             	shl    $0x10,%ecx
  80a568:	01 ca                	add    %ecx,%edx
  80a56a:	8d 04 90             	lea    (%eax,%edx,4),%eax
}
  80a56d:	83 c4 14             	add    $0x14,%esp
  80a570:	5b                   	pop    %ebx
  80a571:	5d                   	pop    %ebp
  80a572:	c3                   	ret    

0080a573 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80a573:	55                   	push   %ebp
  80a574:	89 e5                	mov    %esp,%ebp
  80a576:	83 ec 18             	sub    $0x18,%esp
  80a579:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a57c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a57f:	83 3c 95 80 4b b3 00 	cmpl   $0x0,0xb34b80(,%edx,4)
  80a586:	00 
  80a587:	74 24                	je     80a5ad <sys_sem_free+0x3a>
  80a589:	c7 44 24 0c e9 21 81 	movl   $0x8121e9,0xc(%esp)
  80a590:	00 
  80a591:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a598:	00 
  80a599:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a5a0:	00 
  80a5a1:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a5a8:	e8 cb 48 00 00       	call   80ee78 <_panic>
    sems[sem].freed = 1;
  80a5ad:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a5b0:	c1 e2 02             	shl    $0x2,%edx
  80a5b3:	8d 82 80 4b b3 00    	lea    0xb34b80(%edx),%eax
  80a5b9:	c7 82 80 4b b3 00 01 	movl   $0x1,0xb34b80(%edx)
  80a5c0:	00 00 00 
    sems[sem].gen++;
  80a5c3:	ff 40 04             	incl   0x4(%eax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a5c6:	8b 15 80 5f b3 00    	mov    0xb35f80,%edx
  80a5cc:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5cf:	85 d2                	test   %edx,%edx
  80a5d1:	74 06                	je     80a5d9 <sys_sem_free+0x66>
  80a5d3:	8d 48 0c             	lea    0xc(%eax),%ecx
  80a5d6:	89 4a 10             	mov    %ecx,0x10(%edx)
  80a5d9:	a3 80 5f b3 00       	mov    %eax,0xb35f80
  80a5de:	c7 40 10 80 5f b3 00 	movl   $0xb35f80,0x10(%eax)
}
  80a5e5:	c9                   	leave  
  80a5e6:	c3                   	ret    

0080a5e7 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a5e7:	55                   	push   %ebp
  80a5e8:	89 e5                	mov    %esp,%ebp
  80a5ea:	56                   	push   %esi
  80a5eb:	53                   	push   %ebx
  80a5ec:	83 ec 10             	sub    $0x10,%esp
  80a5ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a5f2:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a5f5:	c1 e0 03             	shl    $0x3,%eax
  80a5f8:	29 d8                	sub    %ebx,%eax
  80a5fa:	83 3c 85 a0 5f b3 00 	cmpl   $0x0,0xb35fa0(,%eax,4)
  80a601:	00 
  80a602:	74 24                	je     80a628 <sys_mbox_free+0x41>
  80a604:	c7 44 24 0c fa 21 81 	movl   $0x8121fa,0xc(%esp)
  80a60b:	00 
  80a60c:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a613:	00 
  80a614:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a61b:	00 
  80a61c:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a623:	e8 50 48 00 00       	call   80ee78 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a628:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
  80a62f:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a632:	c1 e0 03             	shl    $0x3,%eax
  80a635:	29 d8                	sub    %ebx,%eax
  80a637:	8b 04 85 2c 60 b3 00 	mov    0xb3602c(,%eax,4),%eax
  80a63e:	89 04 24             	mov    %eax,(%esp)
  80a641:	e8 2d ff ff ff       	call   80a573 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a646:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a649:	c1 e0 03             	shl    $0x3,%eax
  80a64c:	29 d8                	sub    %ebx,%eax
  80a64e:	8b 04 85 30 60 b3 00 	mov    0xb36030(,%eax,4),%eax
  80a655:	89 04 24             	mov    %eax,(%esp)
  80a658:	e8 16 ff ff ff       	call   80a573 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a65d:	01 de                	add    %ebx,%esi
  80a65f:	c1 e6 03             	shl    $0x3,%esi
  80a662:	29 de                	sub    %ebx,%esi
  80a664:	8d 04 b5 a0 5f b3 00 	lea    0xb35fa0(,%esi,4),%eax
  80a66b:	8b 15 a0 ad b3 00    	mov    0xb3ada0,%edx
  80a671:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a677:	85 d2                	test   %edx,%edx
  80a679:	74 0c                	je     80a687 <sys_mbox_free+0xa0>
  80a67b:	8d 88 94 00 00 00    	lea    0x94(%eax),%ecx
  80a681:	89 8a 98 00 00 00    	mov    %ecx,0x98(%edx)
  80a687:	a3 a0 ad b3 00       	mov    %eax,0xb3ada0
  80a68c:	c7 80 98 00 00 00 a0 	movl   $0xb3ada0,0x98(%eax)
  80a693:	ad b3 00 
    mboxes[mbox].freed = 1;
  80a696:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a699:	c1 e0 03             	shl    $0x3,%eax
  80a69c:	29 d8                	sub    %ebx,%eax
  80a69e:	c7 04 85 a0 5f b3 00 	movl   $0x1,0xb35fa0(,%eax,4)
  80a6a5:	01 00 00 00 
}
  80a6a9:	83 c4 10             	add    $0x10,%esp
  80a6ac:	5b                   	pop    %ebx
  80a6ad:	5e                   	pop    %esi
  80a6ae:	5d                   	pop    %ebp
  80a6af:	c3                   	ret    

0080a6b0 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80a6b0:	55                   	push   %ebp
  80a6b1:	89 e5                	mov    %esp,%ebp
  80a6b3:	57                   	push   %edi
  80a6b4:	56                   	push   %esi
  80a6b5:	53                   	push   %ebx
  80a6b6:	83 ec 1c             	sub    $0x1c,%esp
    assert(size < MBOXSLOTS);
  80a6b9:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a6bd:	7e 24                	jle    80a6e3 <sys_mbox_new+0x33>
  80a6bf:	c7 44 24 0c 0e 22 81 	movl   $0x81220e,0xc(%esp)
  80a6c6:	00 
  80a6c7:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a6ce:	00 
  80a6cf:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80a6d6:	00 
  80a6d7:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a6de:	e8 95 47 00 00       	call   80ee78 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a6e3:	8b 1d a0 ad b3 00    	mov    0xb3ada0,%ebx
    if (!mbe) {
  80a6e9:	85 db                	test   %ebx,%ebx
  80a6eb:	75 16                	jne    80a703 <sys_mbox_new+0x53>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a6ed:	c7 04 24 60 20 81 00 	movl   $0x812060,(%esp)
  80a6f4:	e8 77 48 00 00       	call   80ef70 <cprintf>
	return SYS_MBOX_NULL;
  80a6f9:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80a6fe:	e9 d8 00 00 00       	jmp    80a7db <sys_mbox_new+0x12b>
    }
    LIST_REMOVE(mbe, link);
  80a703:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a709:	85 c0                	test   %eax,%eax
  80a70b:	74 0c                	je     80a719 <sys_mbox_new+0x69>
  80a70d:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a713:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a719:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a71f:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a725:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a727:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a72a:	75 24                	jne    80a750 <sys_mbox_new+0xa0>
  80a72c:	c7 44 24 0c 1f 22 81 	movl   $0x81221f,0xc(%esp)
  80a733:	00 
  80a734:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a73b:	00 
  80a73c:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80a743:	00 
  80a744:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a74b:	e8 28 47 00 00       	call   80ee78 <_panic>
    mbe->freed = 0;
  80a750:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80a756:	89 d8                	mov    %ebx,%eax
  80a758:	2d a0 5f b3 00       	sub    $0xb35fa0,%eax
  80a75d:	c1 f8 02             	sar    $0x2,%eax
  80a760:	8d 14 40             	lea    (%eax,%eax,2),%edx
  80a763:	8d 14 90             	lea    (%eax,%edx,4),%edx
  80a766:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  80a769:	89 d1                	mov    %edx,%ecx
  80a76b:	c1 e1 0c             	shl    $0xc,%ecx
  80a76e:	01 ca                	add    %ecx,%edx
  80a770:	c1 e2 06             	shl    $0x6,%edx
  80a773:	01 c2                	add    %eax,%edx
  80a775:	8d 14 50             	lea    (%eax,%edx,2),%edx
  80a778:	8d 14 90             	lea    (%eax,%edx,4),%edx
  80a77b:	8d 3c d0             	lea    (%eax,%edx,8),%edi
  80a77e:	f7 df                	neg    %edi
  80a780:	89 fe                	mov    %edi,%esi
    mbe->head = -1;
  80a782:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a789:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a790:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a797:	e8 3b fd ff ff       	call   80a4d7 <sys_sem_new>
  80a79c:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a7a2:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a7a9:	e8 29 fd ff ff       	call   80a4d7 <sys_sem_new>
  80a7ae:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a7b4:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a7bb:	74 05                	je     80a7c2 <sys_mbox_new+0x112>
  80a7bd:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a7c0:	75 19                	jne    80a7db <sys_mbox_new+0x12b>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80a7c2:	89 3c 24             	mov    %edi,(%esp)
  80a7c5:	e8 1d fe ff ff       	call   80a5e7 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a7ca:	c7 04 24 88 20 81 00 	movl   $0x812088,(%esp)
  80a7d1:	e8 9a 47 00 00       	call   80ef70 <cprintf>
	return SYS_MBOX_NULL;
  80a7d6:	be ff ff ff ff       	mov    $0xffffffff,%esi
    }
    return i;
}
  80a7db:	89 f0                	mov    %esi,%eax
  80a7dd:	83 c4 1c             	add    $0x1c,%esp
  80a7e0:	5b                   	pop    %ebx
  80a7e1:	5e                   	pop    %esi
  80a7e2:	5f                   	pop    %edi
  80a7e3:	5d                   	pop    %ebp
  80a7e4:	c3                   	ret    

0080a7e5 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80a7e5:	55                   	push   %ebp
  80a7e6:	89 e5                	mov    %esp,%ebp
  80a7e8:	83 ec 18             	sub    $0x18,%esp
  80a7eb:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a7ee:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a7f1:	83 3c 95 80 4b b3 00 	cmpl   $0x0,0xb34b80(,%edx,4)
  80a7f8:	00 
  80a7f9:	74 24                	je     80a81f <sys_sem_signal+0x3a>
  80a7fb:	c7 44 24 0c e9 21 81 	movl   $0x8121e9,0xc(%esp)
  80a802:	00 
  80a803:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a80a:	00 
  80a80b:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80a812:	00 
  80a813:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a81a:	e8 59 46 00 00       	call   80ee78 <_panic>
    sems[sem].counter++;
  80a81f:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a822:	8d 14 95 80 4b b3 00 	lea    0xb34b80(,%edx,4),%edx
  80a829:	66 ff 42 08          	incw   0x8(%edx)
    if (sems[sem].waiters) {
  80a82d:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a832:	74 13                	je     80a847 <sys_sem_signal+0x62>
	sems[sem].waiters = 0;
  80a834:	89 d0                	mov    %edx,%eax
  80a836:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
	thread_wakeup(&sems[sem].v);
  80a83c:	83 c0 08             	add    $0x8,%eax
  80a83f:	89 04 24             	mov    %eax,(%esp)
  80a842:	e8 64 05 00 00       	call   80adab <thread_wakeup>
    }
}
  80a847:	c9                   	leave  
  80a848:	c3                   	ret    

0080a849 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a849:	55                   	push   %ebp
  80a84a:	89 e5                	mov    %esp,%ebp
  80a84c:	57                   	push   %edi
  80a84d:	56                   	push   %esi
  80a84e:	53                   	push   %ebx
  80a84f:	83 ec 2c             	sub    $0x2c,%esp
  80a852:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a855:	8b 55 08             	mov    0x8(%ebp),%edx
  80a858:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80a85b:	83 3c 85 80 4b b3 00 	cmpl   $0x0,0xb34b80(,%eax,4)
  80a862:	00 
  80a863:	74 24                	je     80a889 <sys_arch_sem_wait+0x40>
  80a865:	c7 44 24 0c e9 21 81 	movl   $0x8121e9,0xc(%esp)
  80a86c:	00 
  80a86d:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a874:	00 
  80a875:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a87c:	00 
  80a87d:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a884:	e8 ef 45 00 00       	call   80ee78 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a889:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a88c:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80a88f:	8b 04 85 84 4b b3 00 	mov    0xb34b84(,%eax,4),%eax
  80a896:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a899:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a89e:	8d 1c 89             	lea    (%ecx,%ecx,4),%ebx
  80a8a1:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80a8a4:	89 df                	mov    %ebx,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a8a6:	e9 8c 00 00 00       	jmp    80a937 <sys_arch_sem_wait+0xee>
	if (sems[sem].counter > 0) {
  80a8ab:	8b 04 bd 88 4b b3 00 	mov    0xb34b88(,%edi,4),%eax
  80a8b2:	66 85 c0             	test   %ax,%ax
  80a8b5:	74 17                	je     80a8ce <sys_arch_sem_wait+0x85>
  80a8b7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	    sems[sem].counter--;
  80a8ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a8bd:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80a8c0:	48                   	dec    %eax
  80a8c1:	66 89 04 95 88 4b b3 	mov    %ax,0xb34b88(,%edx,4)
  80a8c8:	00 
	    return waited;
  80a8c9:	e9 86 00 00 00       	jmp    80a954 <sys_arch_sem_wait+0x10b>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a8ce:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a8d1:	74 7c                	je     80a94f <sys_arch_sem_wait+0x106>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a8d3:	e8 9d 52 00 00       	call   80fb75 <sys_time_msec>
  80a8d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a8db:	85 f6                	test   %esi,%esi
  80a8dd:	74 0a                	je     80a8e9 <sys_arch_sem_wait+0xa0>
  80a8df:	89 f0                	mov    %esi,%eax
  80a8e1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80a8e4:	03 45 e0             	add    -0x20(%ebp),%eax
  80a8e7:	eb 05                	jmp    80a8ee <sys_arch_sem_wait+0xa5>
  80a8e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    sems[sem].waiters = 1;
  80a8ee:	8d 1c bd 80 4b b3 00 	lea    0xb34b80(,%edi,4),%ebx
  80a8f5:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a8fb:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a8ff:	8b 43 08             	mov    0x8(%ebx),%eax
  80a902:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a906:	8d 43 08             	lea    0x8(%ebx),%eax
  80a909:	89 04 24             	mov    %eax,(%esp)
  80a90c:	e8 7f 07 00 00       	call   80b090 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a911:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a914:	39 43 04             	cmp    %eax,0x4(%ebx)
  80a917:	74 13                	je     80a92c <sys_arch_sem_wait+0xe3>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a919:	c7 04 24 b4 20 81 00 	movl   $0x8120b4,(%esp)
  80a920:	e8 4b 46 00 00       	call   80ef70 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a925:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a92a:	eb 28                	jmp    80a954 <sys_arch_sem_wait+0x10b>
	    }
	    uint32_t b = sys_time_msec();
  80a92c:	e8 44 52 00 00       	call   80fb75 <sys_time_msec>
	    waited += (b - a);
  80a931:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a934:	01 45 e4             	add    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a937:	85 f6                	test   %esi,%esi
  80a939:	0f 84 6c ff ff ff    	je     80a8ab <sys_arch_sem_wait+0x62>
  80a93f:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80a942:	0f 82 63 ff ff ff    	jb     80a8ab <sys_arch_sem_wait+0x62>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a948:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a94d:	eb 05                	jmp    80a954 <sys_arch_sem_wait+0x10b>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a94f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a954:	89 f8                	mov    %edi,%eax
  80a956:	83 c4 2c             	add    $0x2c,%esp
  80a959:	5b                   	pop    %ebx
  80a95a:	5e                   	pop    %esi
  80a95b:	5f                   	pop    %edi
  80a95c:	5d                   	pop    %ebp
  80a95d:	c3                   	ret    

0080a95e <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a95e:	55                   	push   %ebp
  80a95f:	89 e5                	mov    %esp,%ebp
  80a961:	56                   	push   %esi
  80a962:	53                   	push   %ebx
  80a963:	83 ec 10             	sub    $0x10,%esp
  80a966:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a969:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80a96c:	c1 e0 03             	shl    $0x3,%eax
  80a96f:	29 d8                	sub    %ebx,%eax
  80a971:	83 3c 85 a0 5f b3 00 	cmpl   $0x0,0xb35fa0(,%eax,4)
  80a978:	00 
  80a979:	74 24                	je     80a99f <sys_mbox_trypost+0x41>
  80a97b:	c7 44 24 0c fa 21 81 	movl   $0x8121fa,0xc(%esp)
  80a982:	00 
  80a983:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80a98a:	00 
  80a98b:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80a992:	00 
  80a993:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80a99a:	e8 d9 44 00 00       	call   80ee78 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a99f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a9a6:	00 
  80a9a7:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
  80a9ae:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
  80a9b1:	c1 e0 03             	shl    $0x3,%eax
  80a9b4:	29 d8                	sub    %ebx,%eax
  80a9b6:	8b 04 85 30 60 b3 00 	mov    0xb36030(,%eax,4),%eax
  80a9bd:	89 04 24             	mov    %eax,(%esp)
  80a9c0:	e8 84 fe ff ff       	call   80a849 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a9c5:	01 de                	add    %ebx,%esi
  80a9c7:	c1 e6 03             	shl    $0x3,%esi
  80a9ca:	29 de                	sub    %ebx,%esi
  80a9cc:	8d 14 b5 a0 5f b3 00 	lea    0xb35fa0(,%esi,4),%edx
  80a9d3:	8b 42 08             	mov    0x8(%edx),%eax
  80a9d6:	3b 42 04             	cmp    0x4(%edx),%eax
  80a9d9:	74 6b                	je     80aa46 <sys_mbox_trypost+0xe8>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a9db:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80a9de:	c1 e2 03             	shl    $0x3,%edx
  80a9e1:	29 da                	sub    %ebx,%edx
  80a9e3:	8d 0c 95 a0 5f b3 00 	lea    0xb35fa0(,%edx,4),%ecx
  80a9ea:	8d 50 01             	lea    0x1(%eax),%edx
  80a9ed:	81 e2 1f 00 00 80    	and    $0x8000001f,%edx
  80a9f3:	79 05                	jns    80a9fa <sys_mbox_trypost+0x9c>
  80a9f5:	4a                   	dec    %edx
  80a9f6:	83 ca e0             	or     $0xffffffe0,%edx
  80a9f9:	42                   	inc    %edx
  80a9fa:	89 51 08             	mov    %edx,0x8(%ecx)
    mboxes[mbox].msg[slot] = msg;
  80a9fd:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80aa00:	c1 e2 03             	shl    $0x3,%edx
  80aa03:	29 da                	sub    %ebx,%edx
  80aa05:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80aa08:	8b 75 0c             	mov    0xc(%ebp),%esi
  80aa0b:	89 34 8d ac 5f b3 00 	mov    %esi,0xb35fac(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80aa12:	83 3c 95 a4 5f b3 00 	cmpl   $0xffffffff,0xb35fa4(,%edx,4)
  80aa19:	ff 
  80aa1a:	75 0f                	jne    80aa2b <sys_mbox_trypost+0xcd>
	mboxes[mbox].head = slot;
  80aa1c:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80aa1f:	c1 e2 03             	shl    $0x3,%edx
  80aa22:	29 da                	sub    %ebx,%edx
  80aa24:	89 04 95 a4 5f b3 00 	mov    %eax,0xb35fa4(,%edx,4)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80aa2b:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aa2e:	c1 e0 03             	shl    $0x3,%eax
  80aa31:	29 d8                	sub    %ebx,%eax
  80aa33:	8b 04 85 2c 60 b3 00 	mov    0xb3602c(,%eax,4),%eax
  80aa3a:	89 04 24             	mov    %eax,(%esp)
  80aa3d:	e8 a3 fd ff ff       	call   80a7e5 <sys_sem_signal>

    return ERR_OK;
  80aa42:	b0 00                	mov    $0x0,%al
  80aa44:	eb 02                	jmp    80aa48 <sys_mbox_trypost+0xea>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80aa46:	b0 ff                	mov    $0xff,%al
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80aa48:	83 c4 10             	add    $0x10,%esp
  80aa4b:	5b                   	pop    %ebx
  80aa4c:	5e                   	pop    %esi
  80aa4d:	5d                   	pop    %ebp
  80aa4e:	c3                   	ret    

0080aa4f <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80aa4f:	55                   	push   %ebp
  80aa50:	89 e5                	mov    %esp,%ebp
  80aa52:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80aa55:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aa58:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa5c:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa5f:	89 04 24             	mov    %eax,(%esp)
  80aa62:	e8 f7 fe ff ff       	call   80a95e <sys_mbox_trypost>
  80aa67:	84 c0                	test   %al,%al
  80aa69:	74 24                	je     80aa8f <sys_mbox_post+0x40>
  80aa6b:	c7 44 24 0c e0 20 81 	movl   $0x8120e0,0xc(%esp)
  80aa72:	00 
  80aa73:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80aa7a:	00 
  80aa7b:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80aa82:	00 
  80aa83:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80aa8a:	e8 e9 43 00 00       	call   80ee78 <_panic>
}
  80aa8f:	c9                   	leave  
  80aa90:	c3                   	ret    

0080aa91 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80aa91:	55                   	push   %ebp
  80aa92:	89 e5                	mov    %esp,%ebp
  80aa94:	57                   	push   %edi
  80aa95:	56                   	push   %esi
  80aa96:	53                   	push   %ebx
  80aa97:	83 ec 1c             	sub    $0x1c,%esp
  80aa9a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aa9d:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80aaa0:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aaa3:	c1 e0 03             	shl    $0x3,%eax
  80aaa6:	29 d8                	sub    %ebx,%eax
  80aaa8:	83 3c 85 a0 5f b3 00 	cmpl   $0x0,0xb35fa0(,%eax,4)
  80aaaf:	00 
  80aab0:	74 24                	je     80aad6 <sys_arch_mbox_fetch+0x45>
  80aab2:	c7 44 24 0c fa 21 81 	movl   $0x8121fa,0xc(%esp)
  80aab9:	00 
  80aaba:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  80aac1:	00 
  80aac2:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80aac9:	00 
  80aaca:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80aad1:	e8 a2 43 00 00       	call   80ee78 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80aad6:	8b 45 10             	mov    0x10(%ebp),%eax
  80aad9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aadd:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80aae0:	c1 e0 03             	shl    $0x3,%eax
  80aae3:	29 d8                	sub    %ebx,%eax
  80aae5:	8b 04 85 2c 60 b3 00 	mov    0xb3602c(,%eax,4),%eax
  80aaec:	89 04 24             	mov    %eax,(%esp)
  80aaef:	e8 55 fd ff ff       	call   80a849 <sys_arch_sem_wait>
  80aaf4:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80aaf6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aaf9:	0f 84 93 00 00 00    	je     80ab92 <sys_arch_mbox_fetch+0x101>
	return waited;

    int slot = mboxes[mbox].head;
  80aaff:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80ab02:	c1 e0 03             	shl    $0x3,%eax
  80ab05:	29 d8                	sub    %ebx,%eax
  80ab07:	8b 04 85 a4 5f b3 00 	mov    0xb35fa4(,%eax,4),%eax
    if (slot == -1)
  80ab0e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ab11:	75 1c                	jne    80ab2f <sys_arch_mbox_fetch+0x9e>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80ab13:	c7 44 24 08 08 21 81 	movl   $0x812108,0x8(%esp)
  80ab1a:	00 
  80ab1b:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80ab22:	00 
  80ab23:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80ab2a:	e8 49 43 00 00       	call   80ee78 <_panic>
    if (msg)
  80ab2f:	85 ff                	test   %edi,%edi
  80ab31:	74 11                	je     80ab44 <sys_arch_mbox_fetch+0xb3>
	*msg = mboxes[mbox].msg[slot];
  80ab33:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80ab36:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  80ab39:	29 da                	sub    %ebx,%edx
  80ab3b:	8b 14 95 ac 5f b3 00 	mov    0xb35fac(,%edx,4),%edx
  80ab42:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ab44:	40                   	inc    %eax
  80ab45:	25 1f 00 00 80       	and    $0x8000001f,%eax
  80ab4a:	79 05                	jns    80ab51 <sys_arch_mbox_fetch+0xc0>
  80ab4c:	48                   	dec    %eax
  80ab4d:	83 c8 e0             	or     $0xffffffe0,%eax
  80ab50:	40                   	inc    %eax
  80ab51:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  80ab54:	c1 e2 03             	shl    $0x3,%edx
  80ab57:	29 da                	sub    %ebx,%edx
  80ab59:	8d 14 95 a0 5f b3 00 	lea    0xb35fa0(,%edx,4),%edx
  80ab60:	89 42 04             	mov    %eax,0x4(%edx)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80ab63:	3b 42 08             	cmp    0x8(%edx),%eax
  80ab66:	75 13                	jne    80ab7b <sys_arch_mbox_fetch+0xea>
	mboxes[mbox].head = -1;
  80ab68:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80ab6b:	c1 e0 03             	shl    $0x3,%eax
  80ab6e:	29 d8                	sub    %ebx,%eax
  80ab70:	c7 04 85 a4 5f b3 00 	movl   $0xffffffff,0xb35fa4(,%eax,4)
  80ab77:	ff ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80ab7b:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80ab7e:	c1 e0 03             	shl    $0x3,%eax
  80ab81:	29 d8                	sub    %ebx,%eax
  80ab83:	8b 04 85 30 60 b3 00 	mov    0xb36030(,%eax,4),%eax
  80ab8a:	89 04 24             	mov    %eax,(%esp)
  80ab8d:	e8 53 fc ff ff       	call   80a7e5 <sys_sem_signal>
    return waited;
}
  80ab92:	89 f0                	mov    %esi,%eax
  80ab94:	83 c4 1c             	add    $0x1c,%esp
  80ab97:	5b                   	pop    %ebx
  80ab98:	5e                   	pop    %esi
  80ab99:	5f                   	pop    %edi
  80ab9a:	5d                   	pop    %ebp
  80ab9b:	c3                   	ret    

0080ab9c <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80ab9c:	55                   	push   %ebp
  80ab9d:	89 e5                	mov    %esp,%ebp
  80ab9f:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80aba2:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80aba9:	ff 
  80abaa:	8b 45 0c             	mov    0xc(%ebp),%eax
  80abad:	89 44 24 04          	mov    %eax,0x4(%esp)
  80abb1:	8b 45 08             	mov    0x8(%ebp),%eax
  80abb4:	89 04 24             	mov    %eax,(%esp)
  80abb7:	e8 d5 fe ff ff       	call   80aa91 <sys_arch_mbox_fetch>
}
  80abbc:	c9                   	leave  
  80abbd:	c3                   	ret    

0080abbe <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80abbe:	55                   	push   %ebp
  80abbf:	89 e5                	mov    %esp,%ebp
  80abc1:	53                   	push   %ebx
  80abc2:	83 ec 24             	sub    $0x24,%esp
  80abc5:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80abc8:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80abcf:	e8 bc 58 00 00       	call   810490 <malloc>
    if (lt == 0)
  80abd4:	85 c0                	test   %eax,%eax
  80abd6:	75 1c                	jne    80abf4 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80abd8:	c7 44 24 08 30 21 81 	movl   $0x812130,0x8(%esp)
  80abdf:	00 
  80abe0:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80abe7:	00 
  80abe8:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80abef:	e8 84 42 00 00       	call   80ee78 <_panic>

    if (stacksize > PGSIZE)
  80abf4:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80abfa:	7e 20                	jle    80ac1c <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80abfc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80ac00:	c7 44 24 08 2a 22 81 	movl   $0x81222a,0x8(%esp)
  80ac07:	00 
  80ac08:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80ac0f:	00 
  80ac10:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80ac17:	e8 5c 42 00 00       	call   80ee78 <_panic>

    lt->func = thread;
  80ac1c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac1f:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80ac21:	8b 55 10             	mov    0x10(%ebp),%edx
  80ac24:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80ac27:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac2b:	c7 44 24 08 09 a4 80 	movl   $0x80a409,0x8(%esp)
  80ac32:	00 
  80ac33:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac36:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ac3a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ac3d:	89 04 24             	mov    %eax,(%esp)
  80ac40:	e8 d0 01 00 00       	call   80ae15 <thread_create>

    if (r < 0)
  80ac45:	85 c0                	test   %eax,%eax
  80ac47:	79 28                	jns    80ac71 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80ac49:	89 04 24             	mov    %eax,(%esp)
  80ac4c:	e8 f7 04 00 00       	call   80b148 <e2s>
  80ac51:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac55:	c7 44 24 08 60 21 81 	movl   $0x812160,0x8(%esp)
  80ac5c:	00 
  80ac5d:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80ac64:	00 
  80ac65:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80ac6c:	e8 07 42 00 00       	call   80ee78 <_panic>

    return tid;
}
  80ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ac74:	83 c4 24             	add    $0x24,%esp
  80ac77:	5b                   	pop    %ebx
  80ac78:	5d                   	pop    %ebp
  80ac79:	c3                   	ret    

0080ac7a <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80ac7a:	55                   	push   %ebp
  80ac7b:	89 e5                	mov    %esp,%ebp
  80ac7d:	57                   	push   %edi
  80ac7e:	56                   	push   %esi
  80ac7f:	53                   	push   %ebx
  80ac80:	83 ec 2c             	sub    $0x2c,%esp
    thread_id_t tid = thread_id();
  80ac83:	e8 17 01 00 00       	call   80ad9f <thread_id>
  80ac88:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ac8a:	b9 01 01 00 00       	mov    $0x101,%ecx
  80ac8f:	ba 00 00 00 00       	mov    $0x0,%edx
  80ac94:	f7 f1                	div    %ecx
  80ac96:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
  80ac9d:	8d 87 c0 ad b3 00    	lea    0xb3adc0(%edi),%eax
  80aca3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80aca6:	8b 9f c0 ad b3 00    	mov    0xb3adc0(%edi),%ebx
  80acac:	eb 0b                	jmp    80acb9 <sys_arch_timeouts+0x3f>
	if (t->tid == tid)
  80acae:	39 33                	cmp    %esi,(%ebx)
  80acb0:	0f 84 af 00 00 00    	je     80ad65 <sys_arch_timeouts+0xeb>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80acb6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80acb9:	85 db                	test   %ebx,%ebx
  80acbb:	75 f1                	jne    80acae <sys_arch_timeouts+0x34>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80acbd:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80acc4:	e8 c7 57 00 00       	call   810490 <malloc>
  80acc9:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80accb:	85 c0                	test   %eax,%eax
  80accd:	75 1c                	jne    80aceb <sys_arch_timeouts+0x71>
	panic("sys_arch_timeouts: cannot malloc");
  80accf:	c7 44 24 08 8c 21 81 	movl   $0x81218c,0x8(%esp)
  80acd6:	00 
  80acd7:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80acde:	00 
  80acdf:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80ace6:	e8 8d 41 00 00       	call   80ee78 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80aceb:	c7 04 24 b8 a3 80 00 	movl   $0x80a3b8,(%esp)
  80acf2:	e8 f5 00 00 00       	call   80adec <thread_onhalt>
    if (r < 0)
  80acf7:	85 c0                	test   %eax,%eax
  80acf9:	79 28                	jns    80ad23 <sys_arch_timeouts+0xa9>
	panic("thread_onhalt failed: %s", e2s(r));
  80acfb:	89 04 24             	mov    %eax,(%esp)
  80acfe:	e8 45 04 00 00       	call   80b148 <e2s>
  80ad03:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad07:	c7 44 24 08 39 22 81 	movl   $0x812239,0x8(%esp)
  80ad0e:	00 
  80ad0f:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80ad16:	00 
  80ad17:	c7 04 24 cc 21 81 00 	movl   $0x8121cc,(%esp)
  80ad1e:	e8 55 41 00 00       	call   80ee78 <_panic>

    t->tid = tid;
  80ad23:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80ad25:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ad2c:	00 
  80ad2d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ad34:	00 
  80ad35:	8d 43 04             	lea    0x4(%ebx),%eax
  80ad38:	89 04 24             	mov    %eax,(%esp)
  80ad3b:	e8 0a 49 00 00       	call   80f64a <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80ad40:	8b 87 c0 ad b3 00    	mov    0xb3adc0(%edi),%eax
  80ad46:	89 43 08             	mov    %eax,0x8(%ebx)
  80ad49:	85 c0                	test   %eax,%eax
  80ad4b:	74 0c                	je     80ad59 <sys_arch_timeouts+0xdf>
  80ad4d:	8b 87 c0 ad b3 00    	mov    0xb3adc0(%edi),%eax
  80ad53:	8d 53 08             	lea    0x8(%ebx),%edx
  80ad56:	89 50 0c             	mov    %edx,0xc(%eax)
  80ad59:	89 9f c0 ad b3 00    	mov    %ebx,0xb3adc0(%edi)
  80ad5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ad62:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80ad65:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80ad68:	83 c4 2c             	add    $0x2c,%esp
  80ad6b:	5b                   	pop    %ebx
  80ad6c:	5e                   	pop    %esi
  80ad6d:	5f                   	pop    %edi
  80ad6e:	5d                   	pop    %ebp
  80ad6f:	c3                   	ret    

0080ad70 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80ad70:	55                   	push   %ebp
  80ad71:	89 e5                	mov    %esp,%ebp
}
  80ad73:	5d                   	pop    %ebp
  80ad74:	c3                   	ret    

0080ad75 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80ad75:	55                   	push   %ebp
  80ad76:	89 e5                	mov    %esp,%ebp
}
  80ad78:	5d                   	pop    %ebp
  80ad79:	c3                   	ret    
	...

0080ad7c <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80ad7c:	55                   	push   %ebp
  80ad7d:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80ad7f:	c7 05 c4 b1 b3 00 00 	movl   $0x0,0xb3b1c4
  80ad86:	00 00 00 
    tq->tq_last = 0;
  80ad89:	c7 05 c8 b1 b3 00 00 	movl   $0x0,0xb3b1c8
  80ad90:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80ad93:	c7 05 cc b1 b3 00 00 	movl   $0x0,0xb3b1cc
  80ad9a:	00 00 00 
}
  80ad9d:	5d                   	pop    %ebp
  80ad9e:	c3                   	ret    

0080ad9f <thread_id>:

uint32_t
thread_id(void) {
  80ad9f:	55                   	push   %ebp
  80ada0:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80ada2:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80ada7:	8b 00                	mov    (%eax),%eax
}
  80ada9:	5d                   	pop    %ebp
  80adaa:	c3                   	ret    

0080adab <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80adab:	55                   	push   %ebp
  80adac:	89 e5                	mov    %esp,%ebp
  80adae:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80adb1:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
    while (tc) {
  80adb6:	eb 0c                	jmp    80adc4 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80adb8:	39 50 48             	cmp    %edx,0x48(%eax)
  80adbb:	75 04                	jne    80adc1 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80adbd:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80adc1:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80adc4:	85 c0                	test   %eax,%eax
  80adc6:	75 f0                	jne    80adb8 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80adc8:	5d                   	pop    %ebp
  80adc9:	c3                   	ret    

0080adca <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80adca:	55                   	push   %ebp
  80adcb:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80adcd:	8b 15 c4 b1 b3 00    	mov    0xb3b1c4,%edx
    int n = 0;
  80add3:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80add8:	eb 0c                	jmp    80ade6 <thread_wakeups_pending+0x1c>
	if (tc->tc_wakeup)
  80adda:	8a 4a 4c             	mov    0x4c(%edx),%cl
	    ++n;
  80addd:	80 f9 01             	cmp    $0x1,%cl
  80ade0:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80ade3:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80ade6:	85 d2                	test   %edx,%edx
  80ade8:	75 f0                	jne    80adda <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80adea:	5d                   	pop    %ebp
  80adeb:	c3                   	ret    

0080adec <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80adec:	55                   	push   %ebp
  80aded:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80adef:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80adf4:	8b 50 60             	mov    0x60(%eax),%edx
  80adf7:	83 fa 03             	cmp    $0x3,%edx
  80adfa:	7f 12                	jg     80ae0e <thread_onhalt+0x22>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80adfc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80adff:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
  80ae03:	42                   	inc    %edx
  80ae04:	89 50 60             	mov    %edx,0x60(%eax)
    return 0;
  80ae07:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae0c:	eb 05                	jmp    80ae13 <thread_onhalt+0x27>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80ae0e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80ae13:	5d                   	pop    %ebp
  80ae14:	c3                   	ret    

0080ae15 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80ae15:	55                   	push   %ebp
  80ae16:	89 e5                	mov    %esp,%ebp
  80ae18:	57                   	push   %edi
  80ae19:	56                   	push   %esi
  80ae1a:	53                   	push   %ebx
  80ae1b:	83 ec 1c             	sub    $0x1c,%esp
  80ae1e:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80ae21:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80ae28:	e8 63 56 00 00       	call   810490 <malloc>
  80ae2d:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80ae2f:	85 c0                	test   %eax,%eax
  80ae31:	0f 84 16 01 00 00    	je     80af4d <thread_create+0x138>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80ae37:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80ae3e:	00 
  80ae3f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ae46:	00 
  80ae47:	89 04 24             	mov    %eax,(%esp)
  80ae4a:	e8 fb 47 00 00       	call   80f64a <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80ae4f:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80ae56:	00 
  80ae57:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ae5a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ae5e:	8d 43 08             	lea    0x8(%ebx),%eax
  80ae61:	89 04 24             	mov    %eax,(%esp)
  80ae64:	e8 fa 46 00 00       	call   80f563 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80ae69:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80ae6d:	8b 15 cc b1 b3 00    	mov    0xb3b1cc,%edx
  80ae73:	8d 42 01             	lea    0x1(%edx),%eax
  80ae76:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
    if (max_tid == (uint32_t)~0)
  80ae7b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae7e:	75 1c                	jne    80ae9c <thread_create+0x87>
	panic("alloc_tid: no more thread ids");
  80ae80:	c7 44 24 08 52 22 81 	movl   $0x812252,0x8(%esp)
  80ae87:	00 
  80ae88:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80ae8f:	00 
  80ae90:	c7 04 24 70 22 81 00 	movl   $0x812270,(%esp)
  80ae97:	e8 dc 3f 00 00       	call   80ee78 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80ae9c:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80ae9e:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80aea5:	e8 e6 55 00 00       	call   810490 <malloc>
  80aeaa:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80aead:	85 c0                	test   %eax,%eax
  80aeaf:	75 12                	jne    80aec3 <thread_create+0xae>
	free(tc);
  80aeb1:	89 1c 24             	mov    %ebx,(%esp)
  80aeb4:	e8 07 55 00 00       	call   8103c0 <free>
	return -E_NO_MEM;
  80aeb9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aebe:	e9 96 00 00 00       	jmp    80af59 <thread_create+0x144>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80aec3:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80aec9:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80aed0:	00 
  80aed1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aed8:	00 
  80aed9:	89 34 24             	mov    %esi,(%esp)
  80aedc:	e8 69 47 00 00       	call   80f64a <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80aee1:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80aee8:	00 
  80aee9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aef0:	00 
  80aef1:	8d 43 30             	lea    0x30(%ebx),%eax
  80aef4:	89 04 24             	mov    %eax,(%esp)
  80aef7:	e8 4e 47 00 00       	call   80f64a <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80aefc:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80aeff:	c7 43 30 75 b0 80 00 	movl   $0x80b075,0x30(%ebx)
    tc->tc_entry = entry;
  80af06:	8b 45 10             	mov    0x10(%ebp),%eax
  80af09:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80af0c:	8b 45 14             	mov    0x14(%ebp),%eax
  80af0f:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80af12:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80af19:	83 3d c4 b1 b3 00 00 	cmpl   $0x0,0xb3b1c4
  80af20:	75 0e                	jne    80af30 <thread_create+0x11b>
	tq->tq_first = tc;
  80af22:	89 1d c4 b1 b3 00    	mov    %ebx,0xb3b1c4
	tq->tq_last = tc;
  80af28:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80af2e:	eb 0e                	jmp    80af3e <thread_create+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80af30:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80af35:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80af38:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8

    threadq_push(&thread_queue, tc);

    if (tid)
  80af3e:	85 ff                	test   %edi,%edi
  80af40:	74 12                	je     80af54 <thread_create+0x13f>
	*tid = tc->tc_tid;
  80af42:	8b 03                	mov    (%ebx),%eax
  80af44:	89 07                	mov    %eax,(%edi)
    return 0;
  80af46:	b8 00 00 00 00       	mov    $0x0,%eax
  80af4b:	eb 0c                	jmp    80af59 <thread_create+0x144>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80af4d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80af52:	eb 05                	jmp    80af59 <thread_create+0x144>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80af54:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80af59:	83 c4 1c             	add    $0x1c,%esp
  80af5c:	5b                   	pop    %ebx
  80af5d:	5e                   	pop    %esi
  80af5e:	5f                   	pop    %edi
  80af5f:	5d                   	pop    %ebp
  80af60:	c3                   	ret    

0080af61 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80af61:	55                   	push   %ebp
  80af62:	89 e5                	mov    %esp,%ebp
  80af64:	53                   	push   %ebx
  80af65:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80af68:	8b 1d c4 b1 b3 00    	mov    0xb3b1c4,%ebx
  80af6e:	85 db                	test   %ebx,%ebx
  80af70:	74 69                	je     80afdb <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80af72:	8b 43 64             	mov    0x64(%ebx),%eax
  80af75:	a3 c4 b1 b3 00       	mov    %eax,0xb3b1c4
    tc->tc_queue_link = 0;
  80af7a:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80af81:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80af86:	85 c0                	test   %eax,%eax
  80af88:	74 3e                	je     80afc8 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80af8a:	83 c0 30             	add    $0x30,%eax
  80af8d:	89 04 24             	mov    %eax,(%esp)
  80af90:	e8 6b 01 00 00       	call   80b100 <jos_setjmp>
  80af95:	85 c0                	test   %eax,%eax
  80af97:	75 42                	jne    80afdb <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80af99:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80af9e:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80afa5:	83 3d c4 b1 b3 00 00 	cmpl   $0x0,0xb3b1c4
  80afac:	75 0c                	jne    80afba <thread_yield+0x59>
	tq->tq_first = tc;
  80afae:	a3 c4 b1 b3 00       	mov    %eax,0xb3b1c4
	tq->tq_last = tc;
  80afb3:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
  80afb8:	eb 0e                	jmp    80afc8 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80afba:	8b 15 c8 b1 b3 00    	mov    0xb3b1c8,%edx
  80afc0:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80afc3:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
    }

    cur_tc = next_tc;
  80afc8:	89 1d d0 b1 b3 00    	mov    %ebx,0xb3b1d0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80afce:	8d 43 30             	lea    0x30(%ebx),%eax
  80afd1:	ba 01 00 00 00       	mov    $0x1,%edx
  80afd6:	e8 55 01 00 00       	call   80b130 <jos_longjmp>
}
  80afdb:	83 c4 14             	add    $0x14,%esp
  80afde:	5b                   	pop    %ebx
  80afdf:	5d                   	pop    %ebp
  80afe0:	c3                   	ret    

0080afe1 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80afe1:	55                   	push   %ebp
  80afe2:	89 e5                	mov    %esp,%ebp
  80afe4:	56                   	push   %esi
  80afe5:	53                   	push   %ebx
  80afe6:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80afe9:	8b 1d d4 b1 b3 00    	mov    0xb3b1d4,%ebx
  80afef:	85 db                	test   %ebx,%ebx
  80aff1:	74 38                	je     80b02b <thread_halt+0x4a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80aff3:	8b 43 64             	mov    0x64(%ebx),%eax
  80aff6:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
    tc->tc_queue_link = 0;
  80affb:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80b002:	be 00 00 00 00       	mov    $0x0,%esi
  80b007:	eb 0a                	jmp    80b013 <thread_halt+0x32>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80b009:	8b 03                	mov    (%ebx),%eax
  80b00b:	89 04 24             	mov    %eax,(%esp)
  80b00e:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80b012:	46                   	inc    %esi
  80b013:	3b 73 60             	cmp    0x60(%ebx),%esi
  80b016:	7c f1                	jl     80b009 <thread_halt+0x28>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80b018:	8b 43 04             	mov    0x4(%ebx),%eax
  80b01b:	89 04 24             	mov    %eax,(%esp)
  80b01e:	e8 9d 53 00 00       	call   8103c0 <free>
    free(tc);
  80b023:	89 1c 24             	mov    %ebx,(%esp)
  80b026:	e8 95 53 00 00       	call   8103c0 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b02b:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b030:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b037:	83 3d d4 b1 b3 00 00 	cmpl   $0x0,0xb3b1d4
  80b03e:	75 0c                	jne    80b04c <thread_halt+0x6b>
	tq->tq_first = tc;
  80b040:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	tq->tq_last = tc;
  80b045:	a3 d8 b1 b3 00       	mov    %eax,0xb3b1d8
  80b04a:	eb 0e                	jmp    80b05a <thread_halt+0x79>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b04c:	8b 15 d8 b1 b3 00    	mov    0xb3b1d8,%edx
  80b052:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b055:	a3 d8 b1 b3 00       	mov    %eax,0xb3b1d8
    cur_tc = NULL;
  80b05a:	c7 05 d0 b1 b3 00 00 	movl   $0x0,0xb3b1d0
  80b061:	00 00 00 
    thread_yield();
  80b064:	e8 f8 fe ff ff       	call   80af61 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b069:	e8 f6 3d 00 00       	call   80ee64 <exit>
}
  80b06e:	83 c4 10             	add    $0x10,%esp
  80b071:	5b                   	pop    %ebx
  80b072:	5e                   	pop    %esi
  80b073:	5d                   	pop    %ebp
  80b074:	c3                   	ret    

0080b075 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b075:	55                   	push   %ebp
  80b076:	89 e5                	mov    %esp,%ebp
  80b078:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b07b:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80b080:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b083:	89 14 24             	mov    %edx,(%esp)
  80b086:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b089:	e8 53 ff ff ff       	call   80afe1 <thread_halt>
}
  80b08e:	c9                   	leave  
  80b08f:	c3                   	ret    

0080b090 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b090:	55                   	push   %ebp
  80b091:	89 e5                	mov    %esp,%ebp
  80b093:	57                   	push   %edi
  80b094:	56                   	push   %esi
  80b095:	53                   	push   %ebx
  80b096:	83 ec 0c             	sub    $0xc,%esp
  80b099:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b09c:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b09f:	e8 d1 4a 00 00       	call   80fb75 <sys_time_msec>
  80b0a4:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b0a6:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80b0ab:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b0ae:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80b0b2:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b0b4:	eb 25                	jmp    80b0db <thread_wait+0x4b>
	if (p < s)
  80b0b6:	39 f0                	cmp    %esi,%eax
  80b0b8:	72 25                	jb     80b0df <thread_wait+0x4f>
	    break;
	if (addr && *addr != val)
  80b0ba:	85 db                	test   %ebx,%ebx
  80b0bc:	74 07                	je     80b0c5 <thread_wait+0x35>
  80b0be:	8b 03                	mov    (%ebx),%eax
  80b0c0:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b0c3:	75 1a                	jne    80b0df <thread_wait+0x4f>
	    break;
	if (cur_tc->tc_wakeup)
  80b0c5:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80b0ca:	8a 40 4c             	mov    0x4c(%eax),%al
  80b0cd:	84 c0                	test   %al,%al
  80b0cf:	75 0e                	jne    80b0df <thread_wait+0x4f>
	    break;

	thread_yield();
  80b0d1:	e8 8b fe ff ff       	call   80af61 <thread_yield>
	p = sys_time_msec();
  80b0d6:	e8 9a 4a 00 00       	call   80fb75 <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b0db:	39 f8                	cmp    %edi,%eax
  80b0dd:	72 d7                	jb     80b0b6 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b0df:	a1 d0 b1 b3 00       	mov    0xb3b1d0,%eax
  80b0e4:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b0eb:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b0ef:	83 c4 0c             	add    $0xc,%esp
  80b0f2:	5b                   	pop    %ebx
  80b0f3:	5e                   	pop    %esi
  80b0f4:	5f                   	pop    %edi
  80b0f5:	5d                   	pop    %ebp
  80b0f6:	c3                   	ret    
	...

0080b100 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b100:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b104:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b107:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b109:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b10d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b110:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b113:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b116:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b119:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b11c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b121:	c3                   	ret    
  80b122:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b130 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b130:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b132:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b135:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b138:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b13b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b13e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b141:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b143:	ff e1                	jmp    *%ecx
  80b145:	00 00                	add    %al,(%eax)
	...

0080b148 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80b148:	55                   	push   %ebp
  80b149:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80b14b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b14e:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80b155:	5d                   	pop    %ebp
  80b156:	c3                   	ret    

0080b157 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b157:	55                   	push   %ebp
  80b158:	89 e5                	mov    %esp,%ebp
  80b15a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b15d:	a1 20 b2 b3 00       	mov    0xb3b220,%eax
  80b162:	89 04 24             	mov    %eax,(%esp)
  80b165:	e8 de ff ff ff       	call   80b148 <e2s>
  80b16a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b16e:	8b 45 08             	mov    0x8(%ebp),%eax
  80b171:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b175:	c7 04 24 8b 22 81 00 	movl   $0x81228b,(%esp)
  80b17c:	e8 ef 3d 00 00       	call   80ef70 <cprintf>
}
  80b181:	c9                   	leave  
  80b182:	c3                   	ret    
	...

0080b184 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b184:	55                   	push   %ebp
  80b185:	89 e5                	mov    %esp,%ebp
  80b187:	57                   	push   %edi
  80b188:	56                   	push   %esi
  80b189:	53                   	push   %ebx
  80b18a:	83 ec 2c             	sub    $0x2c,%esp
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b18d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b194:	00 
  80b195:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b19c:	10 
  80b19d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b1a4:	e8 64 47 00 00       	call   80f90d <sys_page_alloc>
    if (r < 0)
  80b1a9:	85 c0                	test   %eax,%eax
  80b1ab:	79 1c                	jns    80b1c9 <low_level_output+0x45>
	panic("jif: could not allocate page of memory");
  80b1ad:	c7 44 24 08 70 27 81 	movl   $0x812770,0x8(%esp)
  80b1b4:	00 
  80b1b5:	c7 44 24 04 57 00 00 	movl   $0x57,0x4(%esp)
  80b1bc:	00 
  80b1bd:	c7 04 24 c1 27 81 00 	movl   $0x8127c1,(%esp)
  80b1c4:	e8 af 3c 00 00       	call   80ee78 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b1c9:	8b 45 08             	mov    0x8(%ebp),%eax
  80b1cc:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b1cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx

    struct jif *jif;
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  80b1d2:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b1d7:	eb 5a                	jmp    80b233 <low_level_output+0xaf>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b1d9:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  80b1dd:	0f b7 d0             	movzwl %ax,%edx
  80b1e0:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80b1e3:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b1e9:	7e 24                	jle    80b20f <low_level_output+0x8b>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b1eb:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b1ef:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b1f3:	c7 44 24 08 98 27 81 	movl   $0x812798,0x8(%esp)
  80b1fa:	00 
  80b1fb:	c7 44 24 04 66 00 00 	movl   $0x66,0x4(%esp)
  80b202:	00 
  80b203:	c7 04 24 c1 27 81 00 	movl   $0x8127c1,(%esp)
  80b20a:	e8 69 3c 00 00       	call   80ee78 <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b20f:	0f b7 c0             	movzwl %ax,%eax
  80b212:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b216:	8b 43 04             	mov    0x4(%ebx),%eax
  80b219:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b21d:	8d 86 04 00 00 10    	lea    0x10000004(%esi),%eax
  80b223:	89 04 24             	mov    %eax,(%esp)
  80b226:	e8 d3 44 00 00       	call   80f6fe <memcpy>
	txsize += q->len;
  80b22b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b22f:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b231:	8b 1b                	mov    (%ebx),%ebx
  80b233:	85 db                	test   %ebx,%ebx
  80b235:	75 a2                	jne    80b1d9 <low_level_output+0x55>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80b237:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b23d:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b244:	00 
  80b245:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b24c:	10 
  80b24d:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b254:	00 
  80b255:	8b 47 04             	mov    0x4(%edi),%eax
  80b258:	89 04 24             	mov    %eax,(%esp)
  80b25b:	e8 01 4e 00 00       	call   810061 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b260:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b267:	10 
  80b268:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b26f:	e8 40 47 00 00       	call   80f9b4 <sys_page_unmap>

    return ERR_OK;
}
  80b274:	b0 00                	mov    $0x0,%al
  80b276:	83 c4 2c             	add    $0x2c,%esp
  80b279:	5b                   	pop    %ebx
  80b27a:	5e                   	pop    %esi
  80b27b:	5f                   	pop    %edi
  80b27c:	5d                   	pop    %ebp
  80b27d:	c3                   	ret    

0080b27e <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b27e:	55                   	push   %ebp
  80b27f:	89 e5                	mov    %esp,%ebp
  80b281:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b284:	8b 45 10             	mov    0x10(%ebp),%eax
  80b287:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b28b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b28e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b292:	8b 45 08             	mov    0x8(%ebp),%eax
  80b295:	89 04 24             	mov    %eax,(%esp)
  80b298:	e8 8d ef ff ff       	call   80a22a <etharp_output>
}
  80b29d:	c9                   	leave  
  80b29e:	c3                   	ret    

0080b29f <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b29f:	55                   	push   %ebp
  80b2a0:	89 e5                	mov    %esp,%ebp
  80b2a2:	57                   	push   %edi
  80b2a3:	56                   	push   %esi
  80b2a4:	53                   	push   %ebx
  80b2a5:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b2a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80b2ab:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b2ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80b2b1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b2b4:	8b 32                	mov    (%edx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b2b6:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b2bd:	00 
  80b2be:	0f b7 c6             	movzwl %si,%eax
  80b2c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2c5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b2cc:	e8 a5 9c ff ff       	call   804f76 <pbuf_alloc>
  80b2d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (p == 0)
  80b2d4:	85 c0                	test   %eax,%eax
  80b2d6:	0f 84 c3 00 00 00    	je     80b39f <jif_input+0x100>
  80b2dc:	89 c3                	mov    %eax,%ebx
  80b2de:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80b2e3:	0f bf f6             	movswl %si,%esi
  80b2e6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b2e9:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
	if (bytes > (len - copied))
  80b2ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b2f0:	29 f8                	sub    %edi,%eax
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b2f2:	89 c6                	mov    %eax,%esi
  80b2f4:	39 d0                	cmp    %edx,%eax
  80b2f6:	7e 02                	jle    80b2fa <jif_input+0x5b>
  80b2f8:	89 d6                	mov    %edx,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b2fa:	89 74 24 08          	mov    %esi,0x8(%esp)
  80b2fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b301:	8d 44 3a 04          	lea    0x4(%edx,%edi,1),%eax
  80b305:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b309:	8b 43 04             	mov    0x4(%ebx),%eax
  80b30c:	89 04 24             	mov    %eax,(%esp)
  80b30f:	e8 ea 43 00 00       	call   80f6fe <memcpy>
	copied += bytes;
  80b314:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b316:	8b 1b                	mov    (%ebx),%ebx
  80b318:	85 db                	test   %ebx,%ebx
  80b31a:	75 cd                	jne    80b2e9 <jif_input+0x4a>
  80b31c:	eb 61                	jmp    80b37f <jif_input+0xe0>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b31e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b321:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b325:	8b 55 08             	mov    0x8(%ebp),%edx
  80b328:	89 14 24             	mov    %edx,(%esp)
  80b32b:	e8 3b e9 ff ff       	call   809c6b <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b330:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b337:	ff 
  80b338:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b33b:	89 04 24             	mov    %eax,(%esp)
  80b33e:	e8 4d 99 ff ff       	call   804c90 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b343:	8b 55 08             	mov    0x8(%ebp),%edx
  80b346:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b34a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b34d:	89 04 24             	mov    %eax,(%esp)
  80b350:	ff 52 10             	call   *0x10(%edx)
	break;
  80b353:	eb 4a                	jmp    80b39f <jif_input+0x100>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b355:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b35c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b35f:	8b 02                	mov    (%edx),%eax
  80b361:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b365:	8b 45 08             	mov    0x8(%ebp),%eax
  80b368:	89 04 24             	mov    %eax,(%esp)
  80b36b:	e8 49 e9 ff ff       	call   809cb9 <etharp_arp_input>
	break;
  80b370:	eb 2d                	jmp    80b39f <jif_input+0x100>

    default:
	pbuf_free(p);
  80b372:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b375:	89 04 24             	mov    %eax,(%esp)
  80b378:	e8 f8 99 ff ff       	call   804d75 <pbuf_free>
  80b37d:	eb 20                	jmp    80b39f <jif_input+0x100>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b37f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b382:	8b 42 04             	mov    0x4(%edx),%eax
  80b385:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b389:	89 04 24             	mov    %eax,(%esp)
  80b38c:	e8 ec c8 ff ff       	call   807c7d <htons>
  80b391:	66 3d 00 08          	cmp    $0x800,%ax
  80b395:	74 87                	je     80b31e <jif_input+0x7f>
  80b397:	66 3d 06 08          	cmp    $0x806,%ax
  80b39b:	75 d5                	jne    80b372 <jif_input+0xd3>
  80b39d:	eb b6                	jmp    80b355 <jif_input+0xb6>
	break;

    default:
	pbuf_free(p);
    }
}
  80b39f:	83 c4 2c             	add    $0x2c,%esp
  80b3a2:	5b                   	pop    %ebx
  80b3a3:	5e                   	pop    %esi
  80b3a4:	5f                   	pop    %edi
  80b3a5:	5d                   	pop    %ebp
  80b3a6:	c3                   	ret    

0080b3a7 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b3a7:	55                   	push   %ebp
  80b3a8:	89 e5                	mov    %esp,%ebp
  80b3aa:	57                   	push   %edi
  80b3ab:	56                   	push   %esi
  80b3ac:	53                   	push   %ebx
  80b3ad:	83 ec 2c             	sub    $0x2c,%esp
  80b3b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b3b3:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b3ba:	e8 7d 93 ff ff       	call   80473c <mem_malloc>
  80b3bf:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b3c1:	85 c0                	test   %eax,%eax
  80b3c3:	74 79                	je     80b43e <jif_init+0x97>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b3c5:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b3c8:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80b3cb:	c7 43 14 7e b2 80 00 	movl   $0x80b27e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b3d2:	c7 43 18 84 b1 80 00 	movl   $0x80b184,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b3d9:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b3e0:	00 
  80b3e1:	c7 44 24 04 45 34 81 	movl   $0x813445,0x4(%esp)
  80b3e8:	00 
  80b3e9:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b3ec:	89 04 24             	mov    %eax,(%esp)
  80b3ef:	e8 0a 43 00 00       	call   80f6fe <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b3f4:	8d 43 25             	lea    0x25(%ebx),%eax
  80b3f7:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b3f9:	8b 17                	mov    (%edi),%edx
  80b3fb:	89 56 04             	mov    %edx,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b3fe:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b402:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b408:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    //netif->hwaddr[1] = 0x54;
    //netif->hwaddr[2] = 0x00;
    //netif->hwaddr[3] = 0x12;
    //netif->hwaddr[4] = 0x34;
    //netif->hwaddr[5] = 0x56;
	sys_e1000_get_mac(netif->hwaddr);
  80b40c:	89 04 24             	mov    %eax,(%esp)
  80b40f:	e8 c2 47 00 00       	call   80fbd6 <sys_e1000_get_mac>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b414:	c7 04 24 eb 0a 81 00 	movl   $0x810aeb,(%esp)
  80b41b:	e8 ab ca ff ff       	call   807ecb <inet_addr>
  80b420:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b423:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b42a:	00 
  80b42b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b42e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b432:	89 1c 24             	mov    %ebx,(%esp)
  80b435:	e8 95 eb ff ff       	call   809fcf <etharp_query>

    return ERR_OK;
  80b43a:	b0 00                	mov    $0x0,%al
  80b43c:	eb 02                	jmp    80b440 <jif_init+0x99>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80b43e:	b0 ff                	mov    $0xff,%al
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80b440:	83 c4 2c             	add    $0x2c,%esp
  80b443:	5b                   	pop    %ebx
  80b444:	5e                   	pop    %esi
  80b445:	5f                   	pop    %edi
  80b446:	5d                   	pop    %ebp
  80b447:	c3                   	ret    

0080b448 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80b448:	55                   	push   %ebp
  80b449:	89 e5                	mov    %esp,%ebp
  80b44b:	53                   	push   %ebx
  80b44c:	83 ec 44             	sub    $0x44,%esp
  80b44f:	8a 45 0c             	mov    0xc(%ebp),%al
  80b452:	88 45 d7             	mov    %al,-0x29(%ebp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80b455:	8b 45 10             	mov    0x10(%ebp),%eax
  80b458:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b45c:	8b 45 08             	mov    0x8(%ebp),%eax
  80b45f:	89 04 24             	mov    %eax,(%esp)
  80b462:	e8 05 10 00 00       	call   80c46c <netconn_alloc>
  80b467:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80b469:	85 c0                	test   %eax,%eax
  80b46b:	0f 84 d7 00 00 00    	je     80b548 <netconn_new_with_proto_and_callback+0x100>
    msg.function = do_newconn;
  80b471:	c7 45 e4 6d c3 80 00 	movl   $0x80c36d,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80b478:	8a 45 d7             	mov    -0x29(%ebp),%al
  80b47b:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80b47e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80b481:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b484:	89 04 24             	mov    %eax,(%esp)
  80b487:	e8 5e 72 ff ff       	call   8026ea <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80b48c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b490:	0f 84 b2 00 00 00    	je     80b548 <netconn_new_with_proto_and_callback+0x100>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80b496:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b49a:	74 1c                	je     80b4b8 <netconn_new_with_proto_and_callback+0x70>
  80b49c:	c7 44 24 08 d8 27 81 	movl   $0x8127d8,0x8(%esp)
  80b4a3:	00 
  80b4a4:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80b4ab:	00 
  80b4ac:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b4b3:	e8 c0 39 00 00       	call   80ee78 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80b4b8:	8b 43 10             	mov    0x10(%ebx),%eax
  80b4bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b4be:	75 1c                	jne    80b4dc <netconn_new_with_proto_and_callback+0x94>
  80b4c0:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80b4c7:	00 
  80b4c8:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80b4cf:	00 
  80b4d0:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b4d7:	e8 9c 39 00 00       	call   80ee78 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80b4dc:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4e0:	75 1c                	jne    80b4fe <netconn_new_with_proto_and_callback+0xb6>
  80b4e2:	c7 44 24 08 ba 28 81 	movl   $0x8128ba,0x8(%esp)
  80b4e9:	00 
  80b4ea:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b4f1:	00 
  80b4f2:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b4f9:	e8 7a 39 00 00       	call   80ee78 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80b4fe:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b502:	74 1c                	je     80b520 <netconn_new_with_proto_and_callback+0xd8>
  80b504:	c7 44 24 08 fc 27 81 	movl   $0x8127fc,0x8(%esp)
  80b50b:	00 
  80b50c:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b513:	00 
  80b514:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b51b:	e8 58 39 00 00       	call   80ee78 <_panic>
      sys_sem_free(conn->op_completed);
  80b520:	89 04 24             	mov    %eax,(%esp)
  80b523:	e8 4b f0 ff ff       	call   80a573 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80b528:	8b 43 14             	mov    0x14(%ebx),%eax
  80b52b:	89 04 24             	mov    %eax,(%esp)
  80b52e:	e8 b4 f0 ff ff       	call   80a5e7 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80b533:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b537:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80b53e:	e8 a7 94 ff ff       	call   8049ea <memp_free>
      return NULL;
  80b543:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
  }
  return conn;
}
  80b548:	89 d8                	mov    %ebx,%eax
  80b54a:	83 c4 44             	add    $0x44,%esp
  80b54d:	5b                   	pop    %ebx
  80b54e:	5d                   	pop    %ebp
  80b54f:	c3                   	ret    

0080b550 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80b550:	55                   	push   %ebp
  80b551:	89 e5                	mov    %esp,%ebp
  80b553:	53                   	push   %ebx
  80b554:	83 ec 34             	sub    $0x34,%esp
  80b557:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b55a:	85 db                	test   %ebx,%ebx
  80b55c:	74 24                	je     80b582 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b55e:	c7 45 e4 b7 c6 80 00 	movl   $0x80c6b7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b565:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b568:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b56b:	89 04 24             	mov    %eax,(%esp)
  80b56e:	e8 77 71 ff ff       	call   8026ea <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b573:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b57a:	89 1c 24             	mov    %ebx,(%esp)
  80b57d:	e8 a1 0f 00 00       	call   80c523 <netconn_free>

  return ERR_OK;
}
  80b582:	b0 00                	mov    $0x0,%al
  80b584:	83 c4 34             	add    $0x34,%esp
  80b587:	5b                   	pop    %ebx
  80b588:	5d                   	pop    %ebp
  80b589:	c3                   	ret    

0080b58a <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b58a:	55                   	push   %ebp
  80b58b:	89 e5                	mov    %esp,%ebp
  80b58d:	83 ec 18             	sub    $0x18,%esp
  80b590:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b593:	85 c0                	test   %eax,%eax
  80b595:	75 1c                	jne    80b5b3 <netconn_type+0x29>
  80b597:	c7 44 24 08 cf 28 81 	movl   $0x8128cf,0x8(%esp)
  80b59e:	00 
  80b59f:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b5a6:	00 
  80b5a7:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b5ae:	e8 c5 38 00 00       	call   80ee78 <_panic>
  80b5b3:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b5b5:	c9                   	leave  
  80b5b6:	c3                   	ret    

0080b5b7 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b5b7:	55                   	push   %ebp
  80b5b8:	89 e5                	mov    %esp,%ebp
  80b5ba:	53                   	push   %ebx
  80b5bb:	83 ec 34             	sub    $0x34,%esp
  80b5be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b5c1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b5c4:	8b 45 10             	mov    0x10(%ebp),%eax
  80b5c7:	8a 4d 14             	mov    0x14(%ebp),%cl
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b5ca:	85 db                	test   %ebx,%ebx
  80b5cc:	75 1c                	jne    80b5ea <netconn_getaddr+0x33>
  80b5ce:	c7 44 24 08 ea 28 81 	movl   $0x8128ea,0x8(%esp)
  80b5d5:	00 
  80b5d6:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b5dd:	00 
  80b5de:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b5e5:	e8 8e 38 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b5ea:	85 d2                	test   %edx,%edx
  80b5ec:	75 1c                	jne    80b60a <netconn_getaddr+0x53>
  80b5ee:	c7 44 24 08 08 29 81 	movl   $0x812908,0x8(%esp)
  80b5f5:	00 
  80b5f6:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b5fd:	00 
  80b5fe:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b605:	e8 6e 38 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b60a:	85 c0                	test   %eax,%eax
  80b60c:	75 1c                	jne    80b62a <netconn_getaddr+0x73>
  80b60e:	c7 44 24 08 26 29 81 	movl   $0x812926,0x8(%esp)
  80b615:	00 
  80b616:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b61d:	00 
  80b61e:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b625:	e8 4e 38 00 00       	call   80ee78 <_panic>

  msg.function = do_getaddr;
  80b62a:	c7 45 e4 26 cb 80 00 	movl   $0x80cb26,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b631:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b634:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b637:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b63a:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b63d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b640:	89 04 24             	mov    %eax,(%esp)
  80b643:	e8 a2 70 ff ff       	call   8026ea <tcpip_apimsg>
  80b648:	8a 43 0c             	mov    0xc(%ebx),%al

  return conn->err;
}
  80b64b:	83 c4 34             	add    $0x34,%esp
  80b64e:	5b                   	pop    %ebx
  80b64f:	5d                   	pop    %ebp
  80b650:	c3                   	ret    

0080b651 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b651:	55                   	push   %ebp
  80b652:	89 e5                	mov    %esp,%ebp
  80b654:	53                   	push   %ebx
  80b655:	83 ec 34             	sub    $0x34,%esp
  80b658:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b65b:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b65e:	85 db                	test   %ebx,%ebx
  80b660:	75 1c                	jne    80b67e <netconn_bind+0x2d>
  80b662:	c7 44 24 08 44 29 81 	movl   $0x812944,0x8(%esp)
  80b669:	00 
  80b66a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b671:	00 
  80b672:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b679:	e8 fa 37 00 00       	call   80ee78 <_panic>

  msg.function = do_bind;
  80b67e:	c7 45 e4 67 c7 80 00 	movl   $0x80c767,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b685:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b688:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b68b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b68e:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b692:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b695:	89 04 24             	mov    %eax,(%esp)
  80b698:	e8 4d 70 ff ff       	call   8026ea <tcpip_apimsg>
  80b69d:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b6a0:	83 c4 34             	add    $0x34,%esp
  80b6a3:	5b                   	pop    %ebx
  80b6a4:	5d                   	pop    %ebp
  80b6a5:	c3                   	ret    

0080b6a6 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b6a6:	55                   	push   %ebp
  80b6a7:	89 e5                	mov    %esp,%ebp
  80b6a9:	53                   	push   %ebx
  80b6aa:	83 ec 34             	sub    $0x34,%esp
  80b6ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6b0:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b6b3:	85 db                	test   %ebx,%ebx
  80b6b5:	75 1c                	jne    80b6d3 <netconn_connect+0x2d>
  80b6b7:	c7 44 24 08 5f 29 81 	movl   $0x81295f,0x8(%esp)
  80b6be:	00 
  80b6bf:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b6c6:	00 
  80b6c7:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b6ce:	e8 a5 37 00 00       	call   80ee78 <_panic>

  msg.function = do_connect;
  80b6d3:	c7 45 e4 fd c7 80 00 	movl   $0x80c7fd,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b6da:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b6dd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b6e0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b6e3:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b6e7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b6ea:	89 04 24             	mov    %eax,(%esp)
  80b6ed:	e8 f8 6f ff ff       	call   8026ea <tcpip_apimsg>
  80b6f2:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b6f5:	83 c4 34             	add    $0x34,%esp
  80b6f8:	5b                   	pop    %ebx
  80b6f9:	5d                   	pop    %ebp
  80b6fa:	c3                   	ret    

0080b6fb <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b6fb:	55                   	push   %ebp
  80b6fc:	89 e5                	mov    %esp,%ebp
  80b6fe:	53                   	push   %ebx
  80b6ff:	83 ec 34             	sub    $0x34,%esp
  80b702:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b705:	85 db                	test   %ebx,%ebx
  80b707:	75 1c                	jne    80b725 <netconn_disconnect+0x2a>
  80b709:	c7 44 24 08 20 28 81 	movl   $0x812820,0x8(%esp)
  80b710:	00 
  80b711:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b718:	00 
  80b719:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b720:	e8 53 37 00 00       	call   80ee78 <_panic>

  msg.function = do_disconnect;
  80b725:	c7 45 e4 c3 c8 80 00 	movl   $0x80c8c3,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b72c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b72f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b732:	89 04 24             	mov    %eax,(%esp)
  80b735:	e8 b0 6f ff ff       	call   8026ea <tcpip_apimsg>
  80b73a:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b73d:	83 c4 34             	add    $0x34,%esp
  80b740:	5b                   	pop    %ebx
  80b741:	5d                   	pop    %ebp
  80b742:	c3                   	ret    

0080b743 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b743:	55                   	push   %ebp
  80b744:	89 e5                	mov    %esp,%ebp
  80b746:	53                   	push   %ebx
  80b747:	83 ec 34             	sub    $0x34,%esp
  80b74a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b74d:	85 db                	test   %ebx,%ebx
  80b74f:	75 1c                	jne    80b76d <netconn_listen_with_backlog+0x2a>
  80b751:	c7 44 24 08 7d 29 81 	movl   $0x81297d,0x8(%esp)
  80b758:	00 
  80b759:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b760:	00 
  80b761:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b768:	e8 0b 37 00 00       	call   80ee78 <_panic>

  msg.function = do_listen;
  80b76d:	c7 45 e4 fa c8 80 00 	movl   $0x80c8fa,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b774:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b777:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b77a:	89 04 24             	mov    %eax,(%esp)
  80b77d:	e8 68 6f ff ff       	call   8026ea <tcpip_apimsg>
  80b782:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80b785:	83 c4 34             	add    $0x34,%esp
  80b788:	5b                   	pop    %ebx
  80b789:	5d                   	pop    %ebp
  80b78a:	c3                   	ret    

0080b78b <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b78b:	55                   	push   %ebp
  80b78c:	89 e5                	mov    %esp,%ebp
  80b78e:	53                   	push   %ebx
  80b78f:	83 ec 24             	sub    $0x24,%esp
  80b792:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b795:	85 db                	test   %ebx,%ebx
  80b797:	75 1c                	jne    80b7b5 <netconn_accept+0x2a>
  80b799:	c7 44 24 08 9a 29 81 	movl   $0x81299a,0x8(%esp)
  80b7a0:	00 
  80b7a1:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b7a8:	00 
  80b7a9:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b7b0:	e8 c3 36 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b7b5:	8b 43 18             	mov    0x18(%ebx),%eax
  80b7b8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b7bb:	75 1c                	jne    80b7d9 <netconn_accept+0x4e>
  80b7bd:	c7 44 24 08 44 28 81 	movl   $0x812844,0x8(%esp)
  80b7c4:	00 
  80b7c5:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b7cc:	00 
  80b7cd:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b7d4:	e8 9f 36 00 00       	call   80ee78 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b7d9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b7e0:	00 
  80b7e1:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b7e4:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b7e8:	89 04 24             	mov    %eax,(%esp)
  80b7eb:	e8 a1 f2 ff ff       	call   80aa91 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b7f0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7f3:	85 c0                	test   %eax,%eax
  80b7f5:	74 15                	je     80b80c <netconn_accept+0x81>
  80b7f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b7fe:	00 
  80b7ff:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b806:	00 
  80b807:	89 1c 24             	mov    %ebx,(%esp)
  80b80a:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b80c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b80f:	83 c4 24             	add    $0x24,%esp
  80b812:	5b                   	pop    %ebx
  80b813:	5d                   	pop    %ebp
  80b814:	c3                   	ret    

0080b815 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b815:	55                   	push   %ebp
  80b816:	89 e5                	mov    %esp,%ebp
  80b818:	53                   	push   %ebx
  80b819:	83 ec 34             	sub    $0x34,%esp
  80b81c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b81f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b826:	85 db                	test   %ebx,%ebx
  80b828:	75 1c                	jne    80b846 <netconn_recv+0x31>
  80b82a:	c7 44 24 08 b7 29 81 	movl   $0x8129b7,0x8(%esp)
  80b831:	00 
  80b832:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80b839:	00 
  80b83a:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b841:	e8 32 36 00 00       	call   80ee78 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b846:	8b 43 14             	mov    0x14(%ebx),%eax
  80b849:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b84c:	75 0e                	jne    80b85c <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80b84e:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b852:	b8 00 00 00 00       	mov    $0x0,%eax
  80b857:	e9 5c 01 00 00       	jmp    80b9b8 <netconn_recv+0x1a3>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b85c:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b860:	0f 8c 46 01 00 00    	jl     80b9ac <netconn_recv+0x197>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b866:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b869:	0f 85 f3 00 00 00    	jne    80b962 <netconn_recv+0x14d>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b86f:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b873:	75 0e                	jne    80b883 <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80b875:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b879:	b8 00 00 00 00       	mov    $0x0,%eax
  80b87e:	e9 35 01 00 00       	jmp    80b9b8 <netconn_recv+0x1a3>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b883:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b88a:	e8 fb 90 ff ff       	call   80498a <memp_malloc>
  80b88f:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b892:	85 c0                	test   %eax,%eax
  80b894:	75 09                	jne    80b89f <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80b896:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b89a:	e9 19 01 00 00       	jmp    80b9b8 <netconn_recv+0x1a3>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b89f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b8a6:	00 
  80b8a7:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b8aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8ae:	8b 43 14             	mov    0x14(%ebx),%eax
  80b8b1:	89 04 24             	mov    %eax,(%esp)
  80b8b4:	e8 d8 f1 ff ff       	call   80aa91 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b8b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b8bc:	85 c0                	test   %eax,%eax
  80b8be:	74 09                	je     80b8c9 <netconn_recv+0xb4>
      len = p->tot_len;
  80b8c0:	8b 50 08             	mov    0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b8c3:	66 29 53 20          	sub    %dx,0x20(%ebx)
  80b8c7:	eb 05                	jmp    80b8ce <netconn_recv+0xb9>
    } else {
      len = 0;
  80b8c9:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b8ce:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8d1:	85 c0                	test   %eax,%eax
  80b8d3:	74 14                	je     80b8e9 <netconn_recv+0xd4>
  80b8d5:	0f b7 d2             	movzwl %dx,%edx
  80b8d8:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b8dc:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b8e3:	00 
  80b8e4:	89 1c 24             	mov    %ebx,(%esp)
  80b8e7:	ff d0                	call   *%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b8e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b8ec:	85 c0                	test   %eax,%eax
  80b8ee:	75 2b                	jne    80b91b <netconn_recv+0x106>
      memp_free(MEMP_NETBUF, buf);
  80b8f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b8f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8f7:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b8fe:	e8 e7 90 ff ff       	call   8049ea <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80b903:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b907:	0f 85 a6 00 00 00    	jne    80b9b3 <netconn_recv+0x19e>
        conn->err = ERR_CLSD;
  80b90d:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
      }
      return NULL;
  80b911:	b8 00 00 00 00       	mov    $0x0,%eax
  80b916:	e9 9d 00 00 00       	jmp    80b9b8 <netconn_recv+0x1a3>
    }

    buf->p = p;
  80b91b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b91e:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b920:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b923:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b926:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80b929:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80b92f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b936:	c7 45 e4 98 ca 80 00 	movl   $0x80ca98,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b93d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80b940:	85 c0                	test   %eax,%eax
  80b942:	74 0b                	je     80b94f <netconn_recv+0x13a>
      msg.msg.msg.r.len = buf->p->tot_len;
  80b944:	8b 00                	mov    (%eax),%eax
  80b946:	8b 40 08             	mov    0x8(%eax),%eax
  80b949:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80b94d:	eb 06                	jmp    80b955 <netconn_recv+0x140>
    } else {
      msg.msg.msg.r.len = 1;
  80b94f:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80b955:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b958:	89 04 24             	mov    %eax,(%esp)
  80b95b:	e8 8a 6d ff ff       	call   8026ea <tcpip_apimsg>
  80b960:	eb 45                	jmp    80b9a7 <netconn_recv+0x192>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b962:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b969:	00 
  80b96a:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b96d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b971:	89 04 24             	mov    %eax,(%esp)
  80b974:	e8 18 f1 ff ff       	call   80aa91 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80b979:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b97c:	85 c0                	test   %eax,%eax
  80b97e:	74 27                	je     80b9a7 <netconn_recv+0x192>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b980:	8b 10                	mov    (%eax),%edx
  80b982:	8b 52 08             	mov    0x8(%edx),%edx
  80b985:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b989:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b98c:	85 d2                	test   %edx,%edx
  80b98e:	74 17                	je     80b9a7 <netconn_recv+0x192>
  80b990:	8b 00                	mov    (%eax),%eax
  80b992:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b996:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b99a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b9a1:	00 
  80b9a2:	89 1c 24             	mov    %ebx,(%esp)
  80b9a5:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b9a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b9aa:	eb 0c                	jmp    80b9b8 <netconn_recv+0x1a3>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80b9ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9b1:	eb 05                	jmp    80b9b8 <netconn_recv+0x1a3>
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  80b9b3:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80b9b8:	83 c4 34             	add    $0x34,%esp
  80b9bb:	5b                   	pop    %ebx
  80b9bc:	5d                   	pop    %ebp
  80b9bd:	c3                   	ret    

0080b9be <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b9be:	55                   	push   %ebp
  80b9bf:	89 e5                	mov    %esp,%ebp
  80b9c1:	53                   	push   %ebx
  80b9c2:	83 ec 34             	sub    $0x34,%esp
  80b9c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b9c8:	85 db                	test   %ebx,%ebx
  80b9ca:	75 1c                	jne    80b9e8 <netconn_send+0x2a>
  80b9cc:	c7 44 24 08 d2 29 81 	movl   $0x8129d2,0x8(%esp)
  80b9d3:	00 
  80b9d4:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80b9db:	00 
  80b9dc:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80b9e3:	e8 90 34 00 00       	call   80ee78 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b9e8:	c7 45 e4 e0 c9 80 00 	movl   $0x80c9e0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b9ef:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b9f2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b9f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b9f8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b9fb:	89 04 24             	mov    %eax,(%esp)
  80b9fe:	e8 e7 6c ff ff       	call   8026ea <tcpip_apimsg>
  80ba03:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80ba06:	83 c4 34             	add    $0x34,%esp
  80ba09:	5b                   	pop    %ebx
  80ba0a:	5d                   	pop    %ebp
  80ba0b:	c3                   	ret    

0080ba0c <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80ba0c:	55                   	push   %ebp
  80ba0d:	89 e5                	mov    %esp,%ebp
  80ba0f:	83 ec 18             	sub    $0x18,%esp
  80ba12:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ba15:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80ba18:	85 c0                	test   %eax,%eax
  80ba1a:	74 1b                	je     80ba37 <netconn_sendto+0x2b>
    buf->addr = addr;
  80ba1c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80ba1f:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80ba22:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80ba26:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba2a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba2d:	89 04 24             	mov    %eax,(%esp)
  80ba30:	e8 89 ff ff ff       	call   80b9be <netconn_send>
  80ba35:	eb 02                	jmp    80ba39 <netconn_sendto+0x2d>
  }
  return ERR_VAL;
  80ba37:	b0 f7                	mov    $0xf7,%al
}
  80ba39:	c9                   	leave  
  80ba3a:	c3                   	ret    

0080ba3b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80ba3b:	55                   	push   %ebp
  80ba3c:	89 e5                	mov    %esp,%ebp
  80ba3e:	53                   	push   %ebx
  80ba3f:	83 ec 34             	sub    $0x34,%esp
  80ba42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ba45:	8a 45 14             	mov    0x14(%ebp),%al
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80ba48:	85 db                	test   %ebx,%ebx
  80ba4a:	75 1c                	jne    80ba68 <netconn_write+0x2d>
  80ba4c:	c7 44 24 08 ed 29 81 	movl   $0x8129ed,0x8(%esp)
  80ba53:	00 
  80ba54:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80ba5b:	00 
  80ba5c:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80ba63:	e8 10 34 00 00       	call   80ee78 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80ba68:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ba6b:	74 1c                	je     80ba89 <netconn_write+0x4e>
  80ba6d:	c7 44 24 08 68 28 81 	movl   $0x812868,0x8(%esp)
  80ba74:	00 
  80ba75:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80ba7c:	00 
  80ba7d:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80ba84:	e8 ef 33 00 00       	call   80ee78 <_panic>

  msg.function = do_write;
  80ba89:	c7 45 e4 d9 ca 80 00 	movl   $0x80cad9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ba90:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80ba93:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ba96:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80ba99:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80ba9c:	8b 45 10             	mov    0x10(%ebp),%eax
  80ba9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80baa2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80baa5:	89 04 24             	mov    %eax,(%esp)
  80baa8:	e8 3d 6c ff ff       	call   8026ea <tcpip_apimsg>
  80baad:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80bab0:	83 c4 34             	add    $0x34,%esp
  80bab3:	5b                   	pop    %ebx
  80bab4:	5d                   	pop    %ebp
  80bab5:	c3                   	ret    

0080bab6 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80bab6:	55                   	push   %ebp
  80bab7:	89 e5                	mov    %esp,%ebp
  80bab9:	53                   	push   %ebx
  80baba:	83 ec 34             	sub    $0x34,%esp
  80babd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bac0:	85 db                	test   %ebx,%ebx
  80bac2:	75 1c                	jne    80bae0 <netconn_close+0x2a>
  80bac4:	c7 44 24 08 09 2a 81 	movl   $0x812a09,0x8(%esp)
  80bacb:	00 
  80bacc:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80bad3:	00 
  80bad4:	c7 04 24 8a 28 81 00 	movl   $0x81288a,(%esp)
  80badb:	e8 98 33 00 00       	call   80ee78 <_panic>

  msg.function = do_close;
  80bae0:	c7 45 e4 e5 cb 80 00 	movl   $0x80cbe5,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bae7:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80baea:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80baed:	89 04 24             	mov    %eax,(%esp)
  80baf0:	e8 f5 6b ff ff       	call   8026ea <tcpip_apimsg>
  80baf5:	8a 43 0c             	mov    0xc(%ebx),%al
  return conn->err;
}
  80baf8:	83 c4 34             	add    $0x34,%esp
  80bafb:	5b                   	pop    %ebx
  80bafc:	5d                   	pop    %ebp
  80bafd:	c3                   	ret    
	...

0080bb00 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80bb00:	55                   	push   %ebp
  80bb01:	89 e5                	mov    %esp,%ebp
  80bb03:	53                   	push   %ebx
  80bb04:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bb07:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bb0a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb0e:	89 1c 24             	mov    %ebx,(%esp)
  80bb11:	e8 98 a2 ff ff       	call   805dae <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bb16:	c7 44 24 04 c9 c0 80 	movl   $0x80c0c9,0x4(%esp)
  80bb1d:	00 
  80bb1e:	89 1c 24             	mov    %ebx,(%esp)
  80bb21:	e8 96 a2 ff ff       	call   805dbc <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bb26:	c7 44 24 04 29 c0 80 	movl   $0x80c029,0x4(%esp)
  80bb2d:	00 
  80bb2e:	89 1c 24             	mov    %ebx,(%esp)
  80bb31:	e8 97 a2 ff ff       	call   805dcd <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bb36:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bb3d:	00 
  80bb3e:	c7 44 24 04 e3 bf 80 	movl   $0x80bfe3,0x4(%esp)
  80bb45:	00 
  80bb46:	89 1c 24             	mov    %ebx,(%esp)
  80bb49:	e8 af a2 ff ff       	call   805dfd <tcp_poll>
  tcp_err(pcb, err_tcp);
  80bb4e:	c7 44 24 04 a2 bd 80 	movl   $0x80bda2,0x4(%esp)
  80bb55:	00 
  80bb56:	89 1c 24             	mov    %ebx,(%esp)
  80bb59:	e8 80 a2 ff ff       	call   805dde <tcp_err>
}
  80bb5e:	83 c4 14             	add    $0x14,%esp
  80bb61:	5b                   	pop    %ebx
  80bb62:	5d                   	pop    %ebp
  80bb63:	c3                   	ret    

0080bb64 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80bb64:	55                   	push   %ebp
  80bb65:	89 e5                	mov    %esp,%ebp
  80bb67:	53                   	push   %ebx
  80bb68:	83 ec 14             	sub    $0x14,%esp
  80bb6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb6e:	8a 45 10             	mov    0x10(%ebp),%al

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80bb71:	85 db                	test   %ebx,%ebx
  80bb73:	74 29                	je     80bb9e <do_connected+0x3a>
    return ERR_VAL;
  }

  conn->err = err;
  80bb75:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80bb78:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bb7b:	75 0b                	jne    80bb88 <do_connected+0x24>
  80bb7d:	84 c0                	test   %al,%al
  80bb7f:	75 07                	jne    80bb88 <do_connected+0x24>
    setup_tcp(conn);
  80bb81:	89 d8                	mov    %ebx,%eax
  80bb83:	e8 78 ff ff ff       	call   80bb00 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80bb88:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80bb8f:	8b 43 10             	mov    0x10(%ebx),%eax
  80bb92:	89 04 24             	mov    %eax,(%esp)
  80bb95:	e8 4b ec ff ff       	call   80a7e5 <sys_sem_signal>
  return ERR_OK;
  80bb9a:	b0 00                	mov    $0x0,%al
  80bb9c:	eb 02                	jmp    80bba0 <do_connected+0x3c>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80bb9e:	b0 f7                	mov    $0xf7,%al
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80bba0:	83 c4 14             	add    $0x14,%esp
  80bba3:	5b                   	pop    %ebx
  80bba4:	5d                   	pop    %ebp
  80bba5:	c3                   	ret    

0080bba6 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80bba6:	55                   	push   %ebp
  80bba7:	89 e5                	mov    %esp,%ebp
  80bba9:	53                   	push   %ebx
  80bbaa:	83 ec 14             	sub    $0x14,%esp
  80bbad:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bbaf:	85 c0                	test   %eax,%eax
  80bbb1:	75 1c                	jne    80bbcf <do_close_internal+0x29>
  80bbb3:	c7 44 24 08 e0 29 81 	movl   $0x8129e0,0x8(%esp)
  80bbba:	00 
  80bbbb:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80bbc2:	00 
  80bbc3:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bbca:	e8 a9 32 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bbcf:	83 38 10             	cmpl   $0x10,(%eax)
  80bbd2:	74 1c                	je     80bbf0 <do_close_internal+0x4a>
  80bbd4:	c7 44 24 08 3c 2a 81 	movl   $0x812a3c,0x8(%esp)
  80bbdb:	00 
  80bbdc:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80bbe3:	00 
  80bbe4:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bbeb:	e8 88 32 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bbf0:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80bbf4:	74 1c                	je     80bc12 <do_close_internal+0x6c>
  80bbf6:	c7 44 24 08 08 2b 81 	movl   $0x812b08,0x8(%esp)
  80bbfd:	00 
  80bbfe:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80bc05:	00 
  80bc06:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bc0d:	e8 66 32 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bc12:	8b 40 08             	mov    0x8(%eax),%eax
  80bc15:	85 c0                	test   %eax,%eax
  80bc17:	75 1c                	jne    80bc35 <do_close_internal+0x8f>
  80bc19:	c7 44 24 08 5a 2a 81 	movl   $0x812a5a,0x8(%esp)
  80bc20:	00 
  80bc21:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80bc28:	00 
  80bc29:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bc30:	e8 43 32 00 00       	call   80ee78 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80bc35:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc3c:	00 
  80bc3d:	89 04 24             	mov    %eax,(%esp)
  80bc40:	e8 69 a1 ff ff       	call   805dae <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80bc45:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc48:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bc4c:	75 12                	jne    80bc60 <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc4e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc55:	00 
  80bc56:	89 04 24             	mov    %eax,(%esp)
  80bc59:	e8 91 a1 ff ff       	call   805def <tcp_accept>
  80bc5e:	eb 64                	jmp    80bcc4 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80bc60:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc67:	00 
  80bc68:	89 04 24             	mov    %eax,(%esp)
  80bc6b:	e8 4c a1 ff ff       	call   805dbc <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc70:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc77:	00 
  80bc78:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc7b:	89 04 24             	mov    %eax,(%esp)
  80bc7e:	e8 6c a1 ff ff       	call   805def <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80bc83:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc8a:	00 
  80bc8b:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc8e:	89 04 24             	mov    %eax,(%esp)
  80bc91:	e8 37 a1 ff ff       	call   805dcd <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80bc96:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bc9d:	00 
  80bc9e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bca5:	00 
  80bca6:	8b 43 08             	mov    0x8(%ebx),%eax
  80bca9:	89 04 24             	mov    %eax,(%esp)
  80bcac:	e8 4c a1 ff ff       	call   805dfd <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80bcb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bcb8:	00 
  80bcb9:	8b 43 08             	mov    0x8(%ebx),%eax
  80bcbc:	89 04 24             	mov    %eax,(%esp)
  80bcbf:	e8 1a a1 ff ff       	call   805dde <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80bcc4:	8b 43 08             	mov    0x8(%ebx),%eax
  80bcc7:	89 04 24             	mov    %eax,(%esp)
  80bcca:	e8 25 a8 ff ff       	call   8064f4 <tcp_close>
  if (err == ERR_OK) {
  80bccf:	84 c0                	test   %al,%al
  80bcd1:	75 57                	jne    80bd2a <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80bcd3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80bcda:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bce1:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bce5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bce8:	85 c0                	test   %eax,%eax
  80bcea:	74 31                	je     80bd1d <do_close_internal+0x177>
  80bcec:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bcf3:	00 
  80bcf4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bcfb:	00 
  80bcfc:	89 1c 24             	mov    %ebx,(%esp)
  80bcff:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bd01:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bd04:	85 c0                	test   %eax,%eax
  80bd06:	74 15                	je     80bd1d <do_close_internal+0x177>
  80bd08:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd0f:	00 
  80bd10:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80bd17:	00 
  80bd18:	89 1c 24             	mov    %ebx,(%esp)
  80bd1b:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80bd1d:	8b 43 10             	mov    0x10(%ebx),%eax
  80bd20:	89 04 24             	mov    %eax,(%esp)
  80bd23:	e8 bd ea ff ff       	call   80a7e5 <sys_sem_signal>
  80bd28:	eb 72                	jmp    80bd9c <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bd2a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd2d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bd31:	75 1c                	jne    80bd4f <do_close_internal+0x1a9>
  80bd33:	c7 44 24 08 2c 2b 81 	movl   $0x812b2c,0x8(%esp)
  80bd3a:	00 
  80bd3b:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80bd42:	00 
  80bd43:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bd4a:	e8 29 31 00 00       	call   80ee78 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80bd4f:	c7 44 24 04 29 c0 80 	movl   $0x80c029,0x4(%esp)
  80bd56:	00 
  80bd57:	89 04 24             	mov    %eax,(%esp)
  80bd5a:	e8 6e a0 ff ff       	call   805dcd <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bd5f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bd66:	00 
  80bd67:	c7 44 24 04 e3 bf 80 	movl   $0x80bfe3,0x4(%esp)
  80bd6e:	00 
  80bd6f:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd72:	89 04 24             	mov    %eax,(%esp)
  80bd75:	e8 83 a0 ff ff       	call   805dfd <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80bd7a:	c7 44 24 04 a2 bd 80 	movl   $0x80bda2,0x4(%esp)
  80bd81:	00 
  80bd82:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd85:	89 04 24             	mov    %eax,(%esp)
  80bd88:	e8 51 a0 ff ff       	call   805dde <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80bd8d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bd91:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd94:	89 04 24             	mov    %eax,(%esp)
  80bd97:	e8 12 a0 ff ff       	call   805dae <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80bd9c:	83 c4 14             	add    $0x14,%esp
  80bd9f:	5b                   	pop    %ebx
  80bda0:	5d                   	pop    %ebp
  80bda1:	c3                   	ret    

0080bda2 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80bda2:	55                   	push   %ebp
  80bda3:	89 e5                	mov    %esp,%ebp
  80bda5:	53                   	push   %ebx
  80bda6:	83 ec 14             	sub    $0x14,%esp
  80bda9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bdac:	8a 45 0c             	mov    0xc(%ebp),%al
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bdaf:	85 db                	test   %ebx,%ebx
  80bdb1:	75 1c                	jne    80bdcf <err_tcp+0x2d>
  80bdb3:	c7 44 24 08 6d 2a 81 	movl   $0x812a6d,0x8(%esp)
  80bdba:	00 
  80bdbb:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80bdc2:	00 
  80bdc3:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bdca:	e8 a9 30 00 00       	call   80ee78 <_panic>

  conn->pcb.tcp = NULL;
  80bdcf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80bdd6:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bdd9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bddd:	74 2f                	je     80be0e <err_tcp+0x6c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bddf:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bde2:	85 c0                	test   %eax,%eax
  80bde4:	74 15                	je     80bdfb <err_tcp+0x59>
  80bde6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bded:	00 
  80bdee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bdf5:	00 
  80bdf6:	89 1c 24             	mov    %ebx,(%esp)
  80bdf9:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80bdfb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be02:	00 
  80be03:	8b 43 14             	mov    0x14(%ebx),%eax
  80be06:	89 04 24             	mov    %eax,(%esp)
  80be09:	e8 41 ec ff ff       	call   80aa4f <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80be0e:	8b 43 10             	mov    0x10(%ebx),%eax
  80be11:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be14:	74 15                	je     80be2b <err_tcp+0x89>
  80be16:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80be1a:	75 0f                	jne    80be2b <err_tcp+0x89>
    conn->state = NETCONN_NONE;
  80be1c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80be23:	89 04 24             	mov    %eax,(%esp)
  80be26:	e8 ba e9 ff ff       	call   80a7e5 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80be2b:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80be2f:	74 2f                	je     80be60 <err_tcp+0xbe>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80be31:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80be34:	85 c0                	test   %eax,%eax
  80be36:	74 15                	je     80be4d <err_tcp+0xab>
  80be38:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be3f:	00 
  80be40:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be47:	00 
  80be48:	89 1c 24             	mov    %ebx,(%esp)
  80be4b:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80be4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be54:	00 
  80be55:	8b 43 18             	mov    0x18(%ebx),%eax
  80be58:	89 04 24             	mov    %eax,(%esp)
  80be5b:	e8 ef eb ff ff       	call   80aa4f <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80be60:	8b 43 04             	mov    0x4(%ebx),%eax
  80be63:	83 f8 01             	cmp    $0x1,%eax
  80be66:	74 05                	je     80be6d <err_tcp+0xcb>
  80be68:	83 f8 04             	cmp    $0x4,%eax
  80be6b:	75 12                	jne    80be7f <err_tcp+0xdd>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80be6d:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80be74:	8b 43 10             	mov    0x10(%ebx),%eax
  80be77:	89 04 24             	mov    %eax,(%esp)
  80be7a:	e8 66 e9 ff ff       	call   80a7e5 <sys_sem_signal>
  }
}
  80be7f:	83 c4 14             	add    $0x14,%esp
  80be82:	5b                   	pop    %ebx
  80be83:	5d                   	pop    %ebp
  80be84:	c3                   	ret    

0080be85 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80be85:	55                   	push   %ebp
  80be86:	89 e5                	mov    %esp,%ebp
  80be88:	57                   	push   %edi
  80be89:	56                   	push   %esi
  80be8a:	53                   	push   %ebx
  80be8b:	83 ec 2c             	sub    $0x2c,%esp
  80be8e:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80be90:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80be94:	74 1c                	je     80beb2 <do_writemore+0x2d>
  80be96:	c7 44 24 08 7a 2a 81 	movl   $0x812a7a,0x8(%esp)
  80be9d:	00 
  80be9e:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80bea5:	00 
  80bea6:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bead:	e8 c6 2f 00 00       	call   80ee78 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80beb2:	8b 40 24             	mov    0x24(%eax),%eax
  80beb5:	8b 53 28             	mov    0x28(%ebx),%edx
  80beb8:	8b 48 04             	mov    0x4(%eax),%ecx
  80bebb:	01 d1                	add    %edx,%ecx
  80bebd:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80bec0:	8b 48 08             	mov    0x8(%eax),%ecx
  80bec3:	89 ce                	mov    %ecx,%esi
  80bec5:	29 d6                	sub    %edx,%esi
  80bec7:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80becd:	7f 05                	jg     80bed4 <do_writemore+0x4f>
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80becf:	66 29 d1             	sub    %dx,%cx
  80bed2:	eb 05                	jmp    80bed9 <do_writemore+0x54>

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
    len = 0xffff;
  80bed4:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80bed9:	8b 53 08             	mov    0x8(%ebx),%edx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80bedc:	66 8b 7a 6e          	mov    0x6e(%edx),%di
  80bee0:	89 ce                	mov    %ecx,%esi
  80bee2:	66 39 f9             	cmp    %di,%cx
  80bee5:	76 02                	jbe    80bee9 <do_writemore+0x64>
  80bee7:	89 fe                	mov    %edi,%esi
  80bee9:	0f b7 f6             	movzwl %si,%esi
  80beec:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80bef0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bef4:	89 74 24 08          	mov    %esi,0x8(%esp)
  80bef8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80befb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80beff:	89 14 24             	mov    %edx,(%esp)
  80bf02:	e8 a9 c6 ff ff       	call   8085b0 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80bf07:	89 f2                	mov    %esi,%edx
  80bf09:	03 53 28             	add    0x28(%ebx),%edx
  80bf0c:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80bf0f:	3b 51 08             	cmp    0x8(%ecx),%edx
  80bf12:	7e 1c                	jle    80bf30 <do_writemore+0xab>
  80bf14:	c7 44 24 08 97 2a 81 	movl   $0x812a97,0x8(%esp)
  80bf1b:	00 
  80bf1c:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80bf23:	00 
  80bf24:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80bf2b:	e8 48 2f 00 00       	call   80ee78 <_panic>
  if (err == ERR_OK) {
  80bf30:	84 c0                	test   %al,%al
  80bf32:	75 71                	jne    80bfa5 <do_writemore+0x120>
    conn->write_offset += len;
  80bf34:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80bf37:	3b 51 08             	cmp    0x8(%ecx),%edx
  80bf3a:	75 15                	jne    80bf51 <do_writemore+0xcc>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80bf3c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80bf43:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80bf4a:	bf 01 00 00 00       	mov    $0x1,%edi
  80bf4f:	eb 05                	jmp    80bf56 <do_writemore+0xd1>
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80bf51:	bf 00 00 00 00       	mov    $0x0,%edi
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80bf56:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf59:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80bf5d:	74 12                	je     80bf71 <do_writemore+0xec>
  80bf5f:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80bf63:	75 0c                	jne    80bf71 <do_writemore+0xec>
  80bf65:	8b 50 74             	mov    0x74(%eax),%edx
  80bf68:	85 d2                	test   %edx,%edx
  80bf6a:	74 71                	je     80bfdd <do_writemore+0x158>
  80bf6c:	83 3a 00             	cmpl   $0x0,(%edx)
  80bf6f:	74 6c                	je     80bfdd <do_writemore+0x158>
  80bf71:	89 04 24             	mov    %eax,(%esp)
  80bf74:	e8 e9 c6 ff ff       	call   808662 <tcp_output>
    conn->err = err;
  80bf79:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80bf7c:	84 c0                	test   %al,%al
  80bf7e:	75 3b                	jne    80bfbb <do_writemore+0x136>
  80bf80:	8b 43 08             	mov    0x8(%ebx),%eax
  80bf83:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bf89:	77 30                	ja     80bfbb <do_writemore+0x136>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80bf8b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bf8e:	85 c0                	test   %eax,%eax
  80bf90:	74 29                	je     80bfbb <do_writemore+0x136>
  80bf92:	89 74 24 08          	mov    %esi,0x8(%esp)
  80bf96:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80bf9d:	00 
  80bf9e:	89 1c 24             	mov    %ebx,(%esp)
  80bfa1:	ff d0                	call   *%eax
  80bfa3:	eb 16                	jmp    80bfbb <do_writemore+0x136>
    }
  } else if (err == ERR_MEM) {
  80bfa5:	3c ff                	cmp    $0xff,%al
  80bfa7:	75 0d                	jne    80bfb6 <do_writemore+0x131>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80bfa9:	8b 43 08             	mov    0x8(%ebx),%eax
  80bfac:	89 04 24             	mov    %eax,(%esp)
  80bfaf:	e8 ae c6 ff ff       	call   808662 <tcp_output>
  80bfb4:	eb 1d                	jmp    80bfd3 <do_writemore+0x14e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80bfb6:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfb9:	eb 06                	jmp    80bfc1 <do_writemore+0x13c>
    write_finished = 1;
  }

  if (write_finished) {
  80bfbb:	89 f9                	mov    %edi,%ecx
  80bfbd:	84 c9                	test   %cl,%cl
  80bfbf:	74 12                	je     80bfd3 <do_writemore+0x14e>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80bfc1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80bfc8:	8b 43 10             	mov    0x10(%ebx),%eax
  80bfcb:	89 04 24             	mov    %eax,(%esp)
  80bfce:	e8 12 e8 ff ff       	call   80a7e5 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80bfd3:	b0 00                	mov    $0x0,%al
  80bfd5:	83 c4 2c             	add    $0x2c,%esp
  80bfd8:	5b                   	pop    %ebx
  80bfd9:	5e                   	pop    %esi
  80bfda:	5f                   	pop    %edi
  80bfdb:	5d                   	pop    %ebp
  80bfdc:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80bfdd:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80bfe1:	eb 9d                	jmp    80bf80 <do_writemore+0xfb>

0080bfe3 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80bfe3:	55                   	push   %ebp
  80bfe4:	89 e5                	mov    %esp,%ebp
  80bfe6:	83 ec 18             	sub    $0x18,%esp
  80bfe9:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bfec:	85 c0                	test   %eax,%eax
  80bfee:	75 1c                	jne    80c00c <poll_tcp+0x29>
  80bff0:	c7 44 24 08 6d 2a 81 	movl   $0x812a6d,0x8(%esp)
  80bff7:	00 
  80bff8:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80bfff:	00 
  80c000:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c007:	e8 6c 2e 00 00       	call   80ee78 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c00c:	8b 50 04             	mov    0x4(%eax),%edx
  80c00f:	83 fa 01             	cmp    $0x1,%edx
  80c012:	75 07                	jne    80c01b <poll_tcp+0x38>
    do_writemore(conn);
  80c014:	e8 6c fe ff ff       	call   80be85 <do_writemore>
  80c019:	eb 0a                	jmp    80c025 <poll_tcp+0x42>
  } else if (conn->state == NETCONN_CLOSE) {
  80c01b:	83 fa 04             	cmp    $0x4,%edx
  80c01e:	75 05                	jne    80c025 <poll_tcp+0x42>
    do_close_internal(conn);
  80c020:	e8 81 fb ff ff       	call   80bba6 <do_close_internal>
  }

  return ERR_OK;
}
  80c025:	b0 00                	mov    $0x0,%al
  80c027:	c9                   	leave  
  80c028:	c3                   	ret    

0080c029 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c029:	55                   	push   %ebp
  80c02a:	89 e5                	mov    %esp,%ebp
  80c02c:	56                   	push   %esi
  80c02d:	53                   	push   %ebx
  80c02e:	83 ec 10             	sub    $0x10,%esp
  80c031:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c034:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c037:	85 db                	test   %ebx,%ebx
  80c039:	75 1c                	jne    80c057 <sent_tcp+0x2e>
  80c03b:	c7 44 24 08 6d 2a 81 	movl   $0x812a6d,0x8(%esp)
  80c042:	00 
  80c043:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c04a:	00 
  80c04b:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c052:	e8 21 2e 00 00       	call   80ee78 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c057:	8b 43 04             	mov    0x4(%ebx),%eax
  80c05a:	83 f8 01             	cmp    $0x1,%eax
  80c05d:	75 2b                	jne    80c08a <sent_tcp+0x61>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c05f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c063:	75 1c                	jne    80c081 <sent_tcp+0x58>
  80c065:	c7 44 24 08 b5 2a 81 	movl   $0x812ab5,0x8(%esp)
  80c06c:	00 
  80c06d:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c074:	00 
  80c075:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c07c:	e8 f7 2d 00 00       	call   80ee78 <_panic>
    do_writemore(conn);
  80c081:	89 d8                	mov    %ebx,%eax
  80c083:	e8 fd fd ff ff       	call   80be85 <do_writemore>
  80c088:	eb 0c                	jmp    80c096 <sent_tcp+0x6d>
  } else if (conn->state == NETCONN_CLOSE) {
  80c08a:	83 f8 04             	cmp    $0x4,%eax
  80c08d:	75 07                	jne    80c096 <sent_tcp+0x6d>
    do_close_internal(conn);
  80c08f:	89 d8                	mov    %ebx,%eax
  80c091:	e8 10 fb ff ff       	call   80bba6 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c096:	8b 43 08             	mov    0x8(%ebx),%eax
  80c099:	85 c0                	test   %eax,%eax
  80c09b:	74 23                	je     80c0c0 <sent_tcp+0x97>
  80c09d:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c0a3:	76 1b                	jbe    80c0c0 <sent_tcp+0x97>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c0a5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c0a8:	85 c0                	test   %eax,%eax
  80c0aa:	74 14                	je     80c0c0 <sent_tcp+0x97>
  80c0ac:	0f b7 f6             	movzwl %si,%esi
  80c0af:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c0b3:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c0ba:	00 
  80c0bb:	89 1c 24             	mov    %ebx,(%esp)
  80c0be:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80c0c0:	b0 00                	mov    $0x0,%al
  80c0c2:	83 c4 10             	add    $0x10,%esp
  80c0c5:	5b                   	pop    %ebx
  80c0c6:	5e                   	pop    %esi
  80c0c7:	5d                   	pop    %ebp
  80c0c8:	c3                   	ret    

0080c0c9 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80c0c9:	55                   	push   %ebp
  80c0ca:	89 e5                	mov    %esp,%ebp
  80c0cc:	56                   	push   %esi
  80c0cd:	53                   	push   %ebx
  80c0ce:	83 ec 10             	sub    $0x10,%esp
  80c0d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c0d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c0d7:	8b 75 10             	mov    0x10(%ebp),%esi
  80c0da:	8a 55 14             	mov    0x14(%ebp),%dl
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80c0dd:	85 c0                	test   %eax,%eax
  80c0df:	75 1c                	jne    80c0fd <recv_tcp+0x34>
  80c0e1:	c7 44 24 08 50 2b 81 	movl   $0x812b50,0x8(%esp)
  80c0e8:	00 
  80c0e9:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80c0f0:	00 
  80c0f1:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c0f8:	e8 7b 2d 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80c0fd:	85 db                	test   %ebx,%ebx
  80c0ff:	75 1c                	jne    80c11d <recv_tcp+0x54>
  80c101:	c7 44 24 08 74 2b 81 	movl   $0x812b74,0x8(%esp)
  80c108:	00 
  80c109:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80c110:	00 
  80c111:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c118:	e8 5b 2d 00 00       	call   80ee78 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80c11d:	39 43 08             	cmp    %eax,0x8(%ebx)
  80c120:	74 1c                	je     80c13e <recv_tcp+0x75>
  80c122:	c7 44 24 08 cb 2a 81 	movl   $0x812acb,0x8(%esp)
  80c129:	00 
  80c12a:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80c131:	00 
  80c132:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c139:	e8 3a 2d 00 00       	call   80ee78 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80c13e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c142:	74 47                	je     80c18b <recv_tcp+0xc2>
    return ERR_VAL;
  }

  conn->err = err;
  80c144:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80c147:	85 f6                	test   %esi,%esi
  80c149:	74 09                	je     80c154 <recv_tcp+0x8b>
    len = p->tot_len;
  80c14b:	8b 56 08             	mov    0x8(%esi),%edx
    SYS_ARCH_INC(conn->recv_avail, len);
  80c14e:	66 01 53 20          	add    %dx,0x20(%ebx)
  80c152:	eb 05                	jmp    80c159 <recv_tcp+0x90>
  } else {
    len = 0;
  80c154:	ba 00 00 00 00       	mov    $0x0,%edx
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80c159:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c15c:	85 c0                	test   %eax,%eax
  80c15e:	74 14                	je     80c174 <recv_tcp+0xab>
  80c160:	0f b7 d2             	movzwl %dx,%edx
  80c163:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c167:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c16e:	00 
  80c16f:	89 1c 24             	mov    %ebx,(%esp)
  80c172:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80c174:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c178:	8b 43 14             	mov    0x14(%ebx),%eax
  80c17b:	89 04 24             	mov    %eax,(%esp)
  80c17e:	e8 db e7 ff ff       	call   80a95e <sys_mbox_trypost>
    return ERR_MEM;
  80c183:	3c 01                	cmp    $0x1,%al
  80c185:	19 c0                	sbb    %eax,%eax
  80c187:	f7 d0                	not    %eax
  80c189:	eb 02                	jmp    80c18d <recv_tcp+0xc4>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80c18b:	b0 f7                	mov    $0xf7,%al
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80c18d:	83 c4 10             	add    $0x10,%esp
  80c190:	5b                   	pop    %ebx
  80c191:	5e                   	pop    %esi
  80c192:	5d                   	pop    %ebp
  80c193:	c3                   	ret    

0080c194 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80c194:	55                   	push   %ebp
  80c195:	89 e5                	mov    %esp,%ebp
  80c197:	57                   	push   %edi
  80c198:	56                   	push   %esi
  80c199:	53                   	push   %ebx
  80c19a:	83 ec 1c             	sub    $0x1c,%esp
  80c19d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c1a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c1a3:	8b 7d 18             	mov    0x18(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80c1a6:	85 c0                	test   %eax,%eax
  80c1a8:	75 1c                	jne    80c1c6 <recv_udp+0x32>
  80c1aa:	c7 44 24 08 94 2b 81 	movl   $0x812b94,0x8(%esp)
  80c1b1:	00 
  80c1b2:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80c1b9:	00 
  80c1ba:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c1c1:	e8 b2 2c 00 00       	call   80ee78 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80c1c6:	85 db                	test   %ebx,%ebx
  80c1c8:	75 1c                	jne    80c1e6 <recv_udp+0x52>
  80c1ca:	c7 44 24 08 b8 2b 81 	movl   $0x812bb8,0x8(%esp)
  80c1d1:	00 
  80c1d2:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80c1d9:	00 
  80c1da:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c1e1:	e8 92 2c 00 00       	call   80ee78 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80c1e6:	39 43 08             	cmp    %eax,0x8(%ebx)
  80c1e9:	74 1c                	je     80c207 <recv_udp+0x73>
  80c1eb:	c7 44 24 08 e9 2a 81 	movl   $0x812ae9,0x8(%esp)
  80c1f2:	00 
  80c1f3:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80c1fa:	00 
  80c1fb:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c202:	e8 71 2c 00 00       	call   80ee78 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80c207:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c20b:	75 0d                	jne    80c21a <recv_udp+0x86>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80c20d:	8b 45 10             	mov    0x10(%ebp),%eax
  80c210:	89 04 24             	mov    %eax,(%esp)
  80c213:	e8 5d 8b ff ff       	call   804d75 <pbuf_free>
    return;
  80c218:	eb 6f                	jmp    80c289 <recv_udp+0xf5>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80c21a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80c221:	e8 64 87 ff ff       	call   80498a <memp_malloc>
  80c226:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80c228:	85 c0                	test   %eax,%eax
  80c22a:	75 0d                	jne    80c239 <recv_udp+0xa5>
    pbuf_free(p);
  80c22c:	8b 55 10             	mov    0x10(%ebp),%edx
  80c22f:	89 14 24             	mov    %edx,(%esp)
  80c232:	e8 3e 8b ff ff       	call   804d75 <pbuf_free>
    return;
  80c237:	eb 50                	jmp    80c289 <recv_udp+0xf5>
  } else {
    buf->p = p;
  80c239:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80c23c:	89 08                	mov    %ecx,(%eax)
    buf->ptr = p;
  80c23e:	89 48 04             	mov    %ecx,0x4(%eax)
    buf->addr = addr;
  80c241:	8b 45 14             	mov    0x14(%ebp),%eax
  80c244:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80c247:	66 89 7e 0c          	mov    %di,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80c24b:	8b 41 08             	mov    0x8(%ecx),%eax
  80c24e:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80c252:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c255:	85 c0                	test   %eax,%eax
  80c257:	74 15                	je     80c26e <recv_udp+0xda>
  80c259:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  80c25d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c261:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c268:	00 
  80c269:	89 1c 24             	mov    %ebx,(%esp)
  80c26c:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80c26e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c272:	8b 43 14             	mov    0x14(%ebx),%eax
  80c275:	89 04 24             	mov    %eax,(%esp)
  80c278:	e8 e1 e6 ff ff       	call   80a95e <sys_mbox_trypost>
  80c27d:	84 c0                	test   %al,%al
  80c27f:	74 08                	je     80c289 <recv_udp+0xf5>
    netbuf_delete(buf);
  80c281:	89 34 24             	mov    %esi,(%esp)
  80c284:	e8 7f 65 ff ff       	call   802808 <netbuf_delete>
    return;
  }
}
  80c289:	83 c4 1c             	add    $0x1c,%esp
  80c28c:	5b                   	pop    %ebx
  80c28d:	5e                   	pop    %esi
  80c28e:	5f                   	pop    %edi
  80c28f:	5d                   	pop    %ebp
  80c290:	c3                   	ret    

0080c291 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80c291:	55                   	push   %ebp
  80c292:	89 e5                	mov    %esp,%ebp
  80c294:	57                   	push   %edi
  80c295:	56                   	push   %esi
  80c296:	53                   	push   %ebx
  80c297:	83 ec 1c             	sub    $0x1c,%esp
  80c29a:	8b 75 08             	mov    0x8(%ebp),%esi
  80c29d:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80c2a0:	85 f6                	test   %esi,%esi
  80c2a2:	0f 84 a7 00 00 00    	je     80c34f <recv_raw+0xbe>
  80c2a8:	83 7e 14 ff          	cmpl   $0xffffffff,0x14(%esi)
  80c2ac:	0f 84 9d 00 00 00    	je     80c34f <recv_raw+0xbe>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c2b2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c2b9:	00 
  80c2ba:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80c2be:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c2c2:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80c2c9:	e8 a8 8c ff ff       	call   804f76 <pbuf_alloc>
  80c2ce:	89 c3                	mov    %eax,%ebx
    if(q != NULL) {
  80c2d0:	85 c0                	test   %eax,%eax
  80c2d2:	74 7b                	je     80c34f <recv_raw+0xbe>
      if (pbuf_copy(q, p) != ERR_OK) {
  80c2d4:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c2d8:	89 04 24             	mov    %eax,(%esp)
  80c2db:	e8 7d 90 ff ff       	call   80535d <pbuf_copy>
  80c2e0:	84 c0                	test   %al,%al
  80c2e2:	74 75                	je     80c359 <recv_raw+0xc8>
        pbuf_free(q);
  80c2e4:	89 1c 24             	mov    %ebx,(%esp)
  80c2e7:	e8 89 8a ff ff       	call   804d75 <pbuf_free>
  80c2ec:	eb 61                	jmp    80c34f <recv_raw+0xbe>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80c2ee:	89 1c 24             	mov    %ebx,(%esp)
  80c2f1:	e8 7f 8a ff ff       	call   804d75 <pbuf_free>
        return 0;
  80c2f6:	eb 57                	jmp    80c34f <recv_raw+0xbe>
      }

      buf->p = q;
  80c2f8:	89 1f                	mov    %ebx,(%edi)
      buf->ptr = q;
  80c2fa:	89 5f 04             	mov    %ebx,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80c2fd:	8b 43 04             	mov    0x4(%ebx),%eax
  80c300:	83 c0 0c             	add    $0xc,%eax
  80c303:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80c306:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c309:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80c30d:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80c311:	8b 43 08             	mov    0x8(%ebx),%eax
  80c314:	66 01 46 20          	add    %ax,0x20(%esi)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80c318:	8b 46 2c             	mov    0x2c(%esi),%eax
  80c31b:	85 c0                	test   %eax,%eax
  80c31d:	74 15                	je     80c334 <recv_raw+0xa3>
  80c31f:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80c323:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c327:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c32e:	00 
  80c32f:	89 34 24             	mov    %esi,(%esp)
  80c332:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80c334:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c338:	8b 46 14             	mov    0x14(%esi),%eax
  80c33b:	89 04 24             	mov    %eax,(%esp)
  80c33e:	e8 1b e6 ff ff       	call   80a95e <sys_mbox_trypost>
  80c343:	84 c0                	test   %al,%al
  80c345:	74 08                	je     80c34f <recv_raw+0xbe>
        netbuf_delete(buf);
  80c347:	89 3c 24             	mov    %edi,(%esp)
  80c34a:	e8 b9 64 ff ff       	call   802808 <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80c34f:	b0 00                	mov    $0x0,%al
  80c351:	83 c4 1c             	add    $0x1c,%esp
  80c354:	5b                   	pop    %ebx
  80c355:	5e                   	pop    %esi
  80c356:	5f                   	pop    %edi
  80c357:	5d                   	pop    %ebp
  80c358:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80c359:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80c360:	e8 25 86 ff ff       	call   80498a <memp_malloc>
  80c365:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80c367:	85 c0                	test   %eax,%eax
  80c369:	75 8d                	jne    80c2f8 <recv_raw+0x67>
  80c36b:	eb 81                	jmp    80c2ee <recv_raw+0x5d>

0080c36d <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80c36d:	55                   	push   %ebp
  80c36e:	89 e5                	mov    %esp,%ebp
  80c370:	56                   	push   %esi
  80c371:	53                   	push   %ebx
  80c372:	83 ec 10             	sub    $0x10,%esp
  80c375:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80c378:	8b 03                	mov    (%ebx),%eax
  80c37a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c37e:	0f 85 d4 00 00 00    	jne    80c458 <do_newconn+0xeb>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80c384:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80c388:	8b 33                	mov    (%ebx),%esi
  80c38a:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80c38e:	74 1c                	je     80c3ac <do_newconn+0x3f>
  80c390:	c7 44 24 08 d8 2b 81 	movl   $0x812bd8,0x8(%esp)
  80c397:	00 
  80c398:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80c39f:	00 
  80c3a0:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c3a7:	e8 cc 2a 00 00       	call   80ee78 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80c3ac:	8b 06                	mov    (%esi),%eax
  80c3ae:	25 f0 00 00 00       	and    $0xf0,%eax
  80c3b3:	83 f8 20             	cmp    $0x20,%eax
  80c3b6:	74 44                	je     80c3fc <do_newconn+0x8f>
  80c3b8:	83 f8 40             	cmp    $0x40,%eax
  80c3bb:	74 0b                	je     80c3c8 <do_newconn+0x5b>
  80c3bd:	83 f8 10             	cmp    $0x10,%eax
  80c3c0:	0f 85 8e 00 00 00    	jne    80c454 <do_newconn+0xe7>
  80c3c6:	eb 6f                	jmp    80c437 <do_newconn+0xca>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80c3c8:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80c3cc:	89 04 24             	mov    %eax,(%esp)
  80c3cf:	e8 6a 24 00 00       	call   80e83e <raw_new>
  80c3d4:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80c3d7:	8b 03                	mov    (%ebx),%eax
  80c3d9:	8b 50 08             	mov    0x8(%eax),%edx
  80c3dc:	85 d2                	test   %edx,%edx
  80c3de:	75 06                	jne    80c3e6 <do_newconn+0x79>
       msg->conn->err = ERR_MEM;
  80c3e0:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c3e4:	eb 72                	jmp    80c458 <do_newconn+0xeb>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80c3e6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c3ea:	c7 44 24 04 91 c2 80 	movl   $0x80c291,0x4(%esp)
  80c3f1:	00 
  80c3f2:	89 14 24             	mov    %edx,(%esp)
  80c3f5:	e8 c4 22 00 00       	call   80e6be <raw_recv>
  80c3fa:	eb 5c                	jmp    80c458 <do_newconn+0xeb>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80c3fc:	e8 e9 d2 ff ff       	call   8096ea <udp_new>
  80c401:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80c404:	8b 03                	mov    (%ebx),%eax
  80c406:	8b 50 08             	mov    0x8(%eax),%edx
  80c409:	85 d2                	test   %edx,%edx
  80c40b:	75 06                	jne    80c413 <do_newconn+0xa6>
       msg->conn->err = ERR_MEM;
  80c40d:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c411:	eb 45                	jmp    80c458 <do_newconn+0xeb>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80c413:	83 38 22             	cmpl   $0x22,(%eax)
  80c416:	75 04                	jne    80c41c <do_newconn+0xaf>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80c418:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80c41c:	8b 03                	mov    (%ebx),%eax
  80c41e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c422:	c7 44 24 04 94 c1 80 	movl   $0x80c194,0x4(%esp)
  80c429:	00 
  80c42a:	8b 40 08             	mov    0x8(%eax),%eax
  80c42d:	89 04 24             	mov    %eax,(%esp)
  80c430:	e8 5b d2 ff ff       	call   809690 <udp_recv>
  80c435:	eb 21                	jmp    80c458 <do_newconn+0xeb>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80c437:	e8 ca a3 ff ff       	call   806806 <tcp_new>
  80c43c:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80c43f:	8b 03                	mov    (%ebx),%eax
  80c441:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c445:	75 06                	jne    80c44d <do_newconn+0xe0>
       msg->conn->err = ERR_MEM;
  80c447:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c44b:	eb 0b                	jmp    80c458 <do_newconn+0xeb>
       break;
     }
     setup_tcp(msg->conn);
  80c44d:	e8 ae f6 ff ff       	call   80bb00 <setup_tcp>
  80c452:	eb 04                	jmp    80c458 <do_newconn+0xeb>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80c454:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80c458:	8b 03                	mov    (%ebx),%eax
  80c45a:	8b 40 10             	mov    0x10(%eax),%eax
  80c45d:	89 04 24             	mov    %eax,(%esp)
  80c460:	e8 80 e3 ff ff       	call   80a7e5 <sys_sem_signal>
}
  80c465:	83 c4 10             	add    $0x10,%esp
  80c468:	5b                   	pop    %ebx
  80c469:	5e                   	pop    %esi
  80c46a:	5d                   	pop    %ebp
  80c46b:	c3                   	ret    

0080c46c <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80c46c:	55                   	push   %ebp
  80c46d:	89 e5                	mov    %esp,%ebp
  80c46f:	53                   	push   %ebx
  80c470:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80c473:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c47a:	e8 0b 85 ff ff       	call   80498a <memp_malloc>
  80c47f:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80c481:	85 c0                	test   %eax,%eax
  80c483:	0f 84 92 00 00 00    	je     80c51b <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80c489:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80c48d:	8b 45 08             	mov    0x8(%ebp),%eax
  80c490:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80c492:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80c499:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c4a0:	e8 32 e0 ff ff       	call   80a4d7 <sys_sem_new>
  80c4a5:	89 43 10             	mov    %eax,0x10(%ebx)
  80c4a8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c4ab:	75 17                	jne    80c4c4 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80c4ad:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c4b1:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c4b8:	e8 2d 85 ff ff       	call   8049ea <memp_free>
    return NULL;
  80c4bd:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c4c2:	eb 57                	jmp    80c51b <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80c4c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c4cb:	e8 e0 e1 ff ff       	call   80a6b0 <sys_mbox_new>
  80c4d0:	89 43 14             	mov    %eax,0x14(%ebx)
  80c4d3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c4d6:	75 22                	jne    80c4fa <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80c4d8:	8b 43 10             	mov    0x10(%ebx),%eax
  80c4db:	89 04 24             	mov    %eax,(%esp)
  80c4de:	e8 90 e0 ff ff       	call   80a573 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80c4e3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c4e7:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c4ee:	e8 f7 84 ff ff       	call   8049ea <memp_free>
    return NULL;
  80c4f3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c4f8:	eb 21                	jmp    80c51b <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80c4fa:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80c501:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80c508:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80c50f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c512:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80c515:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80c51b:	89 d8                	mov    %ebx,%eax
  80c51d:	83 c4 14             	add    $0x14,%esp
  80c520:	5b                   	pop    %ebx
  80c521:	5d                   	pop    %ebp
  80c522:	c3                   	ret    

0080c523 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c523:	55                   	push   %ebp
  80c524:	89 e5                	mov    %esp,%ebp
  80c526:	56                   	push   %esi
  80c527:	53                   	push   %ebx
  80c528:	83 ec 20             	sub    $0x20,%esp
  80c52b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c52e:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c532:	74 1c                	je     80c550 <netconn_free+0x2d>
  80c534:	c7 44 24 08 f8 2b 81 	movl   $0x812bf8,0x8(%esp)
  80c53b:	00 
  80c53c:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c543:	00 
  80c544:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c54b:	e8 28 29 00 00       	call   80ee78 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c550:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c554:	75 25                	jne    80c57b <netconn_free+0x58>
  80c556:	eb 4c                	jmp    80c5a4 <netconn_free+0x81>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c558:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c55b:	75 11                	jne    80c56e <netconn_free+0x4b>
        if(mem != NULL) {
  80c55d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c560:	85 c0                	test   %eax,%eax
  80c562:	74 1a                	je     80c57e <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80c564:	89 04 24             	mov    %eax,(%esp)
  80c567:	e8 09 88 ff ff       	call   804d75 <pbuf_free>
  80c56c:	eb 10                	jmp    80c57e <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c56e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c571:	89 04 24             	mov    %eax,(%esp)
  80c574:	e8 8f 62 ff ff       	call   802808 <netbuf_delete>
  80c579:	eb 03                	jmp    80c57e <netconn_free+0x5b>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c57b:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c57e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c582:	8b 43 14             	mov    0x14(%ebx),%eax
  80c585:	89 04 24             	mov    %eax,(%esp)
  80c588:	e8 0f e6 ff ff       	call   80ab9c <sys_arch_mbox_tryfetch>
  80c58d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c590:	75 c6                	jne    80c558 <netconn_free+0x35>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c592:	8b 43 14             	mov    0x14(%ebx),%eax
  80c595:	89 04 24             	mov    %eax,(%esp)
  80c598:	e8 4a e0 ff ff       	call   80a5e7 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c59d:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c5a4:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c5a8:	75 0f                	jne    80c5b9 <netconn_free+0x96>
  80c5aa:	eb 36                	jmp    80c5e2 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80c5ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c5af:	89 04 24             	mov    %eax,(%esp)
  80c5b2:	e8 99 ef ff ff       	call   80b550 <netconn_delete>
  80c5b7:	eb 03                	jmp    80c5bc <netconn_free+0x99>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c5b9:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c5bc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c5c0:	8b 43 18             	mov    0x18(%ebx),%eax
  80c5c3:	89 04 24             	mov    %eax,(%esp)
  80c5c6:	e8 d1 e5 ff ff       	call   80ab9c <sys_arch_mbox_tryfetch>
  80c5cb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c5ce:	75 dc                	jne    80c5ac <netconn_free+0x89>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c5d0:	8b 43 18             	mov    0x18(%ebx),%eax
  80c5d3:	89 04 24             	mov    %eax,(%esp)
  80c5d6:	e8 0c e0 ff ff       	call   80a5e7 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c5db:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80c5e2:	8b 43 10             	mov    0x10(%ebx),%eax
  80c5e5:	89 04 24             	mov    %eax,(%esp)
  80c5e8:	e8 86 df ff ff       	call   80a573 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c5ed:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80c5f4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c5f8:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c5ff:	e8 e6 83 ff ff       	call   8049ea <memp_free>
}
  80c604:	83 c4 20             	add    $0x20,%esp
  80c607:	5b                   	pop    %ebx
  80c608:	5e                   	pop    %esi
  80c609:	5d                   	pop    %ebp
  80c60a:	c3                   	ret    

0080c60b <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80c60b:	55                   	push   %ebp
  80c60c:	89 e5                	mov    %esp,%ebp
  80c60e:	56                   	push   %esi
  80c60f:	53                   	push   %ebx
  80c610:	83 ec 20             	sub    $0x20,%esp
  80c613:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c616:	8a 45 10             	mov    0x10(%ebp),%al
  80c619:	88 45 f7             	mov    %al,-0x9(%ebp)
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c61c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c620:	75 1c                	jne    80c63e <accept_function+0x33>
  80c622:	c7 44 24 08 28 2c 81 	movl   $0x812c28,0x8(%esp)
  80c629:	00 
  80c62a:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80c631:	00 
  80c632:	c7 04 24 25 2a 81 00 	movl   $0x812a25,(%esp)
  80c639:	e8 3a 28 00 00       	call   80ee78 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80c63e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c641:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c645:	8b 03                	mov    (%ebx),%eax
  80c647:	89 04 24             	mov    %eax,(%esp)
  80c64a:	e8 1d fe ff ff       	call   80c46c <netconn_alloc>
  80c64f:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80c651:	85 c0                	test   %eax,%eax
  80c653:	74 55                	je     80c6aa <accept_function+0x9f>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80c655:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c658:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80c65b:	89 f0                	mov    %esi,%eax
  80c65d:	e8 9e f4 ff ff       	call   80bb00 <setup_tcp>
  newconn->err = err;
  80c662:	8a 45 f7             	mov    -0x9(%ebp),%al
  80c665:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c668:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c66b:	85 c0                	test   %eax,%eax
  80c66d:	74 15                	je     80c684 <accept_function+0x79>
  80c66f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c676:	00 
  80c677:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c67e:	00 
  80c67f:	89 1c 24             	mov    %ebx,(%esp)
  80c682:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c684:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c688:	8b 43 18             	mov    0x18(%ebx),%eax
  80c68b:	89 04 24             	mov    %eax,(%esp)
  80c68e:	e8 cb e2 ff ff       	call   80a95e <sys_mbox_trypost>
  80c693:	84 c0                	test   %al,%al
  80c695:	74 17                	je     80c6ae <accept_function+0xa3>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80c697:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80c69e:	89 34 24             	mov    %esi,(%esp)
  80c6a1:	e8 7d fe ff ff       	call   80c523 <netconn_free>
    return ERR_MEM;
  80c6a6:	b0 ff                	mov    $0xff,%al
  80c6a8:	eb 06                	jmp    80c6b0 <accept_function+0xa5>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80c6aa:	b0 ff                	mov    $0xff,%al
  80c6ac:	eb 02                	jmp    80c6b0 <accept_function+0xa5>
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80c6ae:	b0 00                	mov    $0x0,%al
}
  80c6b0:	83 c4 20             	add    $0x20,%esp
  80c6b3:	5b                   	pop    %ebx
  80c6b4:	5e                   	pop    %esi
  80c6b5:	5d                   	pop    %ebp
  80c6b6:	c3                   	ret    

0080c6b7 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c6b7:	55                   	push   %ebp
  80c6b8:	89 e5                	mov    %esp,%ebp
  80c6ba:	53                   	push   %ebx
  80c6bb:	83 ec 14             	sub    $0x14,%esp
  80c6be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c6c1:	8b 03                	mov    (%ebx),%eax
  80c6c3:	8b 48 08             	mov    0x8(%eax),%ecx
  80c6c6:	85 c9                	test   %ecx,%ecx
  80c6c8:	74 49                	je     80c713 <do_delconn+0x5c>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c6ca:	8b 10                	mov    (%eax),%edx
  80c6cc:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c6d2:	83 fa 20             	cmp    $0x20,%edx
  80c6d5:	74 16                	je     80c6ed <do_delconn+0x36>
  80c6d7:	83 fa 40             	cmp    $0x40,%edx
  80c6da:	74 07                	je     80c6e3 <do_delconn+0x2c>
  80c6dc:	83 fa 10             	cmp    $0x10,%edx
  80c6df:	75 32                	jne    80c713 <do_delconn+0x5c>
  80c6e1:	eb 20                	jmp    80c703 <do_delconn+0x4c>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c6e3:	89 0c 24             	mov    %ecx,(%esp)
  80c6e6:	e8 0d 21 00 00       	call   80e7f8 <raw_remove>
      break;
  80c6eb:	eb 26                	jmp    80c713 <do_delconn+0x5c>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c6ed:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c6f4:	8b 03                	mov    (%ebx),%eax
  80c6f6:	8b 40 08             	mov    0x8(%eax),%eax
  80c6f9:	89 04 24             	mov    %eax,(%esp)
  80c6fc:	e8 a3 cf ff ff       	call   8096a4 <udp_remove>
      break;
  80c701:	eb 10                	jmp    80c713 <do_delconn+0x5c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c703:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c70a:	8b 03                	mov    (%ebx),%eax
  80c70c:	e8 95 f4 ff ff       	call   80bba6 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c711:	eb 4e                	jmp    80c761 <do_delconn+0xaa>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c713:	8b 13                	mov    (%ebx),%edx
  80c715:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c718:	85 c0                	test   %eax,%eax
  80c71a:	74 33                	je     80c74f <do_delconn+0x98>
  80c71c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c723:	00 
  80c724:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c72b:	00 
  80c72c:	89 14 24             	mov    %edx,(%esp)
  80c72f:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c731:	8b 13                	mov    (%ebx),%edx
  80c733:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c736:	85 c0                	test   %eax,%eax
  80c738:	74 15                	je     80c74f <do_delconn+0x98>
  80c73a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c741:	00 
  80c742:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c749:	00 
  80c74a:	89 14 24             	mov    %edx,(%esp)
  80c74d:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c74f:	8b 03                	mov    (%ebx),%eax
  80c751:	8b 40 10             	mov    0x10(%eax),%eax
  80c754:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c757:	74 08                	je     80c761 <do_delconn+0xaa>
    sys_sem_signal(msg->conn->op_completed);
  80c759:	89 04 24             	mov    %eax,(%esp)
  80c75c:	e8 84 e0 ff ff       	call   80a7e5 <sys_sem_signal>
  }
}
  80c761:	83 c4 14             	add    $0x14,%esp
  80c764:	5b                   	pop    %ebx
  80c765:	5d                   	pop    %ebp
  80c766:	c3                   	ret    

0080c767 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c767:	55                   	push   %ebp
  80c768:	89 e5                	mov    %esp,%ebp
  80c76a:	56                   	push   %esi
  80c76b:	53                   	push   %ebx
  80c76c:	83 ec 10             	sub    $0x10,%esp
  80c76f:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c772:	8b 1e                	mov    (%esi),%ebx
  80c774:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c778:	7c 6f                	jl     80c7e9 <do_bind+0x82>
    if (msg->conn->pcb.tcp != NULL) {
  80c77a:	8b 53 08             	mov    0x8(%ebx),%edx
  80c77d:	85 d2                	test   %edx,%edx
  80c77f:	74 64                	je     80c7e5 <do_bind+0x7e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c781:	8b 03                	mov    (%ebx),%eax
  80c783:	25 f0 00 00 00       	and    $0xf0,%eax
  80c788:	83 f8 20             	cmp    $0x20,%eax
  80c78b:	74 20                	je     80c7ad <do_bind+0x46>
  80c78d:	83 f8 40             	cmp    $0x40,%eax
  80c790:	74 07                	je     80c799 <do_bind+0x32>
  80c792:	83 f8 10             	cmp    $0x10,%eax
  80c795:	75 52                	jne    80c7e9 <do_bind+0x82>
  80c797:	eb 30                	jmp    80c7c9 <do_bind+0x62>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c799:	8b 46 04             	mov    0x4(%esi),%eax
  80c79c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7a0:	89 14 24             	mov    %edx,(%esp)
  80c7a3:	e8 dd 1e 00 00       	call   80e685 <raw_bind>
  80c7a8:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c7ab:	eb 3c                	jmp    80c7e9 <do_bind+0x82>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c7ad:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c7b1:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c7b5:	8b 46 04             	mov    0x4(%esi),%eax
  80c7b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7bc:	89 14 24             	mov    %edx,(%esp)
  80c7bf:	e8 5e cb ff ff       	call   809322 <udp_bind>
  80c7c4:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c7c7:	eb 20                	jmp    80c7e9 <do_bind+0x82>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c7c9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c7cd:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c7d1:	8b 46 04             	mov    0x4(%esi),%eax
  80c7d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7d8:	89 14 24             	mov    %edx,(%esp)
  80c7db:	e8 82 91 ff ff       	call   805962 <tcp_bind>
  80c7e0:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80c7e3:	eb 04                	jmp    80c7e9 <do_bind+0x82>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c7e5:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c7e9:	8b 06                	mov    (%esi),%eax
  80c7eb:	8b 40 10             	mov    0x10(%eax),%eax
  80c7ee:	89 04 24             	mov    %eax,(%esp)
  80c7f1:	e8 ef df ff ff       	call   80a7e5 <sys_sem_signal>
}
  80c7f6:	83 c4 10             	add    $0x10,%esp
  80c7f9:	5b                   	pop    %ebx
  80c7fa:	5e                   	pop    %esi
  80c7fb:	5d                   	pop    %ebp
  80c7fc:	c3                   	ret    

0080c7fd <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c7fd:	55                   	push   %ebp
  80c7fe:	89 e5                	mov    %esp,%ebp
  80c800:	56                   	push   %esi
  80c801:	53                   	push   %ebx
  80c802:	83 ec 10             	sub    $0x10,%esp
  80c805:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80c808:	8b 1e                	mov    (%esi),%ebx
  80c80a:	8b 53 08             	mov    0x8(%ebx),%edx
  80c80d:	85 d2                	test   %edx,%edx
  80c80f:	75 10                	jne    80c821 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c811:	8b 43 10             	mov    0x10(%ebx),%eax
  80c814:	89 04 24             	mov    %eax,(%esp)
  80c817:	e8 c9 df ff ff       	call   80a7e5 <sys_sem_signal>
    return;
  80c81c:	e9 9b 00 00 00       	jmp    80c8bc <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c821:	8b 03                	mov    (%ebx),%eax
  80c823:	25 f0 00 00 00       	and    $0xf0,%eax
  80c828:	83 f8 20             	cmp    $0x20,%eax
  80c82b:	74 31                	je     80c85e <do_connect+0x61>
  80c82d:	83 f8 40             	cmp    $0x40,%eax
  80c830:	74 0b                	je     80c83d <do_connect+0x40>
  80c832:	83 f8 10             	cmp    $0x10,%eax
  80c835:	0f 85 81 00 00 00    	jne    80c8bc <do_connect+0xbf>
  80c83b:	eb 4a                	jmp    80c887 <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c83d:	8b 46 04             	mov    0x4(%esi),%eax
  80c840:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c844:	89 14 24             	mov    %edx,(%esp)
  80c847:	e8 55 1e 00 00       	call   80e6a1 <raw_connect>
  80c84c:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c84f:	8b 06                	mov    (%esi),%eax
  80c851:	8b 40 10             	mov    0x10(%eax),%eax
  80c854:	89 04 24             	mov    %eax,(%esp)
  80c857:	e8 89 df ff ff       	call   80a7e5 <sys_sem_signal>
    break;
  80c85c:	eb 5e                	jmp    80c8bc <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c85e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c862:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c866:	8b 46 04             	mov    0x4(%esi),%eax
  80c869:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c86d:	89 14 24             	mov    %edx,(%esp)
  80c870:	e8 8d cd ff ff       	call   809602 <udp_connect>
  80c875:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80c878:	8b 06                	mov    (%esi),%eax
  80c87a:	8b 40 10             	mov    0x10(%eax),%eax
  80c87d:	89 04 24             	mov    %eax,(%esp)
  80c880:	e8 60 df ff ff       	call   80a7e5 <sys_sem_signal>
    break;
  80c885:	eb 35                	jmp    80c8bc <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80c887:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80c88e:	8b 06                	mov    (%esi),%eax
  80c890:	e8 6b f2 ff ff       	call   80bb00 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c895:	8b 1e                	mov    (%esi),%ebx
  80c897:	c7 44 24 0c 64 bb 80 	movl   $0x80bb64,0xc(%esp)
  80c89e:	00 
  80c89f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c8a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c8a7:	8b 46 04             	mov    0x4(%esi),%eax
  80c8aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8ae:	8b 43 08             	mov    0x8(%ebx),%eax
  80c8b1:	89 04 24             	mov    %eax,(%esp)
  80c8b4:	e8 94 9f ff ff       	call   80684d <tcp_connect>
  80c8b9:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80c8bc:	83 c4 10             	add    $0x10,%esp
  80c8bf:	5b                   	pop    %ebx
  80c8c0:	5e                   	pop    %esi
  80c8c1:	5d                   	pop    %ebp
  80c8c2:	c3                   	ret    

0080c8c3 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80c8c3:	55                   	push   %ebp
  80c8c4:	89 e5                	mov    %esp,%ebp
  80c8c6:	53                   	push   %ebx
  80c8c7:	83 ec 14             	sub    $0x14,%esp
  80c8ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c8cd:	8b 03                	mov    (%ebx),%eax
  80c8cf:	8b 10                	mov    (%eax),%edx
  80c8d1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c8d7:	83 fa 20             	cmp    $0x20,%edx
  80c8da:	75 0b                	jne    80c8e7 <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80c8dc:	8b 40 08             	mov    0x8(%eax),%eax
  80c8df:	89 04 24             	mov    %eax,(%esp)
  80c8e2:	e8 8e cd ff ff       	call   809675 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80c8e7:	8b 03                	mov    (%ebx),%eax
  80c8e9:	8b 40 10             	mov    0x10(%eax),%eax
  80c8ec:	89 04 24             	mov    %eax,(%esp)
  80c8ef:	e8 f1 de ff ff       	call   80a7e5 <sys_sem_signal>
}
  80c8f4:	83 c4 14             	add    $0x14,%esp
  80c8f7:	5b                   	pop    %ebx
  80c8f8:	5d                   	pop    %ebp
  80c8f9:	c3                   	ret    

0080c8fa <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80c8fa:	55                   	push   %ebp
  80c8fb:	89 e5                	mov    %esp,%ebp
  80c8fd:	57                   	push   %edi
  80c8fe:	56                   	push   %esi
  80c8ff:	53                   	push   %ebx
  80c900:	83 ec 1c             	sub    $0x1c,%esp
  80c903:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c906:	8b 06                	mov    (%esi),%eax
  80c908:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c90c:	0f 8c b9 00 00 00    	jl     80c9cb <do_listen+0xd1>
    if (msg->conn->pcb.tcp != NULL) {
  80c912:	8b 50 08             	mov    0x8(%eax),%edx
  80c915:	85 d2                	test   %edx,%edx
  80c917:	0f 84 ae 00 00 00    	je     80c9cb <do_listen+0xd1>
      if (msg->conn->type == NETCONN_TCP) {
  80c91d:	83 38 10             	cmpl   $0x10,(%eax)
  80c920:	0f 85 a5 00 00 00    	jne    80c9cb <do_listen+0xd1>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c926:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c92a:	0f 85 97 00 00 00    	jne    80c9c7 <do_listen+0xcd>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c930:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80c937:	00 
  80c938:	89 14 24             	mov    %edx,(%esp)
  80c93b:	e8 ac 91 ff ff       	call   805aec <tcp_listen_with_backlog>
  80c940:	89 c7                	mov    %eax,%edi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80c942:	85 c0                	test   %eax,%eax
  80c944:	75 08                	jne    80c94e <do_listen+0x54>
            msg->conn->err = ERR_MEM;
  80c946:	8b 06                	mov    (%esi),%eax
  80c948:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c94c:	eb 7d                	jmp    80c9cb <do_listen+0xd1>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c94e:	8b 06                	mov    (%esi),%eax
  80c950:	8b 40 14             	mov    0x14(%eax),%eax
  80c953:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c956:	74 11                	je     80c969 <do_listen+0x6f>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80c958:	89 04 24             	mov    %eax,(%esp)
  80c95b:	e8 87 dc ff ff       	call   80a5e7 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c960:	8b 06                	mov    (%esi),%eax
  80c962:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c969:	8b 1e                	mov    (%esi),%ebx
  80c96b:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c96f:	75 1a                	jne    80c98b <do_listen+0x91>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c971:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c978:	e8 33 dd ff ff       	call   80a6b0 <sys_mbox_new>
  80c97d:	89 43 18             	mov    %eax,0x18(%ebx)
  80c980:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c983:	75 06                	jne    80c98b <do_listen+0x91>
                msg->conn->err = ERR_MEM;
  80c985:	8b 06                	mov    (%esi),%eax
  80c987:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80c98b:	8b 06                	mov    (%esi),%eax
  80c98d:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c991:	75 38                	jne    80c9cb <do_listen+0xd1>
              msg->conn->state = NETCONN_LISTEN;
  80c993:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c99a:	8b 06                	mov    (%esi),%eax
  80c99c:	89 78 08             	mov    %edi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c99f:	8b 06                	mov    (%esi),%eax
  80c9a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9a5:	8b 40 08             	mov    0x8(%eax),%eax
  80c9a8:	89 04 24             	mov    %eax,(%esp)
  80c9ab:	e8 fe 93 ff ff       	call   805dae <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c9b0:	c7 44 24 04 0b c6 80 	movl   $0x80c60b,0x4(%esp)
  80c9b7:	00 
  80c9b8:	8b 06                	mov    (%esi),%eax
  80c9ba:	8b 40 08             	mov    0x8(%eax),%eax
  80c9bd:	89 04 24             	mov    %eax,(%esp)
  80c9c0:	e8 2a 94 ff ff       	call   805def <tcp_accept>
  80c9c5:	eb 04                	jmp    80c9cb <do_listen+0xd1>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80c9c7:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c9cb:	8b 06                	mov    (%esi),%eax
  80c9cd:	8b 40 10             	mov    0x10(%eax),%eax
  80c9d0:	89 04 24             	mov    %eax,(%esp)
  80c9d3:	e8 0d de ff ff       	call   80a7e5 <sys_sem_signal>
}
  80c9d8:	83 c4 1c             	add    $0x1c,%esp
  80c9db:	5b                   	pop    %ebx
  80c9dc:	5e                   	pop    %esi
  80c9dd:	5f                   	pop    %edi
  80c9de:	5d                   	pop    %ebp
  80c9df:	c3                   	ret    

0080c9e0 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80c9e0:	55                   	push   %ebp
  80c9e1:	89 e5                	mov    %esp,%ebp
  80c9e3:	57                   	push   %edi
  80c9e4:	56                   	push   %esi
  80c9e5:	53                   	push   %ebx
  80c9e6:	83 ec 1c             	sub    $0x1c,%esp
  80c9e9:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c9ec:	8b 1e                	mov    (%esi),%ebx
  80c9ee:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80c9f2:	0f 8c 8b 00 00 00    	jl     80ca83 <do_send+0xa3>
    if (msg->conn->pcb.tcp != NULL) {
  80c9f8:	8b 43 08             	mov    0x8(%ebx),%eax
  80c9fb:	85 c0                	test   %eax,%eax
  80c9fd:	0f 84 80 00 00 00    	je     80ca83 <do_send+0xa3>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ca03:	8b 13                	mov    (%ebx),%edx
  80ca05:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ca0b:	83 fa 20             	cmp    $0x20,%edx
  80ca0e:	74 39                	je     80ca49 <do_send+0x69>
  80ca10:	83 fa 40             	cmp    $0x40,%edx
  80ca13:	75 6e                	jne    80ca83 <do_send+0xa3>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80ca15:	8b 56 04             	mov    0x4(%esi),%edx
  80ca18:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ca1b:	85 c9                	test   %ecx,%ecx
  80ca1d:	75 13                	jne    80ca32 <do_send+0x52>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80ca1f:	8b 12                	mov    (%edx),%edx
  80ca21:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca25:	89 04 24             	mov    %eax,(%esp)
  80ca28:	e8 aa 1d 00 00       	call   80e7d7 <raw_send>
  80ca2d:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca30:	eb 51                	jmp    80ca83 <do_send+0xa3>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80ca32:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ca36:	8b 12                	mov    (%edx),%edx
  80ca38:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca3c:	89 04 24             	mov    %eax,(%esp)
  80ca3f:	e8 8e 1c 00 00       	call   80e6d2 <raw_sendto>
  80ca44:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca47:	eb 3a                	jmp    80ca83 <do_send+0xa3>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80ca49:	8b 56 04             	mov    0x4(%esi),%edx
  80ca4c:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ca4f:	85 c9                	test   %ecx,%ecx
  80ca51:	75 13                	jne    80ca66 <do_send+0x86>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80ca53:	8b 12                	mov    (%edx),%edx
  80ca55:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca59:	89 04 24             	mov    %eax,(%esp)
  80ca5c:	e8 78 cb ff ff       	call   8095d9 <udp_send>
  80ca61:	88 43 0c             	mov    %al,0xc(%ebx)
  80ca64:	eb 1d                	jmp    80ca83 <do_send+0xa3>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80ca66:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80ca6a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80ca6e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ca72:	8b 12                	mov    (%edx),%edx
  80ca74:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca78:	89 04 24             	mov    %eax,(%esp)
  80ca7b:	e8 13 cb ff ff       	call   809593 <udp_sendto>
  80ca80:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ca83:	8b 06                	mov    (%esi),%eax
  80ca85:	8b 40 10             	mov    0x10(%eax),%eax
  80ca88:	89 04 24             	mov    %eax,(%esp)
  80ca8b:	e8 55 dd ff ff       	call   80a7e5 <sys_sem_signal>
}
  80ca90:	83 c4 1c             	add    $0x1c,%esp
  80ca93:	5b                   	pop    %ebx
  80ca94:	5e                   	pop    %esi
  80ca95:	5f                   	pop    %edi
  80ca96:	5d                   	pop    %ebp
  80ca97:	c3                   	ret    

0080ca98 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80ca98:	55                   	push   %ebp
  80ca99:	89 e5                	mov    %esp,%ebp
  80ca9b:	53                   	push   %ebx
  80ca9c:	83 ec 14             	sub    $0x14,%esp
  80ca9f:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80caa2:	8b 03                	mov    (%ebx),%eax
  80caa4:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80caa8:	7c 1c                	jl     80cac6 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80caaa:	8b 50 08             	mov    0x8(%eax),%edx
  80caad:	85 d2                	test   %edx,%edx
  80caaf:	74 15                	je     80cac6 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80cab1:	83 38 10             	cmpl   $0x10,(%eax)
  80cab4:	75 10                	jne    80cac6 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80cab6:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80caba:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cabe:	89 14 24             	mov    %edx,(%esp)
  80cac1:	e8 21 91 ff ff       	call   805be7 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cac6:	8b 03                	mov    (%ebx),%eax
  80cac8:	8b 40 10             	mov    0x10(%eax),%eax
  80cacb:	89 04 24             	mov    %eax,(%esp)
  80cace:	e8 12 dd ff ff       	call   80a7e5 <sys_sem_signal>
}
  80cad3:	83 c4 14             	add    $0x14,%esp
  80cad6:	5b                   	pop    %ebx
  80cad7:	5d                   	pop    %ebp
  80cad8:	c3                   	ret    

0080cad9 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80cad9:	55                   	push   %ebp
  80cada:	89 e5                	mov    %esp,%ebp
  80cadc:	83 ec 18             	sub    $0x18,%esp
  80cadf:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cae2:	8b 02                	mov    (%edx),%eax
  80cae4:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cae8:	7c 2d                	jl     80cb17 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80caea:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80caee:	74 23                	je     80cb13 <do_write+0x3a>
  80caf0:	83 38 10             	cmpl   $0x10,(%eax)
  80caf3:	75 1e                	jne    80cb13 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80caf5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80cafc:	8b 02                	mov    (%edx),%eax
  80cafe:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80cb01:	8b 02                	mov    (%edx),%eax
  80cb03:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80cb0a:	8b 02                	mov    (%edx),%eax
  80cb0c:	e8 74 f3 ff ff       	call   80be85 <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80cb11:	eb 11                	jmp    80cb24 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80cb13:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cb17:	8b 02                	mov    (%edx),%eax
  80cb19:	8b 40 10             	mov    0x10(%eax),%eax
  80cb1c:	89 04 24             	mov    %eax,(%esp)
  80cb1f:	e8 c1 dc ff ff       	call   80a7e5 <sys_sem_signal>
}
  80cb24:	c9                   	leave  
  80cb25:	c3                   	ret    

0080cb26 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80cb26:	55                   	push   %ebp
  80cb27:	89 e5                	mov    %esp,%ebp
  80cb29:	83 ec 18             	sub    $0x18,%esp
  80cb2c:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80cb2f:	8b 08                	mov    (%eax),%ecx
  80cb31:	8b 51 08             	mov    0x8(%ecx),%edx
  80cb34:	85 d2                	test   %edx,%edx
  80cb36:	0f 84 96 00 00 00    	je     80cbd2 <do_getaddr+0xac>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80cb3c:	8b 48 04             	mov    0x4(%eax),%ecx
  80cb3f:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb43:	74 06                	je     80cb4b <do_getaddr+0x25>
  80cb45:	8b 12                	mov    (%edx),%edx
  80cb47:	89 11                	mov    %edx,(%ecx)
  80cb49:	eb 05                	jmp    80cb50 <do_getaddr+0x2a>
  80cb4b:	8b 52 04             	mov    0x4(%edx),%edx
  80cb4e:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cb50:	8b 08                	mov    (%eax),%ecx
  80cb52:	8b 11                	mov    (%ecx),%edx
  80cb54:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cb5a:	83 fa 20             	cmp    $0x20,%edx
  80cb5d:	74 27                	je     80cb86 <do_getaddr+0x60>
  80cb5f:	83 fa 40             	cmp    $0x40,%edx
  80cb62:	74 07                	je     80cb6b <do_getaddr+0x45>
  80cb64:	83 fa 10             	cmp    $0x10,%edx
  80cb67:	75 6d                	jne    80cbd6 <do_getaddr+0xb0>
  80cb69:	eb 4a                	jmp    80cbb5 <do_getaddr+0x8f>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80cb6b:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb6f:	74 0f                	je     80cb80 <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80cb71:	8b 50 08             	mov    0x8(%eax),%edx
  80cb74:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cb77:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80cb7b:	66 89 0a             	mov    %cx,(%edx)
  80cb7e:	eb 56                	jmp    80cbd6 <do_getaddr+0xb0>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80cb80:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cb84:	eb 50                	jmp    80cbd6 <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80cb86:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb8a:	74 0f                	je     80cb9b <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80cb8c:	8b 50 08             	mov    0x8(%eax),%edx
  80cb8f:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cb92:	66 8b 49 12          	mov    0x12(%ecx),%cx
  80cb96:	66 89 0a             	mov    %cx,(%edx)
  80cb99:	eb 3b                	jmp    80cbd6 <do_getaddr+0xb0>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80cb9b:	8b 51 08             	mov    0x8(%ecx),%edx
  80cb9e:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80cba2:	75 06                	jne    80cbaa <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80cba4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cba8:	eb 2c                	jmp    80cbd6 <do_getaddr+0xb0>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80cbaa:	8b 48 08             	mov    0x8(%eax),%ecx
  80cbad:	8b 52 14             	mov    0x14(%edx),%edx
  80cbb0:	66 89 11             	mov    %dx,(%ecx)
  80cbb3:	eb 21                	jmp    80cbd6 <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80cbb5:	8b 50 08             	mov    0x8(%eax),%edx
  80cbb8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cbbc:	74 08                	je     80cbc6 <do_getaddr+0xa0>
  80cbbe:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cbc1:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  80cbc4:	eb 07                	jmp    80cbcd <do_getaddr+0xa7>
  80cbc6:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cbc9:	66 8b 49 1e          	mov    0x1e(%ecx),%cx
  80cbcd:	66 89 0a             	mov    %cx,(%edx)
      break;
  80cbd0:	eb 04                	jmp    80cbd6 <do_getaddr+0xb0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80cbd2:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80cbd6:	8b 00                	mov    (%eax),%eax
  80cbd8:	8b 40 10             	mov    0x10(%eax),%eax
  80cbdb:	89 04 24             	mov    %eax,(%esp)
  80cbde:	e8 02 dc ff ff       	call   80a7e5 <sys_sem_signal>
}
  80cbe3:	c9                   	leave  
  80cbe4:	c3                   	ret    

0080cbe5 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80cbe5:	55                   	push   %ebp
  80cbe6:	89 e5                	mov    %esp,%ebp
  80cbe8:	83 ec 18             	sub    $0x18,%esp
  80cbeb:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cbee:	8b 02                	mov    (%edx),%eax
  80cbf0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cbf4:	74 15                	je     80cc0b <do_close+0x26>
  80cbf6:	83 38 10             	cmpl   $0x10,(%eax)
  80cbf9:	75 10                	jne    80cc0b <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80cbfb:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80cc02:	8b 02                	mov    (%edx),%eax
  80cc04:	e8 9d ef ff ff       	call   80bba6 <do_close_internal>
  80cc09:	eb 11                	jmp    80cc1c <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80cc0b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80cc0f:	8b 02                	mov    (%edx),%eax
  80cc11:	8b 40 10             	mov    0x10(%eax),%eax
  80cc14:	89 04 24             	mov    %eax,(%esp)
  80cc17:	e8 c9 db ff ff       	call   80a7e5 <sys_sem_signal>
  }
}
  80cc1c:	c9                   	leave  
  80cc1d:	c3                   	ret    
	...

0080cc20 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cc20:	55                   	push   %ebp
  80cc21:	89 e5                	mov    %esp,%ebp
  80cc23:	57                   	push   %edi
  80cc24:	56                   	push   %esi
  80cc25:	53                   	push   %ebx
  80cc26:	83 ec 1c             	sub    $0x1c,%esp
  80cc29:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cc2b:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80cc30:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cc33:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc37:	89 04 24             	mov    %eax,(%esp)
  80cc3a:	e8 4a b0 ff ff       	call   807c89 <ntohs>
  80cc3f:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80cc43:	77 4e                	ja     80cc93 <tcp_parseopt+0x73>
  80cc45:	eb 74                	jmp    80ccbb <tcp_parseopt+0x9b>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cc47:	0f b6 d3             	movzbl %bl,%edx
  80cc4a:	8a 04 16             	mov    (%esi,%edx,1),%al
      if (opt == 0x00) {
  80cc4d:	84 c0                	test   %al,%al
  80cc4f:	74 6a                	je     80ccbb <tcp_parseopt+0x9b>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cc51:	3c 01                	cmp    $0x1,%al
  80cc53:	75 03                	jne    80cc58 <tcp_parseopt+0x38>
        ++c;
  80cc55:	43                   	inc    %ebx
  80cc56:	eb 3d                	jmp    80cc95 <tcp_parseopt+0x75>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80cc58:	3c 02                	cmp    $0x2,%al
  80cc5a:	75 2b                	jne    80cc87 <tcp_parseopt+0x67>
  80cc5c:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80cc61:	75 24                	jne    80cc87 <tcp_parseopt+0x67>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80cc63:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80cc68:	c1 e0 08             	shl    $0x8,%eax
  80cc6b:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80cc70:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80cc72:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cc75:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80cc7a:	76 05                	jbe    80cc81 <tcp_parseopt+0x61>
  80cc7c:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80cc81:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80cc85:	eb 34                	jmp    80ccbb <tcp_parseopt+0x9b>
      } else {
        if (opts[c + 1] == 0) {
  80cc87:	8a 44 16 01          	mov    0x1(%esi,%edx,1),%al
  80cc8b:	84 c0                	test   %al,%al
  80cc8d:	74 2c                	je     80ccbb <tcp_parseopt+0x9b>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80cc8f:	01 c3                	add    %eax,%ebx
  80cc91:	eb 02                	jmp    80cc95 <tcp_parseopt+0x75>
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cc93:	b3 00                	mov    $0x0,%bl
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80cc95:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80cc9a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc9e:	89 04 24             	mov    %eax,(%esp)
  80cca1:	e8 e3 af ff ff       	call   807c89 <ntohs>
  80cca6:	0f b6 d3             	movzbl %bl,%edx
  80cca9:	66 c1 e8 0c          	shr    $0xc,%ax
  80ccad:	0f b7 c0             	movzwl %ax,%eax
  80ccb0:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80ccb7:	39 c2                	cmp    %eax,%edx
  80ccb9:	7c 8c                	jl     80cc47 <tcp_parseopt+0x27>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ccbb:	83 c4 1c             	add    $0x1c,%esp
  80ccbe:	5b                   	pop    %ebx
  80ccbf:	5e                   	pop    %esi
  80ccc0:	5f                   	pop    %edi
  80ccc1:	5d                   	pop    %ebp
  80ccc2:	c3                   	ret    

0080ccc3 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ccc3:	55                   	push   %ebp
  80ccc4:	89 e5                	mov    %esp,%ebp
  80ccc6:	57                   	push   %edi
  80ccc7:	56                   	push   %esi
  80ccc8:	53                   	push   %ebx
  80ccc9:	83 ec 2c             	sub    $0x2c,%esp
  80cccc:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ccce:	f6 05 ec b1 b3 00 10 	testb  $0x10,0xb3b1ec
  80ccd5:	0f 84 41 04 00 00    	je     80d11c <tcp_receive+0x459>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ccdb:	8b 70 5c             	mov    0x5c(%eax),%esi
  80ccde:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80cce1:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80cce6:	39 c2                	cmp    %eax,%edx
  80cce8:	78 26                	js     80cd10 <tcp_receive+0x4d>
  80ccea:	39 c2                	cmp    %eax,%edx
  80ccec:	75 0b                	jne    80ccf9 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ccee:	8b 0d e8 b1 b3 00    	mov    0xb3b1e8,%ecx
  80ccf4:	39 4b 64             	cmp    %ecx,0x64(%ebx)
  80ccf7:	78 17                	js     80cd10 <tcp_receive+0x4d>
  80ccf9:	8b 3d e8 b1 b3 00    	mov    0xb3b1e8,%edi
  80ccff:	39 7b 64             	cmp    %edi,0x64(%ebx)
  80cd02:	75 3a                	jne    80cd3e <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80cd04:	8b 0d e0 b1 b3 00    	mov    0xb3b1e0,%ecx
  80cd0a:	66 3b 71 0e          	cmp    0xe(%ecx),%si
  80cd0e:	73 2e                	jae    80cd3e <tcp_receive+0x7b>
      pcb->snd_wnd = tcphdr->wnd;
  80cd10:	8b 0d e0 b1 b3 00    	mov    0xb3b1e0,%ecx
  80cd16:	66 8b 49 0e          	mov    0xe(%ecx),%cx
  80cd1a:	66 89 4b 5c          	mov    %cx,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80cd1e:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80cd21:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80cd26:	89 43 64             	mov    %eax,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80cd29:	66 85 c9             	test   %cx,%cx
  80cd2c:	74 10                	je     80cd3e <tcp_receive+0x7b>
  80cd2e:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80cd35:	74 07                	je     80cd3e <tcp_receive+0x7b>
          pcb->persist_backoff = 0;
  80cd37:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80cd3e:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80cd41:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80cd46:	39 c1                	cmp    %eax,%ecx
  80cd48:	0f 85 a2 00 00 00    	jne    80cdf0 <tcp_receive+0x12d>
      pcb->acked = 0;
  80cd4e:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cd54:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80cd58:	03 43 60             	add    0x60(%ebx),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cd5b:	0f b7 f6             	movzwl %si,%esi
  80cd5e:	01 f2                	add    %esi,%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cd60:	39 d0                	cmp    %edx,%eax
  80cd62:	0f 85 e3 02 00 00    	jne    80d04b <tcp_receive+0x388>
        ++pcb->dupacks;
  80cd68:	8a 43 4c             	mov    0x4c(%ebx),%al
  80cd6b:	40                   	inc    %eax
  80cd6c:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80cd6f:	3c 02                	cmp    $0x2,%al
  80cd71:	0f 86 d4 02 00 00    	jbe    80d04b <tcp_receive+0x388>
  80cd77:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80cd7b:	0f 84 ca 02 00 00    	je     80d04b <tcp_receive+0x388>
          if (!(pcb->flags & TF_INFR)) {
  80cd81:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80cd85:	75 4e                	jne    80cdd5 <tcp_receive+0x112>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80cd87:	89 1c 24             	mov    %ebx,(%esp)
  80cd8a:	e8 0e bf ff ff       	call   808c9d <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80cd8f:	66 8b 43 4e          	mov    0x4e(%ebx),%ax
  80cd93:	8b 53 5c             	mov    0x5c(%ebx),%edx
  80cd96:	66 39 d0             	cmp    %dx,%ax
  80cd99:	76 09                	jbe    80cda4 <tcp_receive+0xe1>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80cd9b:	66 d1 ea             	shr    %dx
  80cd9e:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80cda2:	eb 07                	jmp    80cdab <tcp_receive+0xe8>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80cda4:	66 d1 e8             	shr    %ax
  80cda7:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80cdab:	8b 43 34             	mov    0x34(%ebx),%eax
  80cdae:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80cdb2:	0f b7 d0             	movzwl %ax,%edx
  80cdb5:	d1 e2                	shl    %edx
  80cdb7:	39 d1                	cmp    %edx,%ecx
  80cdb9:	7d 07                	jge    80cdc2 <tcp_receive+0xff>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80cdbb:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80cdbe:	66 89 53 50          	mov    %dx,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80cdc2:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80cdc5:	03 43 50             	add    0x50(%ebx),%eax
  80cdc8:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80cdcc:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80cdd0:	e9 76 02 00 00       	jmp    80d04b <tcp_receive+0x388>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cdd5:	66 8b 53 4e          	mov    0x4e(%ebx),%dx
  80cdd9:	89 d0                	mov    %edx,%eax
  80cddb:	03 43 34             	add    0x34(%ebx),%eax
  80cdde:	66 39 c2             	cmp    %ax,%dx
  80cde1:	0f 83 64 02 00 00    	jae    80d04b <tcp_receive+0x388>
              pcb->cwnd += pcb->mss;
  80cde7:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80cdeb:	e9 5b 02 00 00       	jmp    80d04b <tcp_receive+0x388>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80cdf0:	89 ca                	mov    %ecx,%edx
  80cdf2:	f7 d2                	not    %edx
  80cdf4:	01 c2                	add    %eax,%edx
  80cdf6:	0f 88 a2 01 00 00    	js     80cf9e <tcp_receive+0x2db>
  80cdfc:	89 c2                	mov    %eax,%edx
  80cdfe:	2b 53 58             	sub    0x58(%ebx),%edx
  80ce01:	85 d2                	test   %edx,%edx
  80ce03:	0f 8f 95 01 00 00    	jg     80cf9e <tcp_receive+0x2db>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80ce09:	8a 53 20             	mov    0x20(%ebx),%dl
  80ce0c:	f6 c2 04             	test   $0x4,%dl
  80ce0f:	74 0d                	je     80ce1e <tcp_receive+0x15b>
        pcb->flags &= ~TF_INFR;
  80ce11:	83 e2 fb             	and    $0xfffffffb,%edx
  80ce14:	88 53 20             	mov    %dl,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80ce17:	8b 53 50             	mov    0x50(%ebx),%edx
  80ce1a:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80ce1e:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80ce22:	8b 53 40             	mov    0x40(%ebx),%edx
  80ce25:	66 c1 fa 03          	sar    $0x3,%dx
  80ce29:	66 03 53 42          	add    0x42(%ebx),%dx
  80ce2d:	66 89 53 44          	mov    %dx,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80ce31:	89 c2                	mov    %eax,%edx
  80ce33:	66 29 ca             	sub    %cx,%dx
  80ce36:	66 89 53 6c          	mov    %dx,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  80ce3a:	66 01 53 6e          	add    %dx,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80ce3e:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  80ce42:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80ce45:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  80ce49:	0f 86 cb 00 00 00    	jbe    80cf1a <tcp_receive+0x257>
        if (pcb->cwnd < pcb->ssthresh) {
  80ce4f:	66 8b 4b 4e          	mov    0x4e(%ebx),%cx
  80ce53:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  80ce57:	73 17                	jae    80ce70 <tcp_receive+0x1ad>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80ce59:	89 c8                	mov    %ecx,%eax
  80ce5b:	03 43 34             	add    0x34(%ebx),%eax
  80ce5e:	66 39 c1             	cmp    %ax,%cx
  80ce61:	0f 83 b3 00 00 00    	jae    80cf1a <tcp_receive+0x257>
            pcb->cwnd += pcb->mss;
  80ce67:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80ce6b:	e9 aa 00 00 00       	jmp    80cf1a <tcp_receive+0x257>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80ce70:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80ce74:	0f af c0             	imul   %eax,%eax
  80ce77:	0f b7 f1             	movzwl %cx,%esi
  80ce7a:	99                   	cltd   
  80ce7b:	f7 fe                	idiv   %esi
  80ce7d:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80ce7f:	66 39 c1             	cmp    %ax,%cx
  80ce82:	0f 83 92 00 00 00    	jae    80cf1a <tcp_receive+0x257>
            pcb->cwnd = new_cwnd;
  80ce88:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80ce8c:	e9 89 00 00 00       	jmp    80cf1a <tcp_receive+0x257>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80ce91:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  80ce94:	8b 06                	mov    (%esi),%eax
  80ce96:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80ce99:	8b 7b 70             	mov    0x70(%ebx),%edi
  80ce9c:	8b 46 04             	mov    0x4(%esi),%eax
  80ce9f:	89 04 24             	mov    %eax,(%esp)
  80cea2:	e8 55 83 ff ff       	call   8051fc <pbuf_clen>
  80cea7:	0f b6 c0             	movzbl %al,%eax
  80ceaa:	66 39 c7             	cmp    %ax,%di
  80cead:	73 1c                	jae    80cecb <tcp_receive+0x208>
  80ceaf:	c7 44 24 08 54 2c 81 	movl   $0x812c54,0x8(%esp)
  80ceb6:	00 
  80ceb7:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80cebe:	00 
  80cebf:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80cec6:	e8 ad 1f 00 00       	call   80ee78 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80cecb:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cece:	8b 46 04             	mov    0x4(%esi),%eax
  80ced1:	89 04 24             	mov    %eax,(%esp)
  80ced4:	e8 23 83 ff ff       	call   8051fc <pbuf_clen>
  80ced9:	0f b6 c0             	movzbl %al,%eax
  80cedc:	66 29 c7             	sub    %ax,%di
  80cedf:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  80cee3:	89 34 24             	mov    %esi,(%esp)
  80cee6:	e8 fe 8d ff ff       	call   805ce9 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80ceeb:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80cef0:	74 28                	je     80cf1a <tcp_receive+0x257>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80cef2:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80cef6:	75 22                	jne    80cf1a <tcp_receive+0x257>
  80cef8:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80cefc:	75 1c                	jne    80cf1a <tcp_receive+0x257>
  80cefe:	c7 44 24 08 7c 2c 81 	movl   $0x812c7c,0x8(%esp)
  80cf05:	00 
  80cf06:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80cf0d:	00 
  80cf0e:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80cf15:	e8 5e 1f 00 00       	call   80ee78 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80cf1a:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf1d:	85 c0                	test   %eax,%eax
  80cf1f:	74 6b                	je     80cf8c <tcp_receive+0x2c9>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80cf21:	8b 40 10             	mov    0x10(%eax),%eax
  80cf24:	8b 40 04             	mov    0x4(%eax),%eax
  80cf27:	89 04 24             	mov    %eax,(%esp)
  80cf2a:	e8 c4 af ff ff       	call   807ef3 <ntohl>
  80cf2f:	89 c6                	mov    %eax,%esi
  80cf31:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf34:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80cf38:	8b 40 10             	mov    0x10(%eax),%eax
  80cf3b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf3f:	89 04 24             	mov    %eax,(%esp)
  80cf42:	e8 42 ad ff ff       	call   807c89 <ntohs>
  80cf47:	a8 01                	test   $0x1,%al
  80cf49:	75 1d                	jne    80cf68 <tcp_receive+0x2a5>
  80cf4b:	8b 43 78             	mov    0x78(%ebx),%eax
  80cf4e:	8b 40 10             	mov    0x10(%eax),%eax
  80cf51:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf55:	89 04 24             	mov    %eax,(%esp)
  80cf58:	e8 2c ad ff ff       	call   807c89 <ntohs>
  80cf5d:	83 e0 02             	and    $0x2,%eax
  80cf60:	0f 95 c0             	setne  %al
  80cf63:	0f b6 c0             	movzbl %al,%eax
  80cf66:	eb 05                	jmp    80cf6d <tcp_receive+0x2aa>
  80cf68:	b8 01 00 00 00       	mov    $0x1,%eax
  80cf6d:	2b 35 e8 b1 b3 00    	sub    0xb3b1e8,%esi
  80cf73:	01 c7                	add    %eax,%edi
  80cf75:	01 fe                	add    %edi,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80cf77:	85 f6                	test   %esi,%esi
  80cf79:	0f 8e 12 ff ff ff    	jle    80ce91 <tcp_receive+0x1ce>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
  80cf7f:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80cf83:	0f 95 c0             	setne  %al
  80cf86:	0f b6 c0             	movzbl %al,%eax
  80cf89:	48                   	dec    %eax
  80cf8a:	eb 05                	jmp    80cf91 <tcp_receive+0x2ce>
  80cf8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80cf91:	66 89 43 32          	mov    %ax,0x32(%ebx)
        pcb->rtime = -1;
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
  80cf95:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
  80cf99:	e9 ad 00 00 00       	jmp    80d04b <tcp_receive+0x388>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80cf9e:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  80cfa4:	e9 a2 00 00 00       	jmp    80d04b <tcp_receive+0x388>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80cfa9:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  80cfac:	8b 06                	mov    (%esi),%eax
  80cfae:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80cfb1:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cfb4:	8b 46 04             	mov    0x4(%esi),%eax
  80cfb7:	89 04 24             	mov    %eax,(%esp)
  80cfba:	e8 3d 82 ff ff       	call   8051fc <pbuf_clen>
  80cfbf:	0f b6 c0             	movzbl %al,%eax
  80cfc2:	66 39 c7             	cmp    %ax,%di
  80cfc5:	73 1c                	jae    80cfe3 <tcp_receive+0x320>
  80cfc7:	c7 44 24 08 54 2c 81 	movl   $0x812c54,0x8(%esp)
  80cfce:	00 
  80cfcf:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80cfd6:	00 
  80cfd7:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80cfde:	e8 95 1e 00 00       	call   80ee78 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80cfe3:	8b 7b 70             	mov    0x70(%ebx),%edi
  80cfe6:	8b 46 04             	mov    0x4(%esi),%eax
  80cfe9:	89 04 24             	mov    %eax,(%esp)
  80cfec:	e8 0b 82 ff ff       	call   8051fc <pbuf_clen>
  80cff1:	0f b6 c0             	movzbl %al,%eax
  80cff4:	66 29 c7             	sub    %ax,%di
  80cff7:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  80cffb:	89 34 24             	mov    %esi,(%esp)
  80cffe:	e8 e6 8c ff ff       	call   805ce9 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80d003:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80d008:	74 29                	je     80d033 <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80d00a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80d00e:	75 23                	jne    80d033 <tcp_receive+0x370>
  80d010:	8b 43 74             	mov    0x74(%ebx),%eax
  80d013:	85 c0                	test   %eax,%eax
  80d015:	75 23                	jne    80d03a <tcp_receive+0x377>
  80d017:	c7 44 24 08 7c 2c 81 	movl   $0x812c7c,0x8(%esp)
  80d01e:	00 
  80d01f:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d026:	00 
  80d027:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d02e:	e8 45 1e 00 00       	call   80ee78 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d033:	8b 43 74             	mov    0x74(%ebx),%eax
  80d036:	85 c0                	test   %eax,%eax
  80d038:	74 11                	je     80d04b <tcp_receive+0x388>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d03a:	8b 40 10             	mov    0x10(%eax),%eax
  80d03d:	8b 40 04             	mov    0x4(%eax),%eax
  80d040:	89 04 24             	mov    %eax,(%esp)
  80d043:	e8 55 ac ff ff       	call   807c9d <htonl>
  80d048:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d04b:	8b 43 74             	mov    0x74(%ebx),%eax
  80d04e:	85 c0                	test   %eax,%eax
  80d050:	74 6e                	je     80d0c0 <tcp_receive+0x3fd>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d052:	8b 35 e8 b1 b3 00    	mov    0xb3b1e8,%esi
  80d058:	8b 40 10             	mov    0x10(%eax),%eax
  80d05b:	8b 40 04             	mov    0x4(%eax),%eax
  80d05e:	89 04 24             	mov    %eax,(%esp)
  80d061:	e8 8d ae ff ff       	call   807ef3 <ntohl>
  80d066:	89 c7                	mov    %eax,%edi
  80d068:	8b 43 74             	mov    0x74(%ebx),%eax
  80d06b:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80d06f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d072:	8b 40 10             	mov    0x10(%eax),%eax
  80d075:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d079:	89 04 24             	mov    %eax,(%esp)
  80d07c:	e8 08 ac ff ff       	call   807c89 <ntohs>
  80d081:	a8 01                	test   $0x1,%al
  80d083:	75 1d                	jne    80d0a2 <tcp_receive+0x3df>
  80d085:	8b 43 74             	mov    0x74(%ebx),%eax
  80d088:	8b 40 10             	mov    0x10(%eax),%eax
  80d08b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d08f:	89 04 24             	mov    %eax,(%esp)
  80d092:	e8 f2 ab ff ff       	call   807c89 <ntohs>
  80d097:	83 e0 02             	and    $0x2,%eax
  80d09a:	0f 95 c0             	setne  %al
  80d09d:	0f b6 c0             	movzbl %al,%eax
  80d0a0:	eb 05                	jmp    80d0a7 <tcp_receive+0x3e4>
  80d0a2:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0a7:	29 fe                	sub    %edi,%esi
  80d0a9:	03 45 e4             	add    -0x1c(%ebp),%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d0ac:	39 c6                	cmp    %eax,%esi
  80d0ae:	78 10                	js     80d0c0 <tcp_receive+0x3fd>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d0b0:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80d0b5:	2b 43 58             	sub    0x58(%ebx),%eax
  80d0b8:	85 c0                	test   %eax,%eax
  80d0ba:	0f 8e e9 fe ff ff    	jle    80cfa9 <tcp_receive+0x2e6>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d0c0:	8b 43 38             	mov    0x38(%ebx),%eax
  80d0c3:	85 c0                	test   %eax,%eax
  80d0c5:	74 55                	je     80d11c <tcp_receive+0x459>
  80d0c7:	8b 0d e8 b1 b3 00    	mov    0xb3b1e8,%ecx
  80d0cd:	39 4b 3c             	cmp    %ecx,0x3c(%ebx)
  80d0d0:	79 4a                	jns    80d11c <tcp_receive+0x459>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d0d2:	8b 53 40             	mov    0x40(%ebx),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80d0d5:	8b 0d 80 b2 b3 00    	mov    0xb3b280,%ecx
  80d0db:	66 29 c1             	sub    %ax,%cx
  80d0de:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d0e0:	89 d1                	mov    %edx,%ecx
  80d0e2:	66 c1 f9 03          	sar    $0x3,%cx
  80d0e6:	66 29 c8             	sub    %cx,%ax
  80d0e9:	89 c1                	mov    %eax,%ecx
      pcb->sa += m;
  80d0eb:	01 c2                	add    %eax,%edx
  80d0ed:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
  80d0f1:	66 85 c0             	test   %ax,%ax
  80d0f4:	79 02                	jns    80d0f8 <tcp_receive+0x435>
        m = -m;
  80d0f6:	f7 d9                	neg    %ecx
      }
      m = m - (pcb->sv >> 2);
  80d0f8:	66 8b 43 42          	mov    0x42(%ebx),%ax
  80d0fc:	89 c6                	mov    %eax,%esi
  80d0fe:	66 c1 fe 02          	sar    $0x2,%si
  80d102:	66 29 f0             	sub    %si,%ax
      pcb->sv += m;
  80d105:	01 c8                	add    %ecx,%eax
  80d107:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d10b:	66 c1 fa 03          	sar    $0x3,%dx
  80d10f:	01 d0                	add    %edx,%eax
  80d111:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d115:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d11c:	66 8b 0d ee b1 b3 00 	mov    0xb3b1ee,%cx
  80d123:	66 85 c9             	test   %cx,%cx
  80d126:	0f 84 39 07 00 00    	je     80d865 <tcp_receive+0xba2>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d12c:	8b 53 24             	mov    0x24(%ebx),%edx
  80d12f:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80d134:	89 c6                	mov    %eax,%esi
  80d136:	f7 d6                	not    %esi
  80d138:	01 d6                	add    %edx,%esi
  80d13a:	0f 88 3a 01 00 00    	js     80d27a <tcp_receive+0x5b7>
  80d140:	8d 7a 01             	lea    0x1(%edx),%edi
  80d143:	29 c7                	sub    %eax,%edi
  80d145:	0f b7 f1             	movzwl %cx,%esi
  80d148:	89 f9                	mov    %edi,%ecx
  80d14a:	29 f1                	sub    %esi,%ecx
  80d14c:	85 c9                	test   %ecx,%ecx
  80d14e:	0f 8f 26 01 00 00    	jg     80d27a <tcp_receive+0x5b7>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80d154:	8b 35 f4 b1 b3 00    	mov    0xb3b1f4,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d15a:	85 f6                	test   %esi,%esi
  80d15c:	75 1c                	jne    80d17a <tcp_receive+0x4b7>
  80d15e:	c7 44 24 08 d7 2d 81 	movl   $0x812dd7,0x8(%esp)
  80d165:	00 
  80d166:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d16d:	00 
  80d16e:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d175:	e8 fe 1c 00 00       	call   80ee78 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d17a:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d17c:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80d182:	7e 1c                	jle    80d1a0 <tcp_receive+0x4dd>
  80d184:	c7 44 24 08 e7 2d 81 	movl   $0x812de7,0x8(%esp)
  80d18b:	00 
  80d18c:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d193:	00 
  80d194:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d19b:	e8 d8 1c 00 00       	call   80ee78 <_panic>
      if (inseg.p->len < off) {
  80d1a0:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d1a4:	39 c2                	cmp    %eax,%edx
  80d1a6:	7e 70                	jle    80d218 <tcp_receive+0x555>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d1a8:	8b 4e 08             	mov    0x8(%esi),%ecx
  80d1ab:	0f b7 f9             	movzwl %cx,%edi
  80d1ae:	39 fa                	cmp    %edi,%edx
  80d1b0:	7e 1c                	jle    80d1ce <tcp_receive+0x50b>
  80d1b2:	c7 44 24 08 f6 2d 81 	movl   $0x812df6,0x8(%esp)
  80d1b9:	00 
  80d1ba:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d1c1:	00 
  80d1c2:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d1c9:	e8 aa 1c 00 00       	call   80ee78 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d1ce:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  80d1d1:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d1d3:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  80d1d7:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  80d1dd:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d1df:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80d1e3:	39 d0                	cmp    %edx,%eax
  80d1e5:	7c ea                	jl     80d1d1 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d1e7:	f7 da                	neg    %edx
  80d1e9:	0f bf c2             	movswl %dx,%eax
  80d1ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d1f0:	89 34 24             	mov    %esi,(%esp)
  80d1f3:	e8 98 7a ff ff       	call   804c90 <pbuf_header>
  80d1f8:	84 c0                	test   %al,%al
  80d1fa:	74 4d                	je     80d249 <tcp_receive+0x586>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d1fc:	c7 44 24 08 06 2e 81 	movl   $0x812e06,0x8(%esp)
  80d203:	00 
  80d204:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d20b:	00 
  80d20c:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d213:	e8 60 1c 00 00       	call   80ee78 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d218:	f7 da                	neg    %edx
  80d21a:	0f bf c2             	movswl %dx,%eax
  80d21d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d221:	89 34 24             	mov    %esi,(%esp)
  80d224:	e8 67 7a ff ff       	call   804c90 <pbuf_header>
  80d229:	84 c0                	test   %al,%al
  80d22b:	74 1c                	je     80d249 <tcp_receive+0x586>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d22d:	c7 44 24 08 06 2e 81 	movl   $0x812e06,0x8(%esp)
  80d234:	00 
  80d235:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d23c:	00 
  80d23d:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80d244:	e8 2f 1c 00 00       	call   80ee78 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d249:	8b 46 04             	mov    0x4(%esi),%eax
  80d24c:	a3 f8 b1 b3 00       	mov    %eax,0xb3b1f8
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d251:	8b 43 24             	mov    0x24(%ebx),%eax
  80d254:	8b 15 e4 b1 b3 00    	mov    0xb3b1e4,%edx
  80d25a:	03 15 fc b1 b3 00    	add    0xb3b1fc,%edx
  80d260:	66 29 c2             	sub    %ax,%dx
  80d263:	66 89 15 fc b1 b3 00 	mov    %dx,0xb3b1fc
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d26a:	a3 e4 b1 b3 00       	mov    %eax,0xb3b1e4
  80d26f:	8b 15 00 b2 b3 00    	mov    0xb3b200,%edx
  80d275:	89 42 04             	mov    %eax,0x4(%edx)
  80d278:	eb 10                	jmp    80d28a <tcp_receive+0x5c7>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d27a:	39 d0                	cmp    %edx,%eax
  80d27c:	79 1c                	jns    80d29a <tcp_receive+0x5d7>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d27e:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d282:	89 1c 24             	mov    %ebx,(%esp)
  80d285:	e8 d8 b3 ff ff       	call   808662 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d28a:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80d28f:	8b 53 24             	mov    0x24(%ebx),%edx
  80d292:	39 d0                	cmp    %edx,%eax
  80d294:	0f 88 bb 05 00 00    	js     80d855 <tcp_receive+0xb92>
  80d29a:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d29e:	89 c6                	mov    %eax,%esi
  80d2a0:	29 ce                	sub    %ecx,%esi
  80d2a2:	8d 4e 01             	lea    0x1(%esi),%ecx
  80d2a5:	29 d1                	sub    %edx,%ecx
  80d2a7:	85 c9                	test   %ecx,%ecx
  80d2a9:	0f 8f a6 05 00 00    	jg     80d855 <tcp_receive+0xb92>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d2af:	39 d0                	cmp    %edx,%eax
  80d2b1:	0f 85 6b 03 00 00    	jne    80d622 <tcp_receive+0x95f>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d2b7:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80d2ba:	85 d2                	test   %edx,%edx
  80d2bc:	0f 84 87 00 00 00    	je     80d349 <tcp_receive+0x686>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d2c2:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d2c5:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d2c8:	0f b7 35 fc b1 b3 00 	movzwl 0xb3b1fc,%esi
  80d2cf:	89 cf                	mov    %ecx,%edi
  80d2d1:	29 f7                	sub    %esi,%edi
  80d2d3:	89 fe                	mov    %edi,%esi
  80d2d5:	29 c6                	sub    %eax,%esi
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d2d7:	85 f6                	test   %esi,%esi
  80d2d9:	7f 6e                	jg     80d349 <tcp_receive+0x686>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d2db:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d2e0:	74 20                	je     80d302 <tcp_receive+0x63f>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d2e2:	66 29 c1             	sub    %ax,%cx
  80d2e5:	66 89 0d fc b1 b3 00 	mov    %cx,0xb3b1fc
            pbuf_realloc(inseg.p, inseg.len);
  80d2ec:	0f b7 c9             	movzwl %cx,%ecx
  80d2ef:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80d2f3:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80d2f8:	89 04 24             	mov    %eax,(%esp)
  80d2fb:	e8 47 7b ff ff       	call   804e47 <pbuf_realloc>
  80d300:	eb 47                	jmp    80d349 <tcp_receive+0x686>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d302:	a1 00 b2 b3 00       	mov    0xb3b200,%eax
  80d307:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d30b:	89 04 24             	mov    %eax,(%esp)
  80d30e:	e8 76 a9 ff ff       	call   807c89 <ntohs>
  80d313:	89 c6                	mov    %eax,%esi
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80d315:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80d318:	8b 40 10             	mov    0x10(%eax),%eax
  80d31b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d31f:	89 04 24             	mov    %eax,(%esp)
  80d322:	e8 62 a9 ff ff       	call   807c89 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d327:	31 c6                	xor    %eax,%esi
  80d329:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80d32f:	75 18                	jne    80d349 <tcp_receive+0x686>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d331:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d334:	8b 10                	mov    (%eax),%edx
  80d336:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d339:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d33d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d344:	e8 a1 76 ff ff       	call   8049ea <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d349:	8b 35 fc b1 b3 00    	mov    0xb3b1fc,%esi
  80d34f:	a1 00 b2 b3 00       	mov    0xb3b200,%eax
  80d354:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d358:	89 04 24             	mov    %eax,(%esp)
  80d35b:	e8 29 a9 ff ff       	call   807c89 <ntohs>
  80d360:	a8 01                	test   $0x1,%al
  80d362:	75 1c                	jne    80d380 <tcp_receive+0x6bd>
  80d364:	a1 00 b2 b3 00       	mov    0xb3b200,%eax
  80d369:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d36d:	89 04 24             	mov    %eax,(%esp)
  80d370:	e8 14 a9 ff ff       	call   807c89 <ntohs>
  80d375:	83 e0 02             	and    $0x2,%eax
  80d378:	0f 95 c0             	setne  %al
  80d37b:	0f b6 c0             	movzbl %al,%eax
  80d37e:	eb 05                	jmp    80d385 <tcp_receive+0x6c2>
  80d380:	b8 01 00 00 00       	mov    $0x1,%eax
  80d385:	01 c6                	add    %eax,%esi
  80d387:	66 89 35 ee b1 b3 00 	mov    %si,0xb3b1ee

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d38e:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80d392:	74 06                	je     80d39a <tcp_receive+0x6d7>
          pcb->rcv_nxt += tcplen;
  80d394:	0f b7 c6             	movzwl %si,%eax
  80d397:	01 43 24             	add    %eax,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d39a:	8b 43 28             	mov    0x28(%ebx),%eax
  80d39d:	66 39 c6             	cmp    %ax,%si
  80d3a0:	76 08                	jbe    80d3aa <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80d3a2:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  80d3a8:	eb 07                	jmp    80d3b1 <tcp_receive+0x6ee>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d3aa:	66 29 f0             	sub    %si,%ax
  80d3ad:	66 89 43 28          	mov    %ax,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d3b1:	66 8b 43 2a          	mov    0x2a(%ebx),%ax
  80d3b5:	66 39 c6             	cmp    %ax,%si
  80d3b8:	76 08                	jbe    80d3c2 <tcp_receive+0x6ff>
          pcb->rcv_ann_wnd = 0;
  80d3ba:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  80d3c0:	eb 07                	jmp    80d3c9 <tcp_receive+0x706>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d3c2:	66 29 f0             	sub    %si,%ax
  80d3c5:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d3c9:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80d3ce:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d3d3:	74 0f                	je     80d3e4 <tcp_receive+0x721>
          recv_data = inseg.p;
  80d3d5:	a3 04 b2 b3 00       	mov    %eax,0xb3b204
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d3da:	c7 05 f4 b1 b3 00 00 	movl   $0x0,0xb3b1f4
  80d3e1:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d3e4:	a1 00 b2 b3 00       	mov    0xb3b200,%eax
  80d3e9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d3ed:	89 04 24             	mov    %eax,(%esp)
  80d3f0:	e8 94 a8 ff ff       	call   807c89 <ntohs>
  80d3f5:	a8 01                	test   $0x1,%al
  80d3f7:	0f 84 df 01 00 00    	je     80d5dc <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d3fd:	c6 05 08 b2 b3 00 20 	movb   $0x20,0xb3b208
  80d404:	89 de                	mov    %ebx,%esi
  80d406:	e9 d3 01 00 00       	jmp    80d5de <tcp_receive+0x91b>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d40b:	a3 e4 b1 b3 00       	mov    %eax,0xb3b1e4

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d410:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d414:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d417:	8b 43 10             	mov    0x10(%ebx),%eax
  80d41a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d41e:	89 04 24             	mov    %eax,(%esp)
  80d421:	e8 63 a8 ff ff       	call   807c89 <ntohs>
  80d426:	a8 01                	test   $0x1,%al
  80d428:	75 1a                	jne    80d444 <tcp_receive+0x781>
  80d42a:	8b 43 10             	mov    0x10(%ebx),%eax
  80d42d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d431:	89 04 24             	mov    %eax,(%esp)
  80d434:	e8 50 a8 ff ff       	call   807c89 <ntohs>
  80d439:	83 e0 02             	and    $0x2,%eax
  80d43c:	0f 95 c0             	setne  %al
  80d43f:	0f b6 c0             	movzbl %al,%eax
  80d442:	eb 05                	jmp    80d449 <tcp_receive+0x786>
  80d444:	b8 01 00 00 00       	mov    $0x1,%eax
  80d449:	03 45 e4             	add    -0x1c(%ebp),%eax
  80d44c:	01 c7                	add    %eax,%edi
  80d44e:	89 7e 24             	mov    %edi,0x24(%esi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d451:	0f b7 7e 28          	movzwl 0x28(%esi),%edi
  80d455:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80d458:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d45c:	8b 43 10             	mov    0x10(%ebx),%eax
  80d45f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d463:	89 04 24             	mov    %eax,(%esp)
  80d466:	e8 1e a8 ff ff       	call   807c89 <ntohs>
  80d46b:	a8 01                	test   $0x1,%al
  80d46d:	75 1a                	jne    80d489 <tcp_receive+0x7c6>
  80d46f:	8b 43 10             	mov    0x10(%ebx),%eax
  80d472:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d476:	89 04 24             	mov    %eax,(%esp)
  80d479:	e8 0b a8 ff ff       	call   807c89 <ntohs>
  80d47e:	83 e0 02             	and    $0x2,%eax
  80d481:	0f 95 c0             	setne  %al
  80d484:	0f b6 c0             	movzbl %al,%eax
  80d487:	eb 05                	jmp    80d48e <tcp_receive+0x7cb>
  80d489:	b8 01 00 00 00       	mov    $0x1,%eax
  80d48e:	01 c7                	add    %eax,%edi
  80d490:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80d493:	7d 08                	jge    80d49d <tcp_receive+0x7da>
            pcb->rcv_wnd = 0;
  80d495:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  80d49b:	eb 47                	jmp    80d4e4 <tcp_receive+0x821>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d49d:	8b 7e 28             	mov    0x28(%esi),%edi
  80d4a0:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d4a3:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d4a7:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4aa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4ae:	89 04 24             	mov    %eax,(%esp)
  80d4b1:	e8 d3 a7 ff ff       	call   807c89 <ntohs>
  80d4b6:	a8 01                	test   $0x1,%al
  80d4b8:	75 1a                	jne    80d4d4 <tcp_receive+0x811>
  80d4ba:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4c1:	89 04 24             	mov    %eax,(%esp)
  80d4c4:	e8 c0 a7 ff ff       	call   807c89 <ntohs>
  80d4c9:	83 e0 02             	and    $0x2,%eax
  80d4cc:	0f 95 c0             	setne  %al
  80d4cf:	0f b6 c0             	movzbl %al,%eax
  80d4d2:	eb 05                	jmp    80d4d9 <tcp_receive+0x816>
  80d4d4:	b8 01 00 00 00       	mov    $0x1,%eax
  80d4d9:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d4dd:	66 29 c7             	sub    %ax,%di
  80d4e0:	66 89 7e 28          	mov    %di,0x28(%esi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d4e4:	0f b7 7e 2a          	movzwl 0x2a(%esi),%edi
  80d4e8:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80d4eb:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d4ef:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4f2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4f6:	89 04 24             	mov    %eax,(%esp)
  80d4f9:	e8 8b a7 ff ff       	call   807c89 <ntohs>
  80d4fe:	a8 01                	test   $0x1,%al
  80d500:	75 1a                	jne    80d51c <tcp_receive+0x859>
  80d502:	8b 43 10             	mov    0x10(%ebx),%eax
  80d505:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d509:	89 04 24             	mov    %eax,(%esp)
  80d50c:	e8 78 a7 ff ff       	call   807c89 <ntohs>
  80d511:	83 e0 02             	and    $0x2,%eax
  80d514:	0f 95 c0             	setne  %al
  80d517:	0f b6 c0             	movzbl %al,%eax
  80d51a:	eb 05                	jmp    80d521 <tcp_receive+0x85e>
  80d51c:	b8 01 00 00 00       	mov    $0x1,%eax
  80d521:	01 c7                	add    %eax,%edi
  80d523:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80d526:	7d 08                	jge    80d530 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80d528:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  80d52e:	eb 48                	jmp    80d578 <tcp_receive+0x8b5>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d530:	66 8b 7e 2a          	mov    0x2a(%esi),%di
  80d534:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d537:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d53b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d53e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d542:	89 04 24             	mov    %eax,(%esp)
  80d545:	e8 3f a7 ff ff       	call   807c89 <ntohs>
  80d54a:	a8 01                	test   $0x1,%al
  80d54c:	75 1a                	jne    80d568 <tcp_receive+0x8a5>
  80d54e:	8b 43 10             	mov    0x10(%ebx),%eax
  80d551:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d555:	89 04 24             	mov    %eax,(%esp)
  80d558:	e8 2c a7 ff ff       	call   807c89 <ntohs>
  80d55d:	83 e0 02             	and    $0x2,%eax
  80d560:	0f 95 c0             	setne  %al
  80d563:	0f b6 c0             	movzbl %al,%eax
  80d566:	eb 05                	jmp    80d56d <tcp_receive+0x8aa>
  80d568:	b8 01 00 00 00       	mov    $0x1,%eax
  80d56d:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  80d571:	66 29 c7             	sub    %ax,%di
  80d574:	66 89 7e 2a          	mov    %di,0x2a(%esi)
          }

          if (cseg->p->tot_len > 0) {
  80d578:	8b 43 04             	mov    0x4(%ebx),%eax
  80d57b:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d580:	74 24                	je     80d5a6 <tcp_receive+0x8e3>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d582:	8b 15 04 b2 b3 00    	mov    0xb3b204,%edx
  80d588:	85 d2                	test   %edx,%edx
  80d58a:	74 0e                	je     80d59a <tcp_receive+0x8d7>
              pbuf_cat(recv_data, cseg->p);
  80d58c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d590:	89 14 24             	mov    %edx,(%esp)
  80d593:	e8 87 7c ff ff       	call   80521f <pbuf_cat>
  80d598:	eb 05                	jmp    80d59f <tcp_receive+0x8dc>
            } else {
              recv_data = cseg->p;
  80d59a:	a3 04 b2 b3 00       	mov    %eax,0xb3b204
            }
            cseg->p = NULL;
  80d59f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d5a6:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5a9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5ad:	89 04 24             	mov    %eax,(%esp)
  80d5b0:	e8 d4 a6 ff ff       	call   807c89 <ntohs>
  80d5b5:	a8 01                	test   $0x1,%al
  80d5b7:	74 14                	je     80d5cd <tcp_receive+0x90a>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d5b9:	c6 05 08 b2 b3 00 20 	movb   $0x20,0xb3b208
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d5c0:	83 7e 10 04          	cmpl   $0x4,0x10(%esi)
  80d5c4:	75 07                	jne    80d5cd <tcp_receive+0x90a>
              pcb->state = CLOSE_WAIT;
  80d5c6:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d5cd:	8b 03                	mov    (%ebx),%eax
  80d5cf:	89 46 7c             	mov    %eax,0x7c(%esi)
          tcp_seg_free(cseg);
  80d5d2:	89 1c 24             	mov    %ebx,(%esp)
  80d5d5:	e8 0f 87 ff ff       	call   805ce9 <tcp_seg_free>
  80d5da:	eb 02                	jmp    80d5de <tcp_receive+0x91b>
  80d5dc:	89 de                	mov    %ebx,%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d5de:	8b 5e 7c             	mov    0x7c(%esi),%ebx
  80d5e1:	85 db                	test   %ebx,%ebx
  80d5e3:	74 11                	je     80d5f6 <tcp_receive+0x933>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d5e5:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5e8:	8b 40 04             	mov    0x4(%eax),%eax
  80d5eb:	8b 7e 24             	mov    0x24(%esi),%edi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d5ee:	39 f8                	cmp    %edi,%eax
  80d5f0:	0f 84 15 fe ff ff    	je     80d40b <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d5f6:	8a 46 20             	mov    0x20(%esi),%al
  80d5f9:	a8 01                	test   $0x1,%al
  80d5fb:	74 18                	je     80d615 <tcp_receive+0x952>
  80d5fd:	83 e0 fe             	and    $0xfffffffe,%eax
  80d600:	83 c8 02             	or     $0x2,%eax
  80d603:	88 46 20             	mov    %al,0x20(%esi)
  80d606:	89 34 24             	mov    %esi,(%esp)
  80d609:	e8 54 b0 ff ff       	call   808662 <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d60e:	b0 01                	mov    $0x1,%al
  80d610:	e9 a4 02 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d615:	83 c8 01             	or     $0x1,%eax
  80d618:	88 46 20             	mov    %al,0x20(%esi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d61b:	b0 01                	mov    $0x1,%al
  80d61d:	e9 97 02 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d622:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d626:	89 1c 24             	mov    %ebx,(%esp)
  80d629:	e8 34 b0 ff ff       	call   808662 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d62e:	8b 73 7c             	mov    0x7c(%ebx),%esi
  80d631:	85 f6                	test   %esi,%esi
  80d633:	75 16                	jne    80d64b <tcp_receive+0x988>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d635:	c7 04 24 f0 b1 b3 00 	movl   $0xb3b1f0,(%esp)
  80d63c:	e8 2a 87 ff ff       	call   805d6b <tcp_seg_copy>
  80d641:	89 43 7c             	mov    %eax,0x7c(%ebx)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d644:	b0 00                	mov    $0x0,%al
  80d646:	e9 6e 02 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d64b:	8b 0d e4 b1 b3 00    	mov    0xb3b1e4,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d651:	8d 41 01             	lea    0x1(%ecx),%eax

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  80d654:	bf 00 00 00 00       	mov    $0x0,%edi
  80d659:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80d65c:	89 c3                	mov    %eax,%ebx
  80d65e:	eb 04                	jmp    80d664 <tcp_receive+0x9a1>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d660:	89 f7                	mov    %esi,%edi
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  80d662:	89 d6                	mov    %edx,%esi
            if (seqno == next->tcphdr->seqno) {
  80d664:	8b 46 10             	mov    0x10(%esi),%eax
  80d667:	8b 40 04             	mov    0x4(%eax),%eax
  80d66a:	39 c8                	cmp    %ecx,%eax
  80d66c:	0f 85 93 00 00 00    	jne    80d705 <tcp_receive+0xa42>
  80d672:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d675:	8b 56 0c             	mov    0xc(%esi),%edx
  80d678:	66 39 15 fc b1 b3 00 	cmp    %dx,0xb3b1fc
  80d67f:	0f 86 0a 02 00 00    	jbe    80d88f <tcp_receive+0xbcc>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d685:	c7 04 24 f0 b1 b3 00 	movl   $0xb3b1f0,(%esp)
  80d68c:	e8 da 86 ff ff       	call   805d6b <tcp_seg_copy>
  80d691:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d694:	85 c0                	test   %eax,%eax
  80d696:	0f 84 f7 01 00 00    	je     80d893 <tcp_receive+0xbd0>
                  cseg->next = next->next;
  80d69c:	8b 06                	mov    (%esi),%eax
  80d69e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d6a1:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d6a3:	85 ff                	test   %edi,%edi
  80d6a5:	74 04                	je     80d6ab <tcp_receive+0x9e8>
                    prev->next = cseg;
  80d6a7:	89 0f                	mov    %ecx,(%edi)
  80d6a9:	eb 06                	jmp    80d6b1 <tcp_receive+0x9ee>
                  } else {
                    pcb->ooseq = cseg;
  80d6ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d6ae:	89 43 7c             	mov    %eax,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  80d6b1:	89 34 24             	mov    %esi,(%esp)
  80d6b4:	e8 30 86 ff ff       	call   805ce9 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d6b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d6bc:	8b 02                	mov    (%edx),%eax
  80d6be:	85 c0                	test   %eax,%eax
  80d6c0:	0f 84 d1 01 00 00    	je     80d897 <tcp_receive+0xbd4>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d6c6:	8b 15 e4 b1 b3 00    	mov    0xb3b1e4,%edx
  80d6cc:	8b 40 10             	mov    0x10(%eax),%eax
  80d6cf:	8b 40 04             	mov    0x4(%eax),%eax
  80d6d2:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80d6d5:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d6d9:	29 c1                	sub    %eax,%ecx
  80d6db:	01 d1                	add    %edx,%ecx
  80d6dd:	85 c9                	test   %ecx,%ecx
  80d6df:	0f 8e b6 01 00 00    	jle    80d89b <tcp_receive+0xbd8>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d6e5:	66 29 d0             	sub    %dx,%ax
  80d6e8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                      pbuf_realloc(cseg->p, cseg->len);
  80d6ec:	0f b7 c0             	movzwl %ax,%eax
  80d6ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d6f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80d6f6:	89 04 24             	mov    %eax,(%esp)
  80d6f9:	e8 49 77 ff ff       	call   804e47 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d6fe:	b0 00                	mov    $0x0,%al
  80d700:	e9 b4 01 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d705:	85 ff                	test   %edi,%edi
  80d707:	75 57                	jne    80d760 <tcp_receive+0xa9d>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d709:	39 c1                	cmp    %eax,%ecx
  80d70b:	0f 89 e6 00 00 00    	jns    80d7f7 <tcp_receive+0xb34>
  80d711:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d714:	0f b7 15 fc b1 b3 00 	movzwl 0xb3b1fc,%edx
  80d71b:	01 ca                	add    %ecx,%edx
  80d71d:	29 c2                	sub    %eax,%edx
  80d71f:	85 d2                	test   %edx,%edx
  80d721:	7e 1d                	jle    80d740 <tcp_receive+0xa7d>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d723:	66 29 c8             	sub    %cx,%ax
  80d726:	66 a3 fc b1 b3 00    	mov    %ax,0xb3b1fc
                    pbuf_realloc(inseg.p, inseg.len);
  80d72c:	0f b7 c0             	movzwl %ax,%eax
  80d72f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d733:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80d738:	89 04 24             	mov    %eax,(%esp)
  80d73b:	e8 07 77 ff ff       	call   804e47 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80d740:	c7 04 24 f0 b1 b3 00 	movl   $0xb3b1f0,(%esp)
  80d747:	e8 1f 86 ff ff       	call   805d6b <tcp_seg_copy>
                  if (cseg != NULL) {
  80d74c:	85 c0                	test   %eax,%eax
  80d74e:	0f 84 4b 01 00 00    	je     80d89f <tcp_receive+0xbdc>
                    cseg->next = next;
  80d754:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  80d756:	89 43 7c             	mov    %eax,0x7c(%ebx)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d759:	b0 00                	mov    $0x0,%al
  80d75b:	e9 59 01 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d760:	8b 57 10             	mov    0x10(%edi),%edx
  80d763:	8b 52 04             	mov    0x4(%edx),%edx
  80d766:	f7 d2                	not    %edx
  80d768:	01 ca                	add    %ecx,%edx
  80d76a:	0f 88 87 00 00 00    	js     80d7f7 <tcp_receive+0xb34>
  80d770:	89 da                	mov    %ebx,%edx
  80d772:	29 c2                	sub    %eax,%edx
  80d774:	85 d2                	test   %edx,%edx
  80d776:	7f 7f                	jg     80d7f7 <tcp_receive+0xb34>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d778:	0f b7 15 fc b1 b3 00 	movzwl 0xb3b1fc,%edx
  80d77f:	01 ca                	add    %ecx,%edx
  80d781:	29 c2                	sub    %eax,%edx
  80d783:	85 d2                	test   %edx,%edx
  80d785:	7e 1d                	jle    80d7a4 <tcp_receive+0xae1>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d787:	66 29 c8             	sub    %cx,%ax
  80d78a:	66 a3 fc b1 b3 00    	mov    %ax,0xb3b1fc
                  pbuf_realloc(inseg.p, inseg.len);
  80d790:	0f b7 c0             	movzwl %ax,%eax
  80d793:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d797:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80d79c:	89 04 24             	mov    %eax,(%esp)
  80d79f:	e8 a3 76 ff ff       	call   804e47 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80d7a4:	c7 04 24 f0 b1 b3 00 	movl   $0xb3b1f0,(%esp)
  80d7ab:	e8 bb 85 ff ff       	call   805d6b <tcp_seg_copy>
                if (cseg != NULL) {
  80d7b0:	85 c0                	test   %eax,%eax
  80d7b2:	0f 84 eb 00 00 00    	je     80d8a3 <tcp_receive+0xbe0>
                  cseg->next = next;
  80d7b8:	89 30                	mov    %esi,(%eax)
                  prev->next = cseg;
  80d7ba:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d7bc:	8b 47 10             	mov    0x10(%edi),%eax
  80d7bf:	8b 50 04             	mov    0x4(%eax),%edx
  80d7c2:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80d7c7:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  80d7cb:	29 c1                	sub    %eax,%ecx
  80d7cd:	01 d1                	add    %edx,%ecx
  80d7cf:	85 c9                	test   %ecx,%ecx
  80d7d1:	0f 8e d0 00 00 00    	jle    80d8a7 <tcp_receive+0xbe4>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d7d7:	66 29 d0             	sub    %dx,%ax
  80d7da:	66 89 47 0c          	mov    %ax,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  80d7de:	0f b7 c0             	movzwl %ax,%eax
  80d7e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d7e5:	8b 47 04             	mov    0x4(%edi),%eax
  80d7e8:	89 04 24             	mov    %eax,(%esp)
  80d7eb:	e8 57 76 ff ff       	call   804e47 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7f0:	b0 00                	mov    $0x0,%al
  80d7f2:	e9 c2 00 00 00       	jmp    80d8b9 <tcp_receive+0xbf6>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d7f7:	8b 16                	mov    (%esi),%edx
  80d7f9:	85 d2                	test   %edx,%edx
  80d7fb:	0f 85 5f fe ff ff    	jne    80d660 <tcp_receive+0x99d>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d801:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d803:	85 c9                	test   %ecx,%ecx
  80d805:	0f 8e a0 00 00 00    	jle    80d8ab <tcp_receive+0xbe8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80d80b:	c7 04 24 f0 b1 b3 00 	movl   $0xb3b1f0,(%esp)
  80d812:	e8 54 85 ff ff       	call   805d6b <tcp_seg_copy>
  80d817:	89 06                	mov    %eax,(%esi)
                if (next->next != NULL) {
  80d819:	85 c0                	test   %eax,%eax
  80d81b:	0f 84 8e 00 00 00    	je     80d8af <tcp_receive+0xbec>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d821:	8b 46 10             	mov    0x10(%esi),%eax
  80d824:	8b 50 04             	mov    0x4(%eax),%edx
  80d827:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80d82c:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80d830:	29 c1                	sub    %eax,%ecx
  80d832:	01 d1                	add    %edx,%ecx
  80d834:	85 c9                	test   %ecx,%ecx
  80d836:	7e 7b                	jle    80d8b3 <tcp_receive+0xbf0>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d838:	66 29 d0             	sub    %dx,%ax
  80d83b:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(next->p, next->len);
  80d83f:	0f b7 c0             	movzwl %ax,%eax
  80d842:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d846:	8b 46 04             	mov    0x4(%esi),%eax
  80d849:	89 04 24             	mov    %eax,(%esp)
  80d84c:	e8 f6 75 ff ff       	call   804e47 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d851:	b0 00                	mov    $0x0,%al
  80d853:	eb 64                	jmp    80d8b9 <tcp_receive+0xbf6>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80d855:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d859:	89 1c 24             	mov    %ebx,(%esp)
  80d85c:	e8 01 ae ff ff       	call   808662 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d861:	b0 00                	mov    $0x0,%al
  80d863:	eb 54                	jmp    80d8b9 <tcp_receive+0xbf6>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d865:	8b 15 e4 b1 b3 00    	mov    0xb3b1e4,%edx
  80d86b:	8b 43 24             	mov    0x24(%ebx),%eax
  80d86e:	39 c2                	cmp    %eax,%edx
  80d870:	78 0d                	js     80d87f <tcp_receive+0xbbc>
  80d872:	42                   	inc    %edx
  80d873:	29 c2                	sub    %eax,%edx
  80d875:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  80d879:	29 c2                	sub    %eax,%edx
  80d87b:	85 d2                	test   %edx,%edx
  80d87d:	7e 38                	jle    80d8b7 <tcp_receive+0xbf4>
      tcp_ack_now(pcb);
  80d87f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d883:	89 1c 24             	mov    %ebx,(%esp)
  80d886:	e8 d7 ad ff ff       	call   808662 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d88b:	b0 00                	mov    $0x0,%al
  80d88d:	eb 2a                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d88f:	b0 00                	mov    $0x0,%al
  80d891:	eb 26                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d893:	b0 00                	mov    $0x0,%al
  80d895:	eb 22                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d897:	b0 00                	mov    $0x0,%al
  80d899:	eb 1e                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d89b:	b0 00                	mov    $0x0,%al
  80d89d:	eb 1a                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d89f:	b0 00                	mov    $0x0,%al
  80d8a1:	eb 16                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8a3:	b0 00                	mov    $0x0,%al
  80d8a5:	eb 12                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8a7:	b0 00                	mov    $0x0,%al
  80d8a9:	eb 0e                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8ab:	b0 00                	mov    $0x0,%al
  80d8ad:	eb 0a                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8af:	b0 00                	mov    $0x0,%al
  80d8b1:	eb 06                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8b3:	b0 00                	mov    $0x0,%al
  80d8b5:	eb 02                	jmp    80d8b9 <tcp_receive+0xbf6>
  80d8b7:	b0 00                	mov    $0x0,%al
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80d8b9:	83 c4 2c             	add    $0x2c,%esp
  80d8bc:	5b                   	pop    %ebx
  80d8bd:	5e                   	pop    %esi
  80d8be:	5f                   	pop    %edi
  80d8bf:	5d                   	pop    %ebp
  80d8c0:	c3                   	ret    

0080d8c1 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80d8c1:	55                   	push   %ebp
  80d8c2:	89 e5                	mov    %esp,%ebp
  80d8c4:	57                   	push   %edi
  80d8c5:	56                   	push   %esi
  80d8c6:	53                   	push   %ebx
  80d8c7:	83 ec 4c             	sub    $0x4c,%esp
  80d8ca:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80d8cd:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d8d0:	89 1d dc b1 b3 00    	mov    %ebx,0xb3b1dc
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d8d6:	0f b7 03             	movzwl (%ebx),%eax
  80d8d9:	89 04 24             	mov    %eax,(%esp)
  80d8dc:	e8 a8 a3 ff ff       	call   807c89 <ntohs>
  80d8e1:	c1 e8 06             	shr    $0x6,%eax
  80d8e4:	83 e0 3c             	and    $0x3c,%eax
  80d8e7:	01 c3                	add    %eax,%ebx
  80d8e9:	89 1d e0 b1 b3 00    	mov    %ebx,0xb3b1e0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d8ef:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
  80d8f4:	0f b7 00             	movzwl (%eax),%eax
  80d8f7:	89 04 24             	mov    %eax,(%esp)
  80d8fa:	e8 8a a3 ff ff       	call   807c89 <ntohs>
  80d8ff:	66 c1 e8 06          	shr    $0x6,%ax
  80d903:	83 e0 3c             	and    $0x3c,%eax
  80d906:	f7 d8                	neg    %eax
  80d908:	98                   	cwtl   
  80d909:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d90d:	89 34 24             	mov    %esi,(%esp)
  80d910:	e8 7b 73 ff ff       	call   804c90 <pbuf_header>
  80d915:	84 c0                	test   %al,%al
  80d917:	75 07                	jne    80d920 <tcp_input+0x5f>
  80d919:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d91e:	77 0d                	ja     80d92d <tcp_input+0x6c>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d920:	89 34 24             	mov    %esi,(%esp)
  80d923:	e8 4d 74 ff ff       	call   804d75 <pbuf_free>
    return;
  80d928:	e9 b9 0c 00 00       	jmp    80e5e6 <tcp_input+0xd25>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d92d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d930:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d934:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
  80d939:	83 c0 10             	add    $0x10,%eax
  80d93c:	89 04 24             	mov    %eax,(%esp)
  80d93f:	e8 7c 90 ff ff       	call   8069c0 <ip_addr_isbroadcast>
  80d944:	84 c0                	test   %al,%al
  80d946:	75 26                	jne    80d96e <tcp_input+0xad>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d948:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
  80d94d:	8b 58 10             	mov    0x10(%eax),%ebx
  80d950:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d957:	e8 97 a5 ff ff       	call   807ef3 <ntohl>
  80d95c:	21 c3                	and    %eax,%ebx
  80d95e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d965:	e8 89 a5 ff ff       	call   807ef3 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d96a:	39 c3                	cmp    %eax,%ebx
  80d96c:	75 0d                	jne    80d97b <tcp_input+0xba>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d96e:	89 34 24             	mov    %esi,(%esp)
  80d971:	e8 ff 73 ff ff       	call   804d75 <pbuf_free>
    return;
  80d976:	e9 6b 0c 00 00       	jmp    80e5e6 <tcp_input+0xd25>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80d97b:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d980:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d984:	89 54 24 10          	mov    %edx,0x10(%esp)
  80d988:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d98f:	00 
  80d990:	8d 50 10             	lea    0x10(%eax),%edx
  80d993:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d997:	83 c0 0c             	add    $0xc,%eax
  80d99a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d99e:	89 34 24             	mov    %esi,(%esp)
  80d9a1:	e8 92 9f ff ff       	call   807938 <inet_chksum_pseudo>
  80d9a6:	66 85 c0             	test   %ax,%ax
  80d9a9:	74 0d                	je     80d9b8 <tcp_input+0xf7>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d9ab:	89 34 24             	mov    %esi,(%esp)
  80d9ae:	e8 c2 73 ff ff       	call   804d75 <pbuf_free>
    return;
  80d9b3:	e9 2e 0c 00 00       	jmp    80e5e6 <tcp_input+0xd25>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d9b8:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80d9bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d9c1:	89 04 24             	mov    %eax,(%esp)
  80d9c4:	e8 c0 a2 ff ff       	call   807c89 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d9c9:	66 c1 e8 0c          	shr    $0xc,%ax
  80d9cd:	f7 d8                	neg    %eax
  80d9cf:	c1 e0 02             	shl    $0x2,%eax
  80d9d2:	98                   	cwtl   
  80d9d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9d7:	89 34 24             	mov    %esi,(%esp)
  80d9da:	e8 b1 72 ff ff       	call   804c90 <pbuf_header>
  80d9df:	84 c0                	test   %al,%al
  80d9e1:	74 0d                	je     80d9f0 <tcp_input+0x12f>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80d9e3:	89 34 24             	mov    %esi,(%esp)
  80d9e6:	e8 8a 73 ff ff       	call   804d75 <pbuf_free>
    return;
  80d9eb:	e9 f6 0b 00 00       	jmp    80e5e6 <tcp_input+0xd25>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80d9f0:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80d9f6:	0f b7 03             	movzwl (%ebx),%eax
  80d9f9:	89 04 24             	mov    %eax,(%esp)
  80d9fc:	e8 88 a2 ff ff       	call   807c89 <ntohs>
  80da01:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80da04:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80da0a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80da0e:	89 04 24             	mov    %eax,(%esp)
  80da11:	e8 73 a2 ff ff       	call   807c89 <ntohs>
  80da16:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80da1a:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80da20:	8b 43 04             	mov    0x4(%ebx),%eax
  80da23:	89 04 24             	mov    %eax,(%esp)
  80da26:	e8 c8 a4 ff ff       	call   807ef3 <ntohl>
  80da2b:	89 43 04             	mov    %eax,0x4(%ebx)
  80da2e:	a3 e4 b1 b3 00       	mov    %eax,0xb3b1e4
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80da33:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80da39:	8b 43 08             	mov    0x8(%ebx),%eax
  80da3c:	89 04 24             	mov    %eax,(%esp)
  80da3f:	e8 af a4 ff ff       	call   807ef3 <ntohl>
  80da44:	89 43 08             	mov    %eax,0x8(%ebx)
  80da47:	a3 e8 b1 b3 00       	mov    %eax,0xb3b1e8
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80da4c:	8b 1d e0 b1 b3 00    	mov    0xb3b1e0,%ebx
  80da52:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80da56:	89 04 24             	mov    %eax,(%esp)
  80da59:	e8 2b a2 ff ff       	call   807c89 <ntohs>
  80da5e:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80da62:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80da67:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80da6b:	89 04 24             	mov    %eax,(%esp)
  80da6e:	e8 16 a2 ff ff       	call   807c89 <ntohs>
  80da73:	83 e0 3f             	and    $0x3f,%eax
  80da76:	88 45 d7             	mov    %al,-0x29(%ebp)
  80da79:	a2 ec b1 b3 00       	mov    %al,0xb3b1ec
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80da7e:	8b 46 08             	mov    0x8(%esi),%eax
  80da81:	f6 45 d7 01          	testb  $0x1,-0x29(%ebp)
  80da85:	75 0c                	jne    80da93 <tcp_input+0x1d2>
  80da87:	f6 45 d7 02          	testb  $0x2,-0x29(%ebp)
  80da8b:	0f 95 c2             	setne  %dl
  80da8e:	0f b6 d2             	movzbl %dl,%edx
  80da91:	eb 05                	jmp    80da98 <tcp_input+0x1d7>
  80da93:	ba 01 00 00 00       	mov    $0x1,%edx
  80da98:	01 d0                	add    %edx,%eax
  80da9a:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80da9e:	66 a3 ee b1 b3 00    	mov    %ax,0xb3b1ee
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80daa4:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80daa9:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80daac:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dab1:	8b 15 dc b1 b3 00    	mov    0xb3b1dc,%edx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dab7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80daba:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dabf:	e9 e1 00 00 00       	jmp    80dba5 <tcp_input+0x2e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dac4:	8b 4b 10             	mov    0x10(%ebx),%ecx
  80dac7:	85 c9                	test   %ecx,%ecx
  80dac9:	75 1c                	jne    80dae7 <tcp_input+0x226>
  80dacb:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  80dad2:	00 
  80dad3:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80dada:	00 
  80dadb:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80dae2:	e8 91 13 00 00       	call   80ee78 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80dae7:	83 f9 0a             	cmp    $0xa,%ecx
  80daea:	75 1c                	jne    80db08 <tcp_input+0x247>
  80daec:	c7 44 24 08 c4 2c 81 	movl   $0x812cc4,0x8(%esp)
  80daf3:	00 
  80daf4:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80dafb:	00 
  80dafc:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80db03:	e8 70 13 00 00       	call   80ee78 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80db08:	83 f9 01             	cmp    $0x1,%ecx
  80db0b:	75 1c                	jne    80db29 <tcp_input+0x268>
  80db0d:	c7 44 24 08 f0 2c 81 	movl   $0x812cf0,0x8(%esp)
  80db14:	00 
  80db15:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80db1c:	00 
  80db1d:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80db24:	e8 4f 13 00 00       	call   80ee78 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80db29:	8b 08                	mov    (%eax),%ecx
  80db2b:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  80db2f:	75 6f                	jne    80dba0 <tcp_input+0x2df>
  80db31:	66 8b 48 02          	mov    0x2(%eax),%cx
  80db35:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80db39:	75 65                	jne    80dba0 <tcp_input+0x2df>
       pcb->local_port == tcphdr->dest &&
  80db3b:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80db3e:	39 4b 04             	cmp    %ecx,0x4(%ebx)
  80db41:	75 5d                	jne    80dba0 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80db43:	8b 4a 10             	mov    0x10(%edx),%ecx
  80db46:	39 0b                	cmp    %ecx,(%ebx)
  80db48:	75 56                	jne    80dba0 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80db4a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80db4d:	39 d8                	cmp    %ebx,%eax
  80db4f:	75 1c                	jne    80db6d <tcp_input+0x2ac>
  80db51:	c7 44 24 08 18 2d 81 	movl   $0x812d18,0x8(%esp)
  80db58:	00 
  80db59:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80db60:	00 
  80db61:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80db68:	e8 0b 13 00 00       	call   80ee78 <_panic>
      if (prev != NULL) {
  80db6d:	85 ff                	test   %edi,%edi
  80db6f:	74 41                	je     80dbb2 <tcp_input+0x2f1>
        prev->next = pcb->next;
  80db71:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80db74:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80db77:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80db7a:	89 1d 7c b2 b3 00    	mov    %ebx,0xb3b27c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80db80:	39 d8                	cmp    %ebx,%eax
  80db82:	75 2e                	jne    80dbb2 <tcp_input+0x2f1>
  80db84:	c7 44 24 08 44 2d 81 	movl   $0x812d44,0x8(%esp)
  80db8b:	00 
  80db8c:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80db93:	00 
  80db94:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80db9b:	e8 d8 12 00 00       	call   80ee78 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dba0:	89 df                	mov    %ebx,%edi
  80dba2:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dba5:	85 db                	test   %ebx,%ebx
  80dba7:	0f 85 17 ff ff ff    	jne    80dac4 <tcp_input+0x203>
  80dbad:	e9 08 0a 00 00       	jmp    80e5ba <tcp_input+0xcf9>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80dbb2:	c7 05 f0 b1 b3 00 00 	movl   $0x0,0xb3b1f0
  80dbb9:	00 00 00 
    inseg.len = p->tot_len;
  80dbbc:	8b 46 08             	mov    0x8(%esi),%eax
  80dbbf:	66 a3 fc b1 b3 00    	mov    %ax,0xb3b1fc
    inseg.dataptr = p->payload;
  80dbc5:	8b 46 04             	mov    0x4(%esi),%eax
  80dbc8:	a3 f8 b1 b3 00       	mov    %eax,0xb3b1f8
    inseg.p = p;
  80dbcd:	89 35 f4 b1 b3 00    	mov    %esi,0xb3b1f4
    inseg.tcphdr = tcphdr;
  80dbd3:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
  80dbd8:	a3 00 b2 b3 00       	mov    %eax,0xb3b200

    recv_data = NULL;
  80dbdd:	c7 05 04 b2 b3 00 00 	movl   $0x0,0xb3b204
  80dbe4:	00 00 00 
    recv_flags = 0;
  80dbe7:	c6 05 08 b2 b3 00 00 	movb   $0x0,0xb3b208

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80dbee:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80dbf4:	85 d2                	test   %edx,%edx
  80dbf6:	0f 85 5f 02 00 00    	jne    80de5b <tcp_input+0x59a>
  80dbfc:	e9 a3 02 00 00       	jmp    80dea4 <tcp_input+0x5e3>

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dc01:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dc05:	74 1c                	je     80dc23 <tcp_input+0x362>
  80dc07:	c7 44 24 08 70 2d 81 	movl   $0x812d70,0x8(%esp)
  80dc0e:	00 
  80dc0f:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80dc16:	00 
  80dc17:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80dc1e:	e8 55 12 00 00       	call   80ee78 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80dc23:	8b 08                	mov    (%eax),%ecx
  80dc25:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  80dc29:	75 57                	jne    80dc82 <tcp_input+0x3c1>
  80dc2b:	66 8b 48 02          	mov    0x2(%eax),%cx
  80dc2f:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80dc33:	75 4d                	jne    80dc82 <tcp_input+0x3c1>
         pcb->local_port == tcphdr->dest &&
  80dc35:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80dc38:	39 4b 04             	cmp    %ecx,0x4(%ebx)
  80dc3b:	75 45                	jne    80dc82 <tcp_input+0x3c1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dc3d:	8b 4a 10             	mov    0x10(%edx),%ecx
  80dc40:	39 0b                	cmp    %ecx,(%ebx)
  80dc42:	75 3e                	jne    80dc82 <tcp_input+0x3c1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80dc44:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80dc48:	03 05 e4 b1 b3 00    	add    0xb3b1e4,%eax
  80dc4e:	89 c2                	mov    %eax,%edx
  80dc50:	2b 53 24             	sub    0x24(%ebx),%edx
  80dc53:	85 d2                	test   %edx,%edx
  80dc55:	7e 03                	jle    80dc5a <tcp_input+0x399>
    pcb->rcv_nxt = seqno + tcplen;
  80dc57:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80dc5a:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80dc5f:	74 0c                	je     80dc6d <tcp_input+0x3ac>
    tcp_ack_now(pcb);
  80dc61:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc65:	89 1c 24             	mov    %ebx,(%esp)
  80dc68:	e8 f5 a9 ff ff       	call   808662 <tcp_output>
  }
  return tcp_output(pcb);
  80dc6d:	89 1c 24             	mov    %ebx,(%esp)
  80dc70:	e8 ed a9 ff ff       	call   808662 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80dc75:	89 34 24             	mov    %esi,(%esp)
  80dc78:	e8 f8 70 ff ff       	call   804d75 <pbuf_free>
        return;
  80dc7d:	e9 64 09 00 00       	jmp    80e5e6 <tcp_input+0xd25>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc82:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dc85:	85 db                	test   %ebx,%ebx
  80dc87:	0f 85 74 ff ff ff    	jne    80dc01 <tcp_input+0x340>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dc8d:	8b 0d 84 b2 b3 00    	mov    0xb3b284,%ecx
  80dc93:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  80dc96:	89 cb                	mov    %ecx,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80dc98:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dc9d:	e9 ac 01 00 00       	jmp    80de4e <tcp_input+0x58d>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80dca2:	85 db                	test   %ebx,%ebx
  80dca4:	74 0f                	je     80dcb5 <tcp_input+0x3f4>
  80dca6:	8b 0b                	mov    (%ebx),%ecx
  80dca8:	85 c9                	test   %ecx,%ecx
  80dcaa:	74 09                	je     80dcb5 <tcp_input+0x3f4>
  80dcac:	3b 4a 10             	cmp    0x10(%edx),%ecx
  80dcaf:	0f 85 94 01 00 00    	jne    80de49 <tcp_input+0x588>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80dcb5:	66 8b 48 02          	mov    0x2(%eax),%cx
  80dcb9:	66 39 4b 1c          	cmp    %cx,0x1c(%ebx)
  80dcbd:	0f 85 86 01 00 00    	jne    80de49 <tcp_input+0x588>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80dcc3:	85 ff                	test   %edi,%edi
  80dcc5:	74 12                	je     80dcd9 <tcp_input+0x418>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80dcc7:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dcca:	89 57 0c             	mov    %edx,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80dccd:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80dcd0:	89 53 0c             	mov    %edx,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80dcd3:	89 1d 84 b2 b3 00    	mov    %ebx,0xb3b284
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80dcd9:	0f b6 55 d7          	movzbl -0x29(%ebp),%edx
  80dcdd:	f6 c2 10             	test   $0x10,%dl
  80dce0:	74 44                	je     80dd26 <tcp_input+0x465>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80dce2:	8b 15 dc b1 b3 00    	mov    0xb3b1dc,%edx
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80dce8:	0f b7 08             	movzwl (%eax),%ecx
  80dceb:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80dcef:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  80dcf3:	89 44 24 10          	mov    %eax,0x10(%esp)
  80dcf7:	8d 42 0c             	lea    0xc(%edx),%eax
  80dcfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80dcfe:	83 c2 10             	add    $0x10,%edx
  80dd01:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dd05:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80dd09:	03 05 e4 b1 b3 00    	add    0xb3b1e4,%eax
  80dd0f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd13:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80dd18:	40                   	inc    %eax
  80dd19:	89 04 24             	mov    %eax,(%esp)
  80dd1c:	e8 cb ad ff ff       	call   808aec <tcp_rst>
  80dd21:	e9 16 01 00 00       	jmp    80de3c <tcp_input+0x57b>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80dd26:	f6 c2 02             	test   $0x2,%dl
  80dd29:	0f 84 0d 01 00 00    	je     80de3c <tcp_input+0x57b>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80dd2f:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80dd33:	89 04 24             	mov    %eax,(%esp)
  80dd36:	e8 57 89 ff ff       	call   806692 <tcp_alloc>
  80dd3b:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80dd3d:	85 c0                	test   %eax,%eax
  80dd3f:	0f 84 f7 00 00 00    	je     80de3c <tcp_input+0x57b>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80dd45:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
  80dd4a:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80dd4d:	74 05                	je     80dd54 <tcp_input+0x493>
  80dd4f:	8b 50 10             	mov    0x10(%eax),%edx
  80dd52:	eb 05                	jmp    80dd59 <tcp_input+0x498>
  80dd54:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd59:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80dd5b:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80dd5e:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80dd62:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80dd65:	74 05                	je     80dd6c <tcp_input+0x4ab>
  80dd67:	8b 40 0c             	mov    0xc(%eax),%eax
  80dd6a:	eb 05                	jmp    80dd71 <tcp_input+0x4b0>
  80dd6c:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd71:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80dd74:	8b 15 e0 b1 b3 00    	mov    0xb3b1e0,%edx
  80dd7a:	8b 02                	mov    (%edx),%eax
  80dd7c:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80dd80:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80dd87:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80dd8c:	8d 48 01             	lea    0x1(%eax),%ecx
  80dd8f:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80dd92:	66 8b 52 0e          	mov    0xe(%edx),%dx
  80dd96:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80dd9a:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80dd9e:	48                   	dec    %eax
  80dd9f:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80dda2:	8b 43 18             	mov    0x18(%ebx),%eax
  80dda5:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80dda8:	8b 43 20             	mov    0x20(%ebx),%eax
  80ddab:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80ddb1:	8b 43 08             	mov    0x8(%ebx),%eax
  80ddb4:	25 99 01 00 00       	and    $0x199,%eax
  80ddb9:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80ddbd:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80ddc2:	89 47 0c             	mov    %eax,0xc(%edi)
  80ddc5:	89 3d 7c b2 b3 00    	mov    %edi,0xb3b27c
  80ddcb:	e8 82 47 ff ff       	call   802552 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80ddd0:	89 f8                	mov    %edi,%eax
  80ddd2:	e8 49 ee ff ff       	call   80cc20 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80ddd7:	8d 47 04             	lea    0x4(%edi),%eax
  80ddda:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ddde:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80dde2:	89 04 24             	mov    %eax,(%esp)
  80dde5:	e8 30 8a ff ff       	call   80681a <tcp_eff_send_mss>
  80ddea:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80ddee:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80ddf5:	e8 a3 9e ff ff       	call   807c9d <htonl>
  80ddfa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80ddfd:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80de04:	00 
  80de05:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80de08:	89 44 24 14          	mov    %eax,0x14(%esp)
  80de0c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80de13:	00 
  80de14:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80de1b:	00 
  80de1c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80de23:	00 
  80de24:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80de2b:	00 
  80de2c:	89 3c 24             	mov    %edi,(%esp)
  80de2f:	e8 d4 a0 ff ff       	call   807f08 <tcp_enqueue>
    return tcp_output(npcb);
  80de34:	89 3c 24             	mov    %edi,(%esp)
  80de37:	e8 26 a8 ff ff       	call   808662 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80de3c:	89 34 24             	mov    %esi,(%esp)
  80de3f:	e8 31 6f ff ff       	call   804d75 <pbuf_free>
        return;
  80de44:	e9 9d 07 00 00       	jmp    80e5e6 <tcp_input+0xd25>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80de49:	89 df                	mov    %ebx,%edi
  80de4b:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80de4e:	85 db                	test   %ebx,%ebx
  80de50:	0f 85 4c fe ff ff    	jne    80dca2 <tcp_input+0x3e1>
  80de56:	e9 6a 07 00 00       	jmp    80e5c5 <tcp_input+0xd04>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80de5b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80de61:	85 c0                	test   %eax,%eax
  80de63:	74 1e                	je     80de83 <tcp_input+0x5c2>
  80de65:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80de6c:	00 
  80de6d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80de71:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80de75:	8b 53 18             	mov    0x18(%ebx),%edx
  80de78:	89 14 24             	mov    %edx,(%esp)
  80de7b:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80de7d:	84 c0                	test   %al,%al
  80de7f:	74 0a                	je     80de8b <tcp_input+0x5ca>
  80de81:	eb 14                	jmp    80de97 <tcp_input+0x5d6>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80de83:	89 14 24             	mov    %edx,(%esp)
  80de86:	e8 ea 6e ff ff       	call   804d75 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80de8b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80de92:	00 00 00 
  80de95:	eb 0d                	jmp    80dea4 <tcp_input+0x5e3>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80de97:	89 34 24             	mov    %esi,(%esp)
  80de9a:	e8 d6 6e ff ff       	call   804d75 <pbuf_free>
        return;
  80de9f:	e9 42 07 00 00       	jmp    80e5e6 <tcp_input+0xd25>
      }
    }

    tcp_input_pcb = pcb;
  80dea4:	89 1d 98 b2 b3 00    	mov    %ebx,0xb3b298
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80deaa:	0f b6 05 ec b1 b3 00 	movzbl 0xb3b1ec,%eax
  80deb1:	a8 04                	test   $0x4,%al
  80deb3:	74 68                	je     80df1d <tcp_input+0x65c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80deb5:	8b 43 10             	mov    0x10(%ebx),%eax
  80deb8:	83 f8 02             	cmp    $0x2,%eax
  80debb:	75 0e                	jne    80decb <tcp_input+0x60a>
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  80debd:	8b 0d e8 b1 b3 00    	mov    0xb3b1e8,%ecx
  80dec3:	39 4b 54             	cmp    %ecx,0x54(%ebx)
  80dec6:	0f 94 c2             	sete   %dl
  80dec9:	eb 1a                	jmp    80dee5 <tcp_input+0x624>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80decb:	8b 15 e4 b1 b3 00    	mov    0xb3b1e4,%edx
  80ded1:	2b 53 24             	sub    0x24(%ebx),%edx
  80ded4:	0f 88 fd 06 00 00    	js     80e5d7 <tcp_input+0xd16>
  80deda:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80dede:	29 ca                	sub    %ecx,%edx
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  80dee0:	85 d2                	test   %edx,%edx
  80dee2:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80dee5:	84 d2                	test   %dl,%dl
  80dee7:	0f 84 ea 06 00 00    	je     80e5d7 <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80deed:	85 c0                	test   %eax,%eax
  80deef:	75 1c                	jne    80df0d <tcp_input+0x64c>
  80def1:	c7 44 24 08 a0 2d 81 	movl   $0x812da0,0x8(%esp)
  80def8:	00 
  80def9:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80df00:	00 
  80df01:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80df08:	e8 6b 0f 00 00       	call   80ee78 <_panic>
      recv_flags = TF_RESET;
  80df0d:	c6 05 08 b2 b3 00 08 	movb   $0x8,0xb3b208
      pcb->flags &= ~TF_ACK_DELAY;
  80df14:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80df18:	e9 ba 06 00 00       	jmp    80e5d7 <tcp_input+0xd16>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80df1d:	8b 15 80 b2 b3 00    	mov    0xb3b280,%edx
  80df23:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80df26:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80df2d:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80df31:	0f 87 d6 04 00 00    	ja     80e40d <tcp_input+0xb4c>
  80df37:	8b 53 10             	mov    0x10(%ebx),%edx
  80df3a:	ff 24 95 44 2e 81 00 	jmp    *0x812e44(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80df41:	83 e0 12             	and    $0x12,%eax
  80df44:	83 f8 12             	cmp    $0x12,%eax
  80df47:	0f 85 fc 00 00 00    	jne    80e049 <tcp_input+0x788>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80df4d:	8b 43 78             	mov    0x78(%ebx),%eax
  80df50:	8b 40 10             	mov    0x10(%eax),%eax
  80df53:	8b 40 04             	mov    0x4(%eax),%eax
  80df56:	89 04 24             	mov    %eax,(%esp)
  80df59:	e8 95 9f ff ff       	call   807ef3 <ntohl>
  80df5e:	8d 50 01             	lea    0x1(%eax),%edx
  80df61:	3b 15 e8 b1 b3 00    	cmp    0xb3b1e8,%edx
  80df67:	0f 85 dc 00 00 00    	jne    80e049 <tcp_input+0x788>
      pcb->snd_buf++;
  80df6d:	66 ff 43 6e          	incw   0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80df71:	a1 e4 b1 b3 00       	mov    0xb3b1e4,%eax
  80df76:	8d 48 01             	lea    0x1(%eax),%ecx
  80df79:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80df7c:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80df7f:	8b 15 e0 b1 b3 00    	mov    0xb3b1e0,%edx
  80df85:	66 8b 52 0e          	mov    0xe(%edx),%dx
  80df89:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80df8d:	48                   	dec    %eax
  80df8e:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80df91:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80df98:	89 d8                	mov    %ebx,%eax
  80df9a:	e8 81 ec ff ff       	call   80cc20 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80df9f:	8d 43 04             	lea    0x4(%ebx),%eax
  80dfa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dfa6:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dfaa:	89 04 24             	mov    %eax,(%esp)
  80dfad:	e8 68 88 ff ff       	call   80681a <tcp_eff_send_mss>
  80dfb2:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80dfb6:	66 6b d0 0a          	imul   $0xa,%ax,%dx
  80dfba:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dfbe:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80dfc3:	75 02                	jne    80dfc7 <tcp_input+0x706>
  80dfc5:	d1 e0                	shl    %eax
  80dfc7:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80dfcb:	8b 43 70             	mov    0x70(%ebx),%eax
  80dfce:	66 85 c0             	test   %ax,%ax
  80dfd1:	75 1c                	jne    80dfef <tcp_input+0x72e>
  80dfd3:	c7 44 24 08 19 2e 81 	movl   $0x812e19,0x8(%esp)
  80dfda:	00 
  80dfdb:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80dfe2:	00 
  80dfe3:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80dfea:	e8 89 0e 00 00       	call   80ee78 <_panic>
      --pcb->snd_queuelen;
  80dfef:	48                   	dec    %eax
  80dff0:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80dff4:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80dff7:	8b 10                	mov    (%eax),%edx
  80dff9:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80dffc:	85 d2                	test   %edx,%edx
  80dffe:	75 08                	jne    80e008 <tcp_input+0x747>
        pcb->rtime = -1;
  80e000:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80e006:	eb 0a                	jmp    80e012 <tcp_input+0x751>
      else {
        pcb->rtime = 0;
  80e008:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e00e:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e012:	89 04 24             	mov    %eax,(%esp)
  80e015:	e8 cf 7c ff ff       	call   805ce9 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e01a:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e020:	85 c0                	test   %eax,%eax
  80e022:	74 14                	je     80e038 <tcp_input+0x777>
  80e024:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e02b:	00 
  80e02c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e030:	8b 53 18             	mov    0x18(%ebx),%edx
  80e033:	89 14 24             	mov    %edx,(%esp)
  80e036:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e038:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e03c:	89 1c 24             	mov    %ebx,(%esp)
  80e03f:	e8 1e a6 ff ff       	call   808662 <tcp_output>
  80e044:	e9 8e 05 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e049:	f6 05 ec b1 b3 00 10 	testb  $0x10,0xb3b1ec
  80e050:	0f 84 81 05 00 00    	je     80e5d7 <tcp_input+0xd16>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e056:	8b 15 e0 b1 b3 00    	mov    0xb3b1e0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e05c:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
  80e061:	0f b7 0a             	movzwl (%edx),%ecx
  80e064:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e068:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e06c:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e070:	8d 50 0c             	lea    0xc(%eax),%edx
  80e073:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e077:	83 c0 10             	add    $0x10,%eax
  80e07a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e07e:	0f b7 05 ee b1 b3 00 	movzwl 0xb3b1ee,%eax
  80e085:	03 05 e4 b1 b3 00    	add    0xb3b1e4,%eax
  80e08b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e08f:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80e094:	89 04 24             	mov    %eax,(%esp)
  80e097:	e8 50 aa ff ff       	call   808aec <tcp_rst>
  80e09c:	e9 36 05 00 00       	jmp    80e5d7 <tcp_input+0xd16>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e0a1:	83 e0 14             	and    $0x14,%eax
  80e0a4:	83 f8 10             	cmp    $0x10,%eax
  80e0a7:	0f 85 2a 05 00 00    	jne    80e5d7 <tcp_input+0xd16>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e0ad:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80e0b2:	8b 53 48             	mov    0x48(%ebx),%edx
  80e0b5:	f7 d2                	not    %edx
  80e0b7:	01 c2                	add    %eax,%edx
  80e0b9:	0f 88 b5 00 00 00    	js     80e174 <tcp_input+0x8b3>
  80e0bf:	89 c2                	mov    %eax,%edx
  80e0c1:	2b 53 54             	sub    0x54(%ebx),%edx
  80e0c4:	85 d2                	test   %edx,%edx
  80e0c6:	0f 8f a8 00 00 00    	jg     80e174 <tcp_input+0x8b3>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e0cc:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e0d3:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e0d9:	85 c0                	test   %eax,%eax
  80e0db:	75 1c                	jne    80e0f9 <tcp_input+0x838>
  80e0dd:	c7 44 24 08 2f 2e 81 	movl   $0x812e2f,0x8(%esp)
  80e0e4:	00 
  80e0e5:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e0ec:	00 
  80e0ed:	c7 04 24 c0 2d 81 00 	movl   $0x812dc0,(%esp)
  80e0f4:	e8 7f 0d 00 00       	call   80ee78 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e0f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e100:	00 
  80e101:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e105:	8b 53 18             	mov    0x18(%ebx),%edx
  80e108:	89 14 24             	mov    %edx,(%esp)
  80e10b:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e10d:	84 c0                	test   %al,%al
  80e10f:	74 17                	je     80e128 <tcp_input+0x867>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e111:	89 1c 24             	mov    %ebx,(%esp)
  80e114:	e8 6d 7e ff ff       	call   805f86 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e119:	c7 05 98 b2 b3 00 00 	movl   $0x0,0xb3b298
  80e120:	00 00 00 
  80e123:	e9 21 04 00 00       	jmp    80e549 <tcp_input+0xc88>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e128:	66 8b 73 4e          	mov    0x4e(%ebx),%si
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e12c:	89 d8                	mov    %ebx,%eax
  80e12e:	e8 90 eb ff ff       	call   80ccc3 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e133:	66 83 fe 01          	cmp    $0x1,%si
  80e137:	75 07                	jne    80e140 <tcp_input+0x87f>
  80e139:	8b 53 34             	mov    0x34(%ebx),%edx
  80e13c:	d1 e2                	shl    %edx
  80e13e:	eb 03                	jmp    80e143 <tcp_input+0x882>
  80e140:	8b 53 34             	mov    0x34(%ebx),%edx
  80e143:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e147:	f6 05 ec b1 b3 00 01 	testb  $0x1,0xb3b1ec
  80e14e:	0f 84 83 04 00 00    	je     80e5d7 <tcp_input+0xd16>
  80e154:	84 c0                	test   %al,%al
  80e156:	0f 84 7b 04 00 00    	je     80e5d7 <tcp_input+0xd16>
          tcp_ack_now(pcb);
  80e15c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e160:	89 1c 24             	mov    %ebx,(%esp)
  80e163:	e8 fa a4 ff ff       	call   808662 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e168:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e16f:	e9 63 04 00 00       	jmp    80e5d7 <tcp_input+0xd16>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e174:	8b 0d e0 b1 b3 00    	mov    0xb3b1e0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e17a:	8b 15 dc b1 b3 00    	mov    0xb3b1dc,%edx
  80e180:	0f b7 31             	movzwl (%ecx),%esi
  80e183:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e187:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e18b:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e18f:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e192:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e196:	83 c2 10             	add    $0x10,%edx
  80e199:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e19d:	0f b7 15 ee b1 b3 00 	movzwl 0xb3b1ee,%edx
  80e1a4:	03 15 e4 b1 b3 00    	add    0xb3b1e4,%edx
  80e1aa:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e1ae:	89 04 24             	mov    %eax,(%esp)
  80e1b1:	e8 36 a9 ff ff       	call   808aec <tcp_rst>
  80e1b6:	e9 1c 04 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e1bb:	89 d8                	mov    %ebx,%eax
  80e1bd:	e8 01 eb ff ff       	call   80ccc3 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e1c2:	f6 05 ec b1 b3 00 01 	testb  $0x1,0xb3b1ec
  80e1c9:	0f 84 08 04 00 00    	je     80e5d7 <tcp_input+0xd16>
  80e1cf:	84 c0                	test   %al,%al
  80e1d1:	0f 84 00 04 00 00    	je     80e5d7 <tcp_input+0xd16>
      tcp_ack_now(pcb);
  80e1d7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e1db:	89 1c 24             	mov    %ebx,(%esp)
  80e1de:	e8 7f a4 ff ff       	call   808662 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e1e3:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e1ea:	e9 e8 03 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e1ef:	89 d8                	mov    %ebx,%eax
  80e1f1:	e8 cd ea ff ff       	call   80ccc3 <tcp_receive>
    if (flags & TCP_FIN) {
  80e1f6:	a0 ec b1 b3 00       	mov    0xb3b1ec,%al
  80e1fb:	a8 01                	test   $0x1,%al
  80e1fd:	0f 84 9a 00 00 00    	je     80e29d <tcp_input+0x9dc>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e203:	a8 10                	test   $0x10,%al
  80e205:	74 7e                	je     80e285 <tcp_input+0x9c4>
  80e207:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80e20c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e20f:	75 74                	jne    80e285 <tcp_input+0x9c4>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e211:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e215:	89 1c 24             	mov    %ebx,(%esp)
  80e218:	e8 45 a4 ff ff       	call   808662 <tcp_output>
        tcp_pcb_purge(pcb);
  80e21d:	89 1c 24             	mov    %ebx,(%esp)
  80e220:	e8 ef 7b ff ff       	call   805e14 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e225:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80e22a:	39 c3                	cmp    %eax,%ebx
  80e22c:	75 0a                	jne    80e238 <tcp_input+0x977>
  80e22e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e231:	a3 7c b2 b3 00       	mov    %eax,0xb3b27c
  80e236:	eb 2e                	jmp    80e266 <tcp_input+0x9a5>
  80e238:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e23d:	eb 1e                	jmp    80e25d <tcp_input+0x99c>
  80e23f:	8b 50 0c             	mov    0xc(%eax),%edx
  80e242:	85 d2                	test   %edx,%edx
  80e244:	74 11                	je     80e257 <tcp_input+0x996>
  80e246:	39 d3                	cmp    %edx,%ebx
  80e248:	75 11                	jne    80e25b <tcp_input+0x99a>
  80e24a:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e24f:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e252:	89 50 0c             	mov    %edx,0xc(%eax)
  80e255:	eb 0f                	jmp    80e266 <tcp_input+0x9a5>
  80e257:	89 d0                	mov    %edx,%eax
  80e259:	eb 02                	jmp    80e25d <tcp_input+0x99c>
  80e25b:	89 d0                	mov    %edx,%eax
  80e25d:	85 c0                	test   %eax,%eax
  80e25f:	75 de                	jne    80e23f <tcp_input+0x97e>
  80e261:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
        pcb->state = TIME_WAIT;
  80e266:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e26d:	a1 90 b2 b3 00       	mov    0xb3b290,%eax
  80e272:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e275:	89 1d 90 b2 b3 00    	mov    %ebx,0xb3b290
  80e27b:	e8 d2 42 ff ff       	call   802552 <tcp_timer_needed>
  80e280:	e9 52 03 00 00       	jmp    80e5d7 <tcp_input+0xd16>
      } else {
        tcp_ack_now(pcb);
  80e285:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e289:	89 1c 24             	mov    %ebx,(%esp)
  80e28c:	e8 d1 a3 ff ff       	call   808662 <tcp_output>
        pcb->state = CLOSING;
  80e291:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e298:	e9 3a 03 00 00       	jmp    80e5d7 <tcp_input+0xd16>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e29d:	a8 10                	test   $0x10,%al
  80e29f:	0f 84 32 03 00 00    	je     80e5d7 <tcp_input+0xd16>
  80e2a5:	8b 15 e8 b1 b3 00    	mov    0xb3b1e8,%edx
  80e2ab:	39 53 54             	cmp    %edx,0x54(%ebx)
  80e2ae:	0f 85 23 03 00 00    	jne    80e5d7 <tcp_input+0xd16>
      pcb->state = FIN_WAIT_2;
  80e2b4:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e2bb:	e9 17 03 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e2c0:	89 d8                	mov    %ebx,%eax
  80e2c2:	e8 fc e9 ff ff       	call   80ccc3 <tcp_receive>
    if (flags & TCP_FIN) {
  80e2c7:	f6 05 ec b1 b3 00 01 	testb  $0x1,0xb3b1ec
  80e2ce:	0f 84 03 03 00 00    	je     80e5d7 <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e2d4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e2d8:	89 1c 24             	mov    %ebx,(%esp)
  80e2db:	e8 82 a3 ff ff       	call   808662 <tcp_output>
      tcp_pcb_purge(pcb);
  80e2e0:	89 1c 24             	mov    %ebx,(%esp)
  80e2e3:	e8 2c 7b ff ff       	call   805e14 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e2e8:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80e2ed:	39 c3                	cmp    %eax,%ebx
  80e2ef:	75 0a                	jne    80e2fb <tcp_input+0xa3a>
  80e2f1:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e2f4:	a3 7c b2 b3 00       	mov    %eax,0xb3b27c
  80e2f9:	eb 2e                	jmp    80e329 <tcp_input+0xa68>
  80e2fb:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e300:	eb 1e                	jmp    80e320 <tcp_input+0xa5f>
  80e302:	8b 50 0c             	mov    0xc(%eax),%edx
  80e305:	85 d2                	test   %edx,%edx
  80e307:	74 11                	je     80e31a <tcp_input+0xa59>
  80e309:	39 d3                	cmp    %edx,%ebx
  80e30b:	75 11                	jne    80e31e <tcp_input+0xa5d>
  80e30d:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e312:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e315:	89 50 0c             	mov    %edx,0xc(%eax)
  80e318:	eb 0f                	jmp    80e329 <tcp_input+0xa68>
  80e31a:	89 d0                	mov    %edx,%eax
  80e31c:	eb 02                	jmp    80e320 <tcp_input+0xa5f>
  80e31e:	89 d0                	mov    %edx,%eax
  80e320:	85 c0                	test   %eax,%eax
  80e322:	75 de                	jne    80e302 <tcp_input+0xa41>
  80e324:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
      pcb->state = TIME_WAIT;
  80e329:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e330:	a1 90 b2 b3 00       	mov    0xb3b290,%eax
  80e335:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e338:	89 1d 90 b2 b3 00    	mov    %ebx,0xb3b290
  80e33e:	e8 0f 42 ff ff       	call   802552 <tcp_timer_needed>
  80e343:	e9 8f 02 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e348:	89 d8                	mov    %ebx,%eax
  80e34a:	e8 74 e9 ff ff       	call   80ccc3 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e34f:	f6 05 ec b1 b3 00 10 	testb  $0x10,0xb3b1ec
  80e356:	0f 84 7b 02 00 00    	je     80e5d7 <tcp_input+0xd16>
  80e35c:	8b 0d e8 b1 b3 00    	mov    0xb3b1e8,%ecx
  80e362:	39 4b 54             	cmp    %ecx,0x54(%ebx)
  80e365:	0f 85 6c 02 00 00    	jne    80e5d7 <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e36b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e36f:	89 1c 24             	mov    %ebx,(%esp)
  80e372:	e8 eb a2 ff ff       	call   808662 <tcp_output>
      tcp_pcb_purge(pcb);
  80e377:	89 1c 24             	mov    %ebx,(%esp)
  80e37a:	e8 95 7a ff ff       	call   805e14 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e37f:	a1 7c b2 b3 00       	mov    0xb3b27c,%eax
  80e384:	39 c3                	cmp    %eax,%ebx
  80e386:	75 0a                	jne    80e392 <tcp_input+0xad1>
  80e388:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e38b:	a3 7c b2 b3 00       	mov    %eax,0xb3b27c
  80e390:	eb 2e                	jmp    80e3c0 <tcp_input+0xaff>
  80e392:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e397:	eb 1e                	jmp    80e3b7 <tcp_input+0xaf6>
  80e399:	8b 50 0c             	mov    0xc(%eax),%edx
  80e39c:	85 d2                	test   %edx,%edx
  80e39e:	74 11                	je     80e3b1 <tcp_input+0xaf0>
  80e3a0:	39 d3                	cmp    %edx,%ebx
  80e3a2:	75 11                	jne    80e3b5 <tcp_input+0xaf4>
  80e3a4:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
  80e3a9:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e3ac:	89 50 0c             	mov    %edx,0xc(%eax)
  80e3af:	eb 0f                	jmp    80e3c0 <tcp_input+0xaff>
  80e3b1:	89 d0                	mov    %edx,%eax
  80e3b3:	eb 02                	jmp    80e3b7 <tcp_input+0xaf6>
  80e3b5:	89 d0                	mov    %edx,%eax
  80e3b7:	85 c0                	test   %eax,%eax
  80e3b9:	75 de                	jne    80e399 <tcp_input+0xad8>
  80e3bb:	a3 88 b2 b3 00       	mov    %eax,0xb3b288
      pcb->state = TIME_WAIT;
  80e3c0:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e3c7:	a1 90 b2 b3 00       	mov    0xb3b290,%eax
  80e3cc:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e3cf:	89 1d 90 b2 b3 00    	mov    %ebx,0xb3b290
  80e3d5:	e8 78 41 ff ff       	call   802552 <tcp_timer_needed>
  80e3da:	e9 f8 01 00 00       	jmp    80e5d7 <tcp_input+0xd16>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e3df:	89 d8                	mov    %ebx,%eax
  80e3e1:	e8 dd e8 ff ff       	call   80ccc3 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e3e6:	f6 05 ec b1 b3 00 10 	testb  $0x10,0xb3b1ec
  80e3ed:	0f 84 e4 01 00 00    	je     80e5d7 <tcp_input+0xd16>
  80e3f3:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80e3f8:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e3fb:	0f 85 d6 01 00 00    	jne    80e5d7 <tcp_input+0xd16>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e401:	c6 05 08 b2 b3 00 10 	movb   $0x10,0xb3b208
  80e408:	e9 ca 01 00 00       	jmp    80e5d7 <tcp_input+0xd16>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e40d:	c7 05 98 b2 b3 00 00 	movl   $0x0,0xb3b298
  80e414:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e417:	0f b6 05 08 b2 b3 00 	movzbl 0xb3b208,%eax
  80e41e:	a8 08                	test   $0x8,%al
  80e420:	74 3f                	je     80e461 <tcp_input+0xba0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e422:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e428:	85 c0                	test   %eax,%eax
  80e42a:	74 10                	je     80e43c <tcp_input+0xb7b>
  80e42c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e433:	ff 
  80e434:	8b 53 18             	mov    0x18(%ebx),%edx
  80e437:	89 14 24             	mov    %edx,(%esp)
  80e43a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e43c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e440:	c7 04 24 7c b2 b3 00 	movl   $0xb3b27c,(%esp)
  80e447:	e8 41 7a ff ff       	call   805e8d <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e44c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e450:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e457:	e8 8e 65 ff ff       	call   8049ea <memp_free>
  80e45c:	e9 e8 00 00 00       	jmp    80e549 <tcp_input+0xc88>
      } else if (recv_flags & TF_CLOSED) {
  80e461:	a8 10                	test   $0x10,%al
  80e463:	74 25                	je     80e48a <tcp_input+0xbc9>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e465:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e469:	c7 04 24 7c b2 b3 00 	movl   $0xb3b27c,(%esp)
  80e470:	e8 18 7a ff ff       	call   805e8d <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e475:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e479:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e480:	e8 65 65 ff ff       	call   8049ea <memp_free>
  80e485:	e9 bf 00 00 00       	jmp    80e549 <tcp_input+0xc88>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e48a:	8b 43 6c             	mov    0x6c(%ebx),%eax
  80e48d:	66 85 c0             	test   %ax,%ax
  80e490:	74 1f                	je     80e4b1 <tcp_input+0xbf0>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e492:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  80e498:	85 d2                	test   %edx,%edx
  80e49a:	74 19                	je     80e4b5 <tcp_input+0xbf4>
  80e49c:	0f b7 c0             	movzwl %ax,%eax
  80e49f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e4a3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e4a7:	8b 43 18             	mov    0x18(%ebx),%eax
  80e4aa:	89 04 24             	mov    %eax,(%esp)
  80e4ad:	ff d2                	call   *%edx
  80e4af:	eb 06                	jmp    80e4b7 <tcp_input+0xbf6>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80e4b1:	b0 00                	mov    $0x0,%al
  80e4b3:	eb 02                	jmp    80e4b7 <tcp_input+0xbf6>
  80e4b5:	b0 00                	mov    $0x0,%al
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
        }
      
        if (recv_data != NULL) {
  80e4b7:	8b 15 04 b2 b3 00    	mov    0xb3b204,%edx
  80e4bd:	85 d2                	test   %edx,%edx
  80e4bf:	74 4d                	je     80e50e <tcp_input+0xc4d>
          if(flags & TCP_PSH) {
  80e4c1:	f6 05 ec b1 b3 00 08 	testb  $0x8,0xb3b1ec
  80e4c8:	74 04                	je     80e4ce <tcp_input+0xc0d>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e4ca:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e4ce:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e4d4:	85 c0                	test   %eax,%eax
  80e4d6:	74 1e                	je     80e4f6 <tcp_input+0xc35>
  80e4d8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e4df:	00 
  80e4e0:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e4e4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e4e8:	8b 53 18             	mov    0x18(%ebx),%edx
  80e4eb:	89 14 24             	mov    %edx,(%esp)
  80e4ee:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e4f0:	84 c0                	test   %al,%al
  80e4f2:	75 0e                	jne    80e502 <tcp_input+0xc41>
  80e4f4:	eb 18                	jmp    80e50e <tcp_input+0xc4d>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e4f6:	89 14 24             	mov    %edx,(%esp)
  80e4f9:	e8 77 68 ff ff       	call   804d75 <pbuf_free>
  80e4fe:	b0 00                	mov    $0x0,%al
  80e500:	eb 0c                	jmp    80e50e <tcp_input+0xc4d>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e502:	8b 15 04 b2 b3 00    	mov    0xb3b204,%edx
  80e508:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e50e:	f6 05 08 b2 b3 00 20 	testb  $0x20,0xb3b208
  80e515:	74 26                	je     80e53d <tcp_input+0xc7c>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e517:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e51d:	85 c0                	test   %eax,%eax
  80e51f:	74 20                	je     80e541 <tcp_input+0xc80>
  80e521:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e528:	00 
  80e529:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e530:	00 
  80e531:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e535:	8b 53 18             	mov    0x18(%ebx),%edx
  80e538:	89 14 24             	mov    %edx,(%esp)
  80e53b:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e53d:	84 c0                	test   %al,%al
  80e53f:	75 08                	jne    80e549 <tcp_input+0xc88>
          tcp_output(pcb);
  80e541:	89 1c 24             	mov    %ebx,(%esp)
  80e544:	e8 19 a1 ff ff       	call   808662 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e549:	a1 f4 b1 b3 00       	mov    0xb3b1f4,%eax
  80e54e:	85 c0                	test   %eax,%eax
  80e550:	0f 84 90 00 00 00    	je     80e5e6 <tcp_input+0xd25>
    {
      pbuf_free(inseg.p);
  80e556:	89 04 24             	mov    %eax,(%esp)
  80e559:	e8 17 68 ff ff       	call   804d75 <pbuf_free>
      inseg.p = NULL;
  80e55e:	c7 05 f4 b1 b3 00 00 	movl   $0x0,0xb3b1f4
  80e565:	00 00 00 
  80e568:	eb 7c                	jmp    80e5e6 <tcp_input+0xd25>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e56a:	8b 15 e0 b1 b3 00    	mov    0xb3b1e0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e570:	a1 dc b1 b3 00       	mov    0xb3b1dc,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e575:	0f b7 0a             	movzwl (%edx),%ecx
  80e578:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e57c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e580:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e584:	8d 50 0c             	lea    0xc(%eax),%edx
  80e587:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e58b:	83 c0 10             	add    $0x10,%eax
  80e58e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e592:	0f b7 05 ee b1 b3 00 	movzwl 0xb3b1ee,%eax
  80e599:	03 05 e4 b1 b3 00    	add    0xb3b1e4,%eax
  80e59f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e5a3:	a1 e8 b1 b3 00       	mov    0xb3b1e8,%eax
  80e5a8:	89 04 24             	mov    %eax,(%esp)
  80e5ab:	e8 3c a5 ff ff       	call   808aec <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e5b0:	89 34 24             	mov    %esi,(%esp)
  80e5b3:	e8 bd 67 ff ff       	call   804d75 <pbuf_free>
  80e5b8:	eb 2c                	jmp    80e5e6 <tcp_input+0xd25>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e5ba:	8b 1d 90 b2 b3 00    	mov    0xb3b290,%ebx
  80e5c0:	e9 c0 f6 ff ff       	jmp    80dc85 <tcp_input+0x3c4>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e5c5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e5c9:	89 04 24             	mov    %eax,(%esp)
  80e5cc:	e8 b8 96 ff ff       	call   807c89 <ntohs>
  80e5d1:	a8 04                	test   $0x4,%al
  80e5d3:	75 db                	jne    80e5b0 <tcp_input+0xcef>
  80e5d5:	eb 93                	jmp    80e56a <tcp_input+0xca9>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e5d7:	c7 05 98 b2 b3 00 00 	movl   $0x0,0xb3b298
  80e5de:	00 00 00 
  80e5e1:	e9 31 fe ff ff       	jmp    80e417 <tcp_input+0xb56>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e5e6:	83 c4 4c             	add    $0x4c,%esp
  80e5e9:	5b                   	pop    %ebx
  80e5ea:	5e                   	pop    %esi
  80e5eb:	5f                   	pop    %edi
  80e5ec:	5d                   	pop    %ebp
  80e5ed:	c3                   	ret    
	...

0080e5f0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e5f0:	55                   	push   %ebp
  80e5f1:	89 e5                	mov    %esp,%ebp
  80e5f3:	57                   	push   %edi
  80e5f4:	56                   	push   %esi
  80e5f5:	53                   	push   %ebx
  80e5f6:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e5f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5fc:	8b 40 04             	mov    0x4(%eax),%eax
  80e5ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  proto = IPH_PROTO(iphdr);
  80e602:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e606:	89 04 24             	mov    %eax,(%esp)
  80e609:	e8 7b 96 ff ff       	call   807c89 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80e60e:	8b 1d 0c b2 b3 00    	mov    0xb3b20c,%ebx
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e614:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e619:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e61c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e61f:	83 c2 0c             	add    $0xc,%edx
  80e622:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e625:	eb 4c                	jmp    80e673 <raw_input+0x83>
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e627:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e62b:	39 f8                	cmp    %edi,%eax
  80e62d:	75 3f                	jne    80e66e <raw_input+0x7e>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80e62f:	8b 43 14             	mov    0x14(%ebx),%eax
  80e632:	85 c0                	test   %eax,%eax
  80e634:	74 38                	je     80e66e <raw_input+0x7e>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e636:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e639:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e63d:	8b 55 08             	mov    0x8(%ebp),%edx
  80e640:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e644:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e648:	8b 53 18             	mov    0x18(%ebx),%edx
  80e64b:	89 14 24             	mov    %edx,(%esp)
  80e64e:	ff d0                	call   *%eax
  80e650:	84 c0                	test   %al,%al
  80e652:	74 1a                	je     80e66e <raw_input+0x7e>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80e654:	85 f6                	test   %esi,%esi
  80e656:	74 29                	je     80e681 <raw_input+0x91>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80e658:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e65b:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  80e65e:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80e663:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e666:	89 1d 0c b2 b3 00    	mov    %ebx,0xb3b20c
  80e66c:	eb 13                	jmp    80e681 <raw_input+0x91>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  80e66e:	89 de                	mov    %ebx,%esi
  80e670:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e673:	85 db                	test   %ebx,%ebx
  80e675:	75 b0                	jne    80e627 <raw_input+0x37>
  80e677:	b0 00                	mov    $0x0,%al
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80e679:	83 c4 2c             	add    $0x2c,%esp
  80e67c:	5b                   	pop    %ebx
  80e67d:	5e                   	pop    %esi
  80e67e:	5f                   	pop    %edi
  80e67f:	5d                   	pop    %ebp
  80e680:	c3                   	ret    
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e681:	b0 01                	mov    $0x1,%al
  80e683:	eb f4                	jmp    80e679 <raw_input+0x89>

0080e685 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e685:	55                   	push   %ebp
  80e686:	89 e5                	mov    %esp,%ebp
  80e688:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e68b:	85 c0                	test   %eax,%eax
  80e68d:	74 04                	je     80e693 <raw_bind+0xe>
  80e68f:	8b 10                	mov    (%eax),%edx
  80e691:	eb 05                	jmp    80e698 <raw_bind+0x13>
  80e693:	ba 00 00 00 00       	mov    $0x0,%edx
  80e698:	8b 45 08             	mov    0x8(%ebp),%eax
  80e69b:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80e69d:	b0 00                	mov    $0x0,%al
  80e69f:	5d                   	pop    %ebp
  80e6a0:	c3                   	ret    

0080e6a1 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e6a1:	55                   	push   %ebp
  80e6a2:	89 e5                	mov    %esp,%ebp
  80e6a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e6a7:	85 c0                	test   %eax,%eax
  80e6a9:	74 04                	je     80e6af <raw_connect+0xe>
  80e6ab:	8b 10                	mov    (%eax),%edx
  80e6ad:	eb 05                	jmp    80e6b4 <raw_connect+0x13>
  80e6af:	ba 00 00 00 00       	mov    $0x0,%edx
  80e6b4:	8b 45 08             	mov    0x8(%ebp),%eax
  80e6b7:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80e6ba:	b0 00                	mov    $0x0,%al
  80e6bc:	5d                   	pop    %ebp
  80e6bd:	c3                   	ret    

0080e6be <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e6be:	55                   	push   %ebp
  80e6bf:	89 e5                	mov    %esp,%ebp
  80e6c1:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e6c4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e6c7:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e6ca:	8b 55 10             	mov    0x10(%ebp),%edx
  80e6cd:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e6d0:	5d                   	pop    %ebp
  80e6d1:	c3                   	ret    

0080e6d2 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e6d2:	55                   	push   %ebp
  80e6d3:	89 e5                	mov    %esp,%ebp
  80e6d5:	57                   	push   %edi
  80e6d6:	56                   	push   %esi
  80e6d7:	53                   	push   %ebx
  80e6d8:	83 ec 2c             	sub    $0x2c,%esp
  80e6db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e6de:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e6e1:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80e6e8:	00 
  80e6e9:	89 3c 24             	mov    %edi,(%esp)
  80e6ec:	e8 9f 65 ff ff       	call   804c90 <pbuf_header>
  80e6f1:	84 c0                	test   %al,%al
  80e6f3:	74 34                	je     80e729 <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e6f5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e6fc:	00 
  80e6fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e704:	00 
  80e705:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e70c:	e8 65 68 ff ff       	call   804f76 <pbuf_alloc>
  80e711:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e713:	85 c0                	test   %eax,%eax
  80e715:	0f 84 ac 00 00 00    	je     80e7c7 <raw_sendto+0xf5>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e71b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e71f:	89 04 24             	mov    %eax,(%esp)
  80e722:	e8 6c 6b ff ff       	call   805293 <pbuf_chain>
  80e727:	eb 32                	jmp    80e75b <raw_sendto+0x89>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80e729:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80e730:	ff 
  80e731:	89 3c 24             	mov    %edi,(%esp)
  80e734:	e8 57 65 ff ff       	call   804c90 <pbuf_header>
  80e739:	84 c0                	test   %al,%al
  80e73b:	74 1c                	je     80e759 <raw_sendto+0x87>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e73d:	c7 44 24 08 6c 2e 81 	movl   $0x812e6c,0x8(%esp)
  80e744:	00 
  80e745:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80e74c:	00 
  80e74d:	c7 04 24 92 2e 81 00 	movl   $0x812e92,(%esp)
  80e754:	e8 1f 07 00 00       	call   80ee78 <_panic>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80e759:	89 fe                	mov    %edi,%esi
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e75b:	8b 45 10             	mov    0x10(%ebp),%eax
  80e75e:	89 04 24             	mov    %eax,(%esp)
  80e761:	e8 9e 82 ff ff       	call   806a04 <ip_route>
  80e766:	85 c0                	test   %eax,%eax
  80e768:	75 10                	jne    80e77a <raw_sendto+0xa8>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e76a:	39 fe                	cmp    %edi,%esi
  80e76c:	74 5d                	je     80e7cb <raw_sendto+0xf9>
      pbuf_free(q);
  80e76e:	89 34 24             	mov    %esi,(%esp)
  80e771:	e8 ff 65 ff ff       	call   804d75 <pbuf_free>
    }
    return ERR_RTE;
  80e776:	b3 fc                	mov    $0xfc,%bl
  80e778:	eb 53                	jmp    80e7cd <raw_sendto+0xfb>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e77a:	89 da                	mov    %ebx,%edx
  80e77c:	85 db                	test   %ebx,%ebx
  80e77e:	74 05                	je     80e785 <raw_sendto+0xb3>
  80e780:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e783:	75 03                	jne    80e788 <raw_sendto+0xb6>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e785:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e788:	89 44 24 18          	mov    %eax,0x18(%esp)
  80e78c:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e790:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e794:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e798:	89 44 24 10          	mov    %eax,0x10(%esp)
  80e79c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e7a0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80e7a4:	8b 45 10             	mov    0x10(%ebp),%eax
  80e7a7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e7ab:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e7af:	89 34 24             	mov    %esi,(%esp)
  80e7b2:	e8 4d 85 ff ff       	call   806d04 <ip_output_if>
  80e7b7:	88 c3                	mov    %al,%bl
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e7b9:	39 fe                	cmp    %edi,%esi
  80e7bb:	74 10                	je     80e7cd <raw_sendto+0xfb>
    /* free the header */
    pbuf_free(q);
  80e7bd:	89 34 24             	mov    %esi,(%esp)
  80e7c0:	e8 b0 65 ff ff       	call   804d75 <pbuf_free>
  80e7c5:	eb 06                	jmp    80e7cd <raw_sendto+0xfb>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80e7c7:	b3 ff                	mov    $0xff,%bl
  80e7c9:	eb 02                	jmp    80e7cd <raw_sendto+0xfb>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e7cb:	b3 fc                	mov    $0xfc,%bl
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80e7cd:	88 d8                	mov    %bl,%al
  80e7cf:	83 c4 2c             	add    $0x2c,%esp
  80e7d2:	5b                   	pop    %ebx
  80e7d3:	5e                   	pop    %esi
  80e7d4:	5f                   	pop    %edi
  80e7d5:	5d                   	pop    %ebp
  80e7d6:	c3                   	ret    

0080e7d7 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e7d7:	55                   	push   %ebp
  80e7d8:	89 e5                	mov    %esp,%ebp
  80e7da:	83 ec 18             	sub    $0x18,%esp
  80e7dd:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e7e0:	8d 50 04             	lea    0x4(%eax),%edx
  80e7e3:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e7e7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e7ea:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e7ee:	89 04 24             	mov    %eax,(%esp)
  80e7f1:	e8 dc fe ff ff       	call   80e6d2 <raw_sendto>
}
  80e7f6:	c9                   	leave  
  80e7f7:	c3                   	ret    

0080e7f8 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e7f8:	55                   	push   %ebp
  80e7f9:	89 e5                	mov    %esp,%ebp
  80e7fb:	83 ec 18             	sub    $0x18,%esp
  80e7fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e801:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80e806:	39 c8                	cmp    %ecx,%eax
  80e808:	75 1e                	jne    80e828 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e80a:	8b 40 0c             	mov    0xc(%eax),%eax
  80e80d:	a3 0c b2 b3 00       	mov    %eax,0xb3b20c
  80e812:	eb 18                	jmp    80e82c <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e814:	8b 50 0c             	mov    0xc(%eax),%edx
  80e817:	85 d2                	test   %edx,%edx
  80e819:	74 0a                	je     80e825 <raw_remove+0x2d>
  80e81b:	39 d1                	cmp    %edx,%ecx
  80e81d:	75 06                	jne    80e825 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80e81f:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e822:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e825:	8b 40 0c             	mov    0xc(%eax),%eax
  80e828:	85 c0                	test   %eax,%eax
  80e82a:	75 e8                	jne    80e814 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e82c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80e830:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e837:	e8 ae 61 ff ff       	call   8049ea <memp_free>
}
  80e83c:	c9                   	leave  
  80e83d:	c3                   	ret    

0080e83e <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e83e:	55                   	push   %ebp
  80e83f:	89 e5                	mov    %esp,%ebp
  80e841:	53                   	push   %ebx
  80e842:	83 ec 24             	sub    $0x24,%esp
  80e845:	8a 45 08             	mov    0x8(%ebp),%al
  80e848:	88 45 f7             	mov    %al,-0x9(%ebp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e84b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e852:	e8 33 61 ff ff       	call   80498a <memp_malloc>
  80e857:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e859:	85 c0                	test   %eax,%eax
  80e85b:	74 30                	je     80e88d <raw_new+0x4f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e85d:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80e864:	00 
  80e865:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e86c:	00 
  80e86d:	89 04 24             	mov    %eax,(%esp)
  80e870:	e8 d5 0d 00 00       	call   80f64a <memset>
    pcb->protocol = proto;
  80e875:	8a 45 f7             	mov    -0x9(%ebp),%al
  80e878:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e87b:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e87f:	a1 0c b2 b3 00       	mov    0xb3b20c,%eax
  80e884:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e887:	89 1d 0c b2 b3 00    	mov    %ebx,0xb3b20c
  }
  return pcb;
}
  80e88d:	89 d8                	mov    %ebx,%eax
  80e88f:	83 c4 24             	add    $0x24,%esp
  80e892:	5b                   	pop    %ebx
  80e893:	5d                   	pop    %ebp
  80e894:	c3                   	ret    
  80e895:	00 00                	add    %al,(%eax)
	...

0080e898 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e898:	55                   	push   %ebp
  80e899:	89 e5                	mov    %esp,%ebp
  80e89b:	57                   	push   %edi
  80e89c:	56                   	push   %esi
  80e89d:	53                   	push   %ebx
  80e89e:	83 ec 3c             	sub    $0x3c,%esp
  80e8a1:	8b 75 08             	mov    0x8(%ebp),%esi

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e8a4:	8b 46 04             	mov    0x4(%esi),%eax
  80e8a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  hlen = IPH_HL(iphdr) * 4;
  80e8aa:	0f b7 00             	movzwl (%eax),%eax
  80e8ad:	89 04 24             	mov    %eax,(%esp)
  80e8b0:	e8 d4 93 ff ff       	call   807c89 <ntohs>
  80e8b5:	66 c1 e8 06          	shr    $0x6,%ax
  80e8b9:	89 c7                	mov    %eax,%edi
  80e8bb:	83 e7 3c             	and    $0x3c,%edi
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e8be:	89 fb                	mov    %edi,%ebx
  80e8c0:	f7 db                	neg    %ebx
  80e8c2:	0f bf db             	movswl %bx,%ebx
  80e8c5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e8c9:	89 34 24             	mov    %esi,(%esp)
  80e8cc:	e8 bf 63 ff ff       	call   804c90 <pbuf_header>
  80e8d1:	84 c0                	test   %al,%al
  80e8d3:	0f 85 04 03 00 00    	jne    80ebdd <icmp_input+0x345>
  80e8d9:	66 83 7e 08 03       	cmpw   $0x3,0x8(%esi)
  80e8de:	0f 86 f9 02 00 00    	jbe    80ebdd <icmp_input+0x345>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e8e4:	8b 46 04             	mov    0x4(%esi),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e8e7:	80 38 08             	cmpb   $0x8,(%eax)
  80e8ea:	0f 85 e3 02 00 00    	jne    80ebd3 <icmp_input+0x33b>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e8f0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8f3:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e8f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e8fa:	83 c0 10             	add    $0x10,%eax
  80e8fd:	89 04 24             	mov    %eax,(%esp)
  80e900:	e8 bb 80 ff ff       	call   8069c0 <ip_addr_isbroadcast>
  80e905:	84 c0                	test   %al,%al
  80e907:	75 2c                	jne    80e935 <icmp_input+0x9d>
  80e909:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e90c:	8b 49 10             	mov    0x10(%ecx),%ecx
  80e90f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e912:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80e919:	e8 d5 95 ff ff       	call   807ef3 <ntohl>
  80e91e:	23 45 e0             	and    -0x20(%ebp),%eax
  80e921:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e924:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e92b:	e8 c3 95 ff ff       	call   807ef3 <ntohl>
  80e930:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e933:	75 0d                	jne    80e942 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80e935:	89 34 24             	mov    %esi,(%esp)
  80e938:	e8 38 64 ff ff       	call   804d75 <pbuf_free>
      return;
  80e93d:	e9 ad 02 00 00       	jmp    80ebef <icmp_input+0x357>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e942:	66 83 7e 08 07       	cmpw   $0x7,0x8(%esi)
  80e947:	0f 86 90 02 00 00    	jbe    80ebdd <icmp_input+0x345>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80e94d:	89 34 24             	mov    %esi,(%esp)
  80e950:	e8 08 92 ff ff       	call   807b5d <inet_chksum_pbuf>
  80e955:	66 85 c0             	test   %ax,%ax
  80e958:	74 0d                	je     80e967 <icmp_input+0xcf>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80e95a:	89 34 24             	mov    %esi,(%esp)
  80e95d:	e8 13 64 ff ff       	call   804d75 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80e962:	e9 88 02 00 00       	jmp    80ebef <icmp_input+0x357>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e967:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80e96e:	00 
  80e96f:	89 34 24             	mov    %esi,(%esp)
  80e972:	e8 19 63 ff ff       	call   804c90 <pbuf_header>
  80e977:	84 c0                	test   %al,%al
  80e979:	0f 84 f4 00 00 00    	je     80ea73 <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80e97f:	0f bf c7             	movswl %di,%eax
  80e982:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e986:	89 34 24             	mov    %esi,(%esp)
  80e989:	e8 02 63 ff ff       	call   804c90 <pbuf_header>
  80e98e:	84 c0                	test   %al,%al
  80e990:	74 1c                	je     80e9ae <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e992:	c7 44 24 08 a8 2e 81 	movl   $0x812ea8,0x8(%esp)
  80e999:	00 
  80e99a:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80e9a1:	00 
  80e9a2:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80e9a9:	e8 ca 04 00 00       	call   80ee78 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e9ae:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9b5:	00 
  80e9b6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e9ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e9be:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e9c5:	e8 ac 65 ff ff       	call   804f76 <pbuf_alloc>
  80e9ca:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e9cd:	85 c0                	test   %eax,%eax
  80e9cf:	0f 84 12 02 00 00    	je     80ebe7 <icmp_input+0x34f>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e9d5:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e9d9:	0f bf c7             	movswl %di,%eax
  80e9dc:	83 c0 08             	add    $0x8,%eax
  80e9df:	39 c2                	cmp    %eax,%edx
  80e9e1:	73 1c                	jae    80e9ff <icmp_input+0x167>
  80e9e3:	c7 44 24 08 dc 2e 81 	movl   $0x812edc,0x8(%esp)
  80e9ea:	00 
  80e9eb:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80e9f2:	00 
  80e9f3:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80e9fa:	e8 79 04 00 00       	call   80ee78 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80e9ff:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ea03:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea06:	89 04 24             	mov    %eax,(%esp)
  80ea09:	e8 4f 69 ff ff       	call   80535d <pbuf_copy>
  80ea0e:	84 c0                	test   %al,%al
  80ea10:	74 1c                	je     80ea2e <icmp_input+0x196>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80ea12:	c7 44 24 08 14 2f 81 	movl   $0x812f14,0x8(%esp)
  80ea19:	00 
  80ea1a:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80ea21:	00 
  80ea22:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80ea29:	e8 4a 04 00 00       	call   80ee78 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80ea2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea31:	8b 40 04             	mov    0x4(%eax),%eax
  80ea34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80ea37:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ea3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea3e:	89 04 24             	mov    %eax,(%esp)
  80ea41:	e8 4a 62 ff ff       	call   804c90 <pbuf_header>
  80ea46:	84 c0                	test   %al,%al
  80ea48:	74 1c                	je     80ea66 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ea4a:	c7 44 24 08 3c 2f 81 	movl   $0x812f3c,0x8(%esp)
  80ea51:	00 
  80ea52:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ea59:	00 
  80ea5a:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80ea61:	e8 12 04 00 00       	call   80ee78 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80ea66:	89 34 24             	mov    %esi,(%esp)
  80ea69:	e8 07 63 ff ff       	call   804d75 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80ea6e:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80ea71:	eb 30                	jmp    80eaa3 <icmp_input+0x20b>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80ea73:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80ea7a:	ff 
  80ea7b:	89 34 24             	mov    %esi,(%esp)
  80ea7e:	e8 0d 62 ff ff       	call   804c90 <pbuf_header>
  80ea83:	84 c0                	test   %al,%al
  80ea85:	74 1c                	je     80eaa3 <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ea87:	c7 44 24 08 3c 2f 81 	movl   $0x812f3c,0x8(%esp)
  80ea8e:	00 
  80ea8f:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80ea96:	00 
  80ea97:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80ea9e:	e8 d5 03 00 00       	call   80ee78 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80eaa3:	8b 56 04             	mov    0x4(%esi),%edx
  80eaa6:	89 55 e0             	mov    %edx,-0x20(%ebp)
    tmpaddr.addr = iphdr->src.addr;
  80eaa9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eaac:	8b 41 0c             	mov    0xc(%ecx),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80eaaf:	8b 51 10             	mov    0x10(%ecx),%edx
  80eab2:	89 51 0c             	mov    %edx,0xc(%ecx)
    iphdr->dest.addr = tmpaddr.addr;
  80eab5:	89 41 10             	mov    %eax,0x10(%ecx)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80eab8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eabb:	0f b7 02             	movzwl (%edx),%eax
  80eabe:	89 04 24             	mov    %eax,(%esp)
  80eac1:	e8 c3 91 ff ff       	call   807c89 <ntohs>
  80eac6:	0f b6 c0             	movzbl %al,%eax
  80eac9:	89 04 24             	mov    %eax,(%esp)
  80eacc:	e8 ac 91 ff ff       	call   807c7d <htons>
  80ead1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ead4:	66 89 01             	mov    %ax,(%ecx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80ead7:	66 8b 59 02          	mov    0x2(%ecx),%bx
  80eadb:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80eae2:	e8 96 91 ff ff       	call   807c7d <htons>
  80eae7:	66 39 c3             	cmp    %ax,%bx
  80eaea:	72 20                	jb     80eb0c <icmp_input+0x274>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80eaec:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eaef:	66 8b 58 02          	mov    0x2(%eax),%bx
  80eaf3:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80eafa:	e8 7e 91 ff ff       	call   807c7d <htons>
  80eaff:	8d 44 03 01          	lea    0x1(%ebx,%eax,1),%eax
  80eb03:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eb06:	66 89 42 02          	mov    %ax,0x2(%edx)
  80eb0a:	eb 1c                	jmp    80eb28 <icmp_input+0x290>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80eb0c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eb0f:	66 8b 59 02          	mov    0x2(%ecx),%bx
  80eb13:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80eb1a:	e8 5e 91 ff ff       	call   807c7d <htons>
  80eb1f:	01 d8                	add    %ebx,%eax
  80eb21:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eb24:	66 89 42 02          	mov    %ax,0x2(%edx)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80eb28:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eb2b:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
  80eb2f:	89 04 24             	mov    %eax,(%esp)
  80eb32:	e8 52 91 ff ff       	call   807c89 <ntohs>
  80eb37:	0d 00 ff ff ff       	or     $0xffffff00,%eax
  80eb3c:	0f b7 c0             	movzwl %ax,%eax
  80eb3f:	89 04 24             	mov    %eax,(%esp)
  80eb42:	e8 36 91 ff ff       	call   807c7d <htons>
  80eb47:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80eb4a:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_CHKSUM_SET(iphdr, 0);
  80eb4e:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80eb54:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80eb5b:	00 
  80eb5c:	89 14 24             	mov    %edx,(%esp)
  80eb5f:	e8 e3 8f ff ff       	call   807b47 <inet_chksum>
  80eb64:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eb67:	66 89 41 0a          	mov    %ax,0xa(%ecx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80eb6b:	0f bf ff             	movswl %di,%edi
  80eb6e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eb72:	89 34 24             	mov    %esi,(%esp)
  80eb75:	e8 16 61 ff ff       	call   804c90 <pbuf_header>
  80eb7a:	84 c0                	test   %al,%al
  80eb7c:	74 1c                	je     80eb9a <icmp_input+0x302>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80eb7e:	c7 44 24 08 94 1f 81 	movl   $0x811f94,0x8(%esp)
  80eb85:	00 
  80eb86:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80eb8d:	00 
  80eb8e:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80eb95:	e8 de 02 00 00       	call   80ee78 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80eb9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb9d:	89 44 24 18          	mov    %eax,0x18(%esp)
  80eba1:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eba8:	00 
  80eba9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ebb0:	00 
  80ebb1:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ebb8:	00 
  80ebb9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ebc0:	00 
  80ebc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ebc4:	83 c0 0c             	add    $0xc,%eax
  80ebc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebcb:	89 34 24             	mov    %esi,(%esp)
  80ebce:	e8 31 81 ff ff       	call   806d04 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80ebd3:	89 34 24             	mov    %esi,(%esp)
  80ebd6:	e8 9a 61 ff ff       	call   804d75 <pbuf_free>
  return;
  80ebdb:	eb 12                	jmp    80ebef <icmp_input+0x357>
lenerr:
  pbuf_free(p);
  80ebdd:	89 34 24             	mov    %esi,(%esp)
  80ebe0:	e8 90 61 ff ff       	call   804d75 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80ebe5:	eb 08                	jmp    80ebef <icmp_input+0x357>
memerr:
  pbuf_free(p);
  80ebe7:	89 34 24             	mov    %esi,(%esp)
  80ebea:	e8 86 61 ff ff       	call   804d75 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80ebef:	83 c4 3c             	add    $0x3c,%esp
  80ebf2:	5b                   	pop    %ebx
  80ebf3:	5e                   	pop    %esi
  80ebf4:	5f                   	pop    %edi
  80ebf5:	5d                   	pop    %ebp
  80ebf6:	c3                   	ret    

0080ebf7 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80ebf7:	55                   	push   %ebp
  80ebf8:	89 e5                	mov    %esp,%ebp
  80ebfa:	57                   	push   %edi
  80ebfb:	56                   	push   %esi
  80ebfc:	53                   	push   %ebx
  80ebfd:	83 ec 3c             	sub    $0x3c,%esp
  80ec00:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ec03:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ec0a:	00 
  80ec0b:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ec12:	00 
  80ec13:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ec1a:	e8 57 63 ff ff       	call   804f76 <pbuf_alloc>
  80ec1f:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ec21:	85 c0                	test   %eax,%eax
  80ec23:	0f 84 d7 00 00 00    	je     80ed00 <icmp_dest_unreach+0x109>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ec29:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ec2e:	77 1c                	ja     80ec4c <icmp_dest_unreach+0x55>
  80ec30:	c7 44 24 08 70 2f 81 	movl   $0x812f70,0x8(%esp)
  80ec37:	00 
  80ec38:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80ec3f:	00 
  80ec40:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80ec47:	e8 2c 02 00 00       	call   80ee78 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ec4c:	8b 47 04             	mov    0x4(%edi),%eax
  80ec4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ec52:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ec55:	0f b7 06             	movzwl (%esi),%eax
  80ec58:	89 04 24             	mov    %eax,(%esp)
  80ec5b:	e8 29 90 ff ff       	call   807c89 <ntohs>
  80ec60:	0f b6 c0             	movzbl %al,%eax
  80ec63:	80 cc 03             	or     $0x3,%ah
  80ec66:	89 04 24             	mov    %eax,(%esp)
  80ec69:	e8 0f 90 ff ff       	call   807c7d <htons>
  80ec6e:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ec71:	0f b7 c0             	movzwl %ax,%eax
  80ec74:	89 04 24             	mov    %eax,(%esp)
  80ec77:	e8 0d 90 ff ff       	call   807c89 <ntohs>
  80ec7c:	b0 00                	mov    $0x0,%al
  80ec7e:	0b 45 0c             	or     0xc(%ebp),%eax
  80ec81:	0f b7 c0             	movzwl %ax,%eax
  80ec84:	89 04 24             	mov    %eax,(%esp)
  80ec87:	e8 f1 8f ff ff       	call   807c7d <htons>
  80ec8c:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80ec8f:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ec96:	00 
  80ec97:	8b 47 04             	mov    0x4(%edi),%eax
  80ec9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ec9e:	8b 43 04             	mov    0x4(%ebx),%eax
  80eca1:	83 c0 08             	add    $0x8,%eax
  80eca4:	89 04 24             	mov    %eax,(%esp)
  80eca7:	e8 52 0a 00 00       	call   80f6fe <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80ecac:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80ecb2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ecb6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ecba:	89 34 24             	mov    %esi,(%esp)
  80ecbd:	e8 85 8e ff ff       	call   807b47 <inet_chksum>
  80ecc2:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80ecc6:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eccd:	00 
  80ecce:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ecd5:	00 
  80ecd6:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ecdd:	00 
  80ecde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ece1:	83 c0 0c             	add    $0xc,%eax
  80ece4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ece8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ecef:	00 
  80ecf0:	89 1c 24             	mov    %ebx,(%esp)
  80ecf3:	e8 93 81 ff ff       	call   806e8b <ip_output>
  pbuf_free(q);
  80ecf8:	89 1c 24             	mov    %ebx,(%esp)
  80ecfb:	e8 75 60 ff ff       	call   804d75 <pbuf_free>
}
  80ed00:	83 c4 3c             	add    $0x3c,%esp
  80ed03:	5b                   	pop    %ebx
  80ed04:	5e                   	pop    %esi
  80ed05:	5f                   	pop    %edi
  80ed06:	5d                   	pop    %ebp
  80ed07:	c3                   	ret    

0080ed08 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80ed08:	55                   	push   %ebp
  80ed09:	89 e5                	mov    %esp,%ebp
  80ed0b:	57                   	push   %edi
  80ed0c:	56                   	push   %esi
  80ed0d:	53                   	push   %ebx
  80ed0e:	83 ec 3c             	sub    $0x3c,%esp
  80ed11:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ed14:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ed1b:	00 
  80ed1c:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ed23:	00 
  80ed24:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ed2b:	e8 46 62 ff ff       	call   804f76 <pbuf_alloc>
  80ed30:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ed32:	85 c0                	test   %eax,%eax
  80ed34:	0f 84 d7 00 00 00    	je     80ee11 <icmp_time_exceeded+0x109>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ed3a:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ed3f:	77 1c                	ja     80ed5d <icmp_time_exceeded+0x55>
  80ed41:	c7 44 24 08 70 2f 81 	movl   $0x812f70,0x8(%esp)
  80ed48:	00 
  80ed49:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ed50:	00 
  80ed51:	c7 04 24 9c 2f 81 00 	movl   $0x812f9c,(%esp)
  80ed58:	e8 1b 01 00 00       	call   80ee78 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ed5d:	8b 47 04             	mov    0x4(%edi),%eax
  80ed60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ed63:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ed66:	0f b7 06             	movzwl (%esi),%eax
  80ed69:	89 04 24             	mov    %eax,(%esp)
  80ed6c:	e8 18 8f ff ff       	call   807c89 <ntohs>
  80ed71:	0f b6 c0             	movzbl %al,%eax
  80ed74:	80 cc 0b             	or     $0xb,%ah
  80ed77:	89 04 24             	mov    %eax,(%esp)
  80ed7a:	e8 fe 8e ff ff       	call   807c7d <htons>
  80ed7f:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80ed82:	0f b7 c0             	movzwl %ax,%eax
  80ed85:	89 04 24             	mov    %eax,(%esp)
  80ed88:	e8 fc 8e ff ff       	call   807c89 <ntohs>
  80ed8d:	b0 00                	mov    $0x0,%al
  80ed8f:	0b 45 0c             	or     0xc(%ebp),%eax
  80ed92:	0f b7 c0             	movzwl %ax,%eax
  80ed95:	89 04 24             	mov    %eax,(%esp)
  80ed98:	e8 e0 8e ff ff       	call   807c7d <htons>
  80ed9d:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80eda0:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80eda7:	00 
  80eda8:	8b 47 04             	mov    0x4(%edi),%eax
  80edab:	89 44 24 04          	mov    %eax,0x4(%esp)
  80edaf:	8b 43 04             	mov    0x4(%ebx),%eax
  80edb2:	83 c0 08             	add    $0x8,%eax
  80edb5:	89 04 24             	mov    %eax,(%esp)
  80edb8:	e8 41 09 00 00       	call   80f6fe <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80edbd:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80edc3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80edc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80edcb:	89 34 24             	mov    %esi,(%esp)
  80edce:	e8 74 8d ff ff       	call   807b47 <inet_chksum>
  80edd3:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80edd7:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80edde:	00 
  80eddf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ede6:	00 
  80ede7:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80edee:	00 
  80edef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80edf2:	83 c0 0c             	add    $0xc,%eax
  80edf5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80edf9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ee00:	00 
  80ee01:	89 1c 24             	mov    %ebx,(%esp)
  80ee04:	e8 82 80 ff ff       	call   806e8b <ip_output>
  pbuf_free(q);
  80ee09:	89 1c 24             	mov    %ebx,(%esp)
  80ee0c:	e8 64 5f ff ff       	call   804d75 <pbuf_free>
}
  80ee11:	83 c4 3c             	add    $0x3c,%esp
  80ee14:	5b                   	pop    %ebx
  80ee15:	5e                   	pop    %esi
  80ee16:	5f                   	pop    %edi
  80ee17:	5d                   	pop    %ebp
  80ee18:	c3                   	ret    
  80ee19:	00 00                	add    %al,(%eax)
	...

0080ee1c <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80ee1c:	55                   	push   %ebp
  80ee1d:	89 e5                	mov    %esp,%ebp
  80ee1f:	56                   	push   %esi
  80ee20:	53                   	push   %ebx
  80ee21:	83 ec 10             	sub    $0x10,%esp
  80ee24:	8b 75 08             	mov    0x8(%ebp),%esi
  80ee27:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80ee2a:	e8 a0 0a 00 00       	call   80f8cf <sys_getenvid>
  80ee2f:	25 ff 03 00 00       	and    $0x3ff,%eax
  80ee34:	c1 e0 07             	shl    $0x7,%eax
  80ee37:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80ee3c:	a3 9c b2 b3 00       	mov    %eax,0xb3b29c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80ee41:	85 f6                	test   %esi,%esi
  80ee43:	7e 07                	jle    80ee4c <libmain+0x30>
		binaryname = argv[0];
  80ee45:	8b 03                	mov    (%ebx),%eax
  80ee47:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80ee4c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ee50:	89 34 24             	mov    %esi,(%esp)
  80ee53:	e8 ea 17 ff ff       	call   800642 <umain>

	// exit gracefully
	exit();
  80ee58:	e8 07 00 00 00       	call   80ee64 <exit>
}
  80ee5d:	83 c4 10             	add    $0x10,%esp
  80ee60:	5b                   	pop    %ebx
  80ee61:	5e                   	pop    %esi
  80ee62:	5d                   	pop    %ebp
  80ee63:	c3                   	ret    

0080ee64 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80ee64:	55                   	push   %ebp
  80ee65:	89 e5                	mov    %esp,%ebp
  80ee67:	83 ec 18             	sub    $0x18,%esp
	//close_all();
	sys_env_destroy(0);
  80ee6a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ee71:	e8 07 0a 00 00       	call   80f87d <sys_env_destroy>
}
  80ee76:	c9                   	leave  
  80ee77:	c3                   	ret    

0080ee78 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80ee78:	55                   	push   %ebp
  80ee79:	89 e5                	mov    %esp,%ebp
  80ee7b:	56                   	push   %esi
  80ee7c:	53                   	push   %ebx
  80ee7d:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  80ee80:	8d 75 14             	lea    0x14(%ebp),%esi

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80ee83:	8b 1d e8 42 81 00    	mov    0x8142e8,%ebx
  80ee89:	e8 41 0a 00 00       	call   80f8cf <sys_getenvid>
  80ee8e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ee91:	89 54 24 10          	mov    %edx,0x10(%esp)
  80ee95:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee98:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80ee9c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80eea0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eea4:	c7 04 24 c0 2f 81 00 	movl   $0x812fc0,(%esp)
  80eeab:	e8 c0 00 00 00       	call   80ef70 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80eeb0:	89 74 24 04          	mov    %esi,0x4(%esp)
  80eeb4:	8b 45 10             	mov    0x10(%ebp),%eax
  80eeb7:	89 04 24             	mov    %eax,(%esp)
  80eeba:	e8 50 00 00 00       	call   80ef0f <vcprintf>
	cprintf("\n");
  80eebf:	c7 04 24 c8 0a 81 00 	movl   $0x810ac8,(%esp)
  80eec6:	e8 a5 00 00 00       	call   80ef70 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80eecb:	cc                   	int3   
  80eecc:	eb fd                	jmp    80eecb <_panic+0x53>
	...

0080eed0 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80eed0:	55                   	push   %ebp
  80eed1:	89 e5                	mov    %esp,%ebp
  80eed3:	53                   	push   %ebx
  80eed4:	83 ec 14             	sub    $0x14,%esp
  80eed7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80eeda:	8b 03                	mov    (%ebx),%eax
  80eedc:	8b 55 08             	mov    0x8(%ebp),%edx
  80eedf:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  80eee3:	40                   	inc    %eax
  80eee4:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  80eee6:	3d ff 00 00 00       	cmp    $0xff,%eax
  80eeeb:	75 19                	jne    80ef06 <putch+0x36>
		sys_cputs(b->buf, b->idx);
  80eeed:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80eef4:	00 
  80eef5:	8d 43 08             	lea    0x8(%ebx),%eax
  80eef8:	89 04 24             	mov    %eax,(%esp)
  80eefb:	e8 40 09 00 00       	call   80f840 <sys_cputs>
		b->idx = 0;
  80ef00:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80ef06:	ff 43 04             	incl   0x4(%ebx)
}
  80ef09:	83 c4 14             	add    $0x14,%esp
  80ef0c:	5b                   	pop    %ebx
  80ef0d:	5d                   	pop    %ebp
  80ef0e:	c3                   	ret    

0080ef0f <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80ef0f:	55                   	push   %ebp
  80ef10:	89 e5                	mov    %esp,%ebp
  80ef12:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80ef18:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80ef1f:	00 00 00 
	b.cnt = 0;
  80ef22:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80ef29:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80ef2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ef2f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ef33:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef36:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ef3a:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80ef40:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef44:	c7 04 24 d0 ee 80 00 	movl   $0x80eed0,(%esp)
  80ef4b:	e8 82 01 00 00       	call   80f0d2 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80ef50:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80ef56:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef5a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80ef60:	89 04 24             	mov    %eax,(%esp)
  80ef63:	e8 d8 08 00 00       	call   80f840 <sys_cputs>

	return b.cnt;
}
  80ef68:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80ef6e:	c9                   	leave  
  80ef6f:	c3                   	ret    

0080ef70 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80ef70:	55                   	push   %ebp
  80ef71:	89 e5                	mov    %esp,%ebp
  80ef73:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80ef76:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80ef79:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ef7d:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef80:	89 04 24             	mov    %eax,(%esp)
  80ef83:	e8 87 ff ff ff       	call   80ef0f <vcprintf>
	va_end(ap);

	return cnt;
}
  80ef88:	c9                   	leave  
  80ef89:	c3                   	ret    
	...

0080ef8c <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80ef8c:	55                   	push   %ebp
  80ef8d:	89 e5                	mov    %esp,%ebp
  80ef8f:	57                   	push   %edi
  80ef90:	56                   	push   %esi
  80ef91:	53                   	push   %ebx
  80ef92:	83 ec 3c             	sub    $0x3c,%esp
  80ef95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ef98:	89 d7                	mov    %edx,%edi
  80ef9a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef9d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80efa0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80efa3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80efa6:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80efa9:	8b 75 18             	mov    0x18(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80efac:	85 c0                	test   %eax,%eax
  80efae:	75 08                	jne    80efb8 <printnum+0x2c>
  80efb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80efb3:	39 45 10             	cmp    %eax,0x10(%ebp)
  80efb6:	77 57                	ja     80f00f <printnum+0x83>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80efb8:	89 74 24 10          	mov    %esi,0x10(%esp)
  80efbc:	4b                   	dec    %ebx
  80efbd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80efc1:	8b 45 10             	mov    0x10(%ebp),%eax
  80efc4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80efc8:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  80efcc:	8b 74 24 0c          	mov    0xc(%esp),%esi
  80efd0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80efd7:	00 
  80efd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80efdb:	89 04 24             	mov    %eax,(%esp)
  80efde:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80efe1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efe5:	e8 ea 16 00 00       	call   8106d4 <__udivdi3>
  80efea:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80efee:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80eff2:	89 04 24             	mov    %eax,(%esp)
  80eff5:	89 54 24 04          	mov    %edx,0x4(%esp)
  80eff9:	89 fa                	mov    %edi,%edx
  80effb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80effe:	e8 89 ff ff ff       	call   80ef8c <printnum>
  80f003:	eb 0f                	jmp    80f014 <printnum+0x88>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f005:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f009:	89 34 24             	mov    %esi,(%esp)
  80f00c:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f00f:	4b                   	dec    %ebx
  80f010:	85 db                	test   %ebx,%ebx
  80f012:	7f f1                	jg     80f005 <printnum+0x79>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f014:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f018:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80f01c:	8b 45 10             	mov    0x10(%ebp),%eax
  80f01f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f023:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80f02a:	00 
  80f02b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f02e:	89 04 24             	mov    %eax,(%esp)
  80f031:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f034:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f038:	e8 b7 17 00 00       	call   8107f4 <__umoddi3>
  80f03d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f041:	0f be 80 e3 2f 81 00 	movsbl 0x812fe3(%eax),%eax
  80f048:	89 04 24             	mov    %eax,(%esp)
  80f04b:	ff 55 e4             	call   *-0x1c(%ebp)
}
  80f04e:	83 c4 3c             	add    $0x3c,%esp
  80f051:	5b                   	pop    %ebx
  80f052:	5e                   	pop    %esi
  80f053:	5f                   	pop    %edi
  80f054:	5d                   	pop    %ebp
  80f055:	c3                   	ret    

0080f056 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80f056:	55                   	push   %ebp
  80f057:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80f059:	83 fa 01             	cmp    $0x1,%edx
  80f05c:	7e 0e                	jle    80f06c <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80f05e:	8b 10                	mov    (%eax),%edx
  80f060:	8d 4a 08             	lea    0x8(%edx),%ecx
  80f063:	89 08                	mov    %ecx,(%eax)
  80f065:	8b 02                	mov    (%edx),%eax
  80f067:	8b 52 04             	mov    0x4(%edx),%edx
  80f06a:	eb 22                	jmp    80f08e <getuint+0x38>
	else if (lflag)
  80f06c:	85 d2                	test   %edx,%edx
  80f06e:	74 10                	je     80f080 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80f070:	8b 10                	mov    (%eax),%edx
  80f072:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f075:	89 08                	mov    %ecx,(%eax)
  80f077:	8b 02                	mov    (%edx),%eax
  80f079:	ba 00 00 00 00       	mov    $0x0,%edx
  80f07e:	eb 0e                	jmp    80f08e <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80f080:	8b 10                	mov    (%eax),%edx
  80f082:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f085:	89 08                	mov    %ecx,(%eax)
  80f087:	8b 02                	mov    (%edx),%eax
  80f089:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80f08e:	5d                   	pop    %ebp
  80f08f:	c3                   	ret    

0080f090 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f090:	55                   	push   %ebp
  80f091:	89 e5                	mov    %esp,%ebp
  80f093:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f096:	ff 40 08             	incl   0x8(%eax)
	if (b->buf < b->ebuf)
  80f099:	8b 10                	mov    (%eax),%edx
  80f09b:	3b 50 04             	cmp    0x4(%eax),%edx
  80f09e:	73 08                	jae    80f0a8 <sprintputch+0x18>
		*b->buf++ = ch;
  80f0a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f0a3:	88 0a                	mov    %cl,(%edx)
  80f0a5:	42                   	inc    %edx
  80f0a6:	89 10                	mov    %edx,(%eax)
}
  80f0a8:	5d                   	pop    %ebp
  80f0a9:	c3                   	ret    

0080f0aa <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f0aa:	55                   	push   %ebp
  80f0ab:	89 e5                	mov    %esp,%ebp
  80f0ad:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  80f0b0:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80f0b3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f0b7:	8b 45 10             	mov    0x10(%ebp),%eax
  80f0ba:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f0be:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f0c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0c5:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0c8:	89 04 24             	mov    %eax,(%esp)
  80f0cb:	e8 02 00 00 00       	call   80f0d2 <vprintfmt>
	va_end(ap);
}
  80f0d0:	c9                   	leave  
  80f0d1:	c3                   	ret    

0080f0d2 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f0d2:	55                   	push   %ebp
  80f0d3:	89 e5                	mov    %esp,%ebp
  80f0d5:	57                   	push   %edi
  80f0d6:	56                   	push   %esi
  80f0d7:	53                   	push   %ebx
  80f0d8:	83 ec 4c             	sub    $0x4c,%esp
  80f0db:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f0de:	8b 75 10             	mov    0x10(%ebp),%esi
  80f0e1:	eb 12                	jmp    80f0f5 <vprintfmt+0x23>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80f0e3:	85 c0                	test   %eax,%eax
  80f0e5:	0f 84 6b 03 00 00    	je     80f456 <vprintfmt+0x384>
				return;
			putch(ch, putdat);
  80f0eb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f0ef:	89 04 24             	mov    %eax,(%esp)
  80f0f2:	ff 55 08             	call   *0x8(%ebp)
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80f0f5:	0f b6 06             	movzbl (%esi),%eax
  80f0f8:	46                   	inc    %esi
  80f0f9:	83 f8 25             	cmp    $0x25,%eax
  80f0fc:	75 e5                	jne    80f0e3 <vprintfmt+0x11>
  80f0fe:	c6 45 d8 20          	movb   $0x20,-0x28(%ebp)
  80f102:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80f109:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80f10e:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  80f115:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f11a:	eb 26                	jmp    80f142 <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f11c:	8b 75 e0             	mov    -0x20(%ebp),%esi

		// flag to pad on the right
		case '-':
			padc = '-';
  80f11f:	c6 45 d8 2d          	movb   $0x2d,-0x28(%ebp)
  80f123:	eb 1d                	jmp    80f142 <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f125:	8b 75 e0             	mov    -0x20(%ebp),%esi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80f128:	c6 45 d8 30          	movb   $0x30,-0x28(%ebp)
  80f12c:	eb 14                	jmp    80f142 <vprintfmt+0x70>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f12e:	8b 75 e0             	mov    -0x20(%ebp),%esi
			precision = va_arg(ap, int);
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
  80f131:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80f138:	eb 08                	jmp    80f142 <vprintfmt+0x70>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  80f13a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80f13d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f142:	0f b6 06             	movzbl (%esi),%eax
  80f145:	8d 56 01             	lea    0x1(%esi),%edx
  80f148:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80f14b:	8a 16                	mov    (%esi),%dl
  80f14d:	83 ea 23             	sub    $0x23,%edx
  80f150:	80 fa 55             	cmp    $0x55,%dl
  80f153:	0f 87 e1 02 00 00    	ja     80f43a <vprintfmt+0x368>
  80f159:	0f b6 d2             	movzbl %dl,%edx
  80f15c:	ff 24 95 20 31 81 00 	jmp    *0x813120(,%edx,4)
  80f163:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f166:	bf 00 00 00 00       	mov    $0x0,%edi
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f16b:	8d 14 bf             	lea    (%edi,%edi,4),%edx
  80f16e:	8d 7c 50 d0          	lea    -0x30(%eax,%edx,2),%edi
				ch = *fmt;
  80f172:	0f be 06             	movsbl (%esi),%eax
				if (ch < '0' || ch > '9')
  80f175:	8d 50 d0             	lea    -0x30(%eax),%edx
  80f178:	83 fa 09             	cmp    $0x9,%edx
  80f17b:	77 2a                	ja     80f1a7 <vprintfmt+0xd5>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f17d:	46                   	inc    %esi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f17e:	eb eb                	jmp    80f16b <vprintfmt+0x99>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f180:	8b 45 14             	mov    0x14(%ebp),%eax
  80f183:	8d 50 04             	lea    0x4(%eax),%edx
  80f186:	89 55 14             	mov    %edx,0x14(%ebp)
  80f189:	8b 38                	mov    (%eax),%edi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f18b:	8b 75 e0             	mov    -0x20(%ebp),%esi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80f18e:	eb 17                	jmp    80f1a7 <vprintfmt+0xd5>

		case '.':
			if (width < 0)
  80f190:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f194:	78 98                	js     80f12e <vprintfmt+0x5c>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f196:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f199:	eb a7                	jmp    80f142 <vprintfmt+0x70>
  80f19b:	8b 75 e0             	mov    -0x20(%ebp),%esi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80f19e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
  80f1a5:	eb 9b                	jmp    80f142 <vprintfmt+0x70>

		process_precision:
			if (width < 0)
  80f1a7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f1ab:	79 95                	jns    80f142 <vprintfmt+0x70>
  80f1ad:	eb 8b                	jmp    80f13a <vprintfmt+0x68>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f1af:	41                   	inc    %ecx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f1b0:	8b 75 e0             	mov    -0x20(%ebp),%esi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80f1b3:	eb 8d                	jmp    80f142 <vprintfmt+0x70>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f1b5:	8b 45 14             	mov    0x14(%ebp),%eax
  80f1b8:	8d 50 04             	lea    0x4(%eax),%edx
  80f1bb:	89 55 14             	mov    %edx,0x14(%ebp)
  80f1be:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f1c2:	8b 00                	mov    (%eax),%eax
  80f1c4:	89 04 24             	mov    %eax,(%esp)
  80f1c7:	ff 55 08             	call   *0x8(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f1ca:	8b 75 e0             	mov    -0x20(%ebp),%esi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80f1cd:	e9 23 ff ff ff       	jmp    80f0f5 <vprintfmt+0x23>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f1d2:	8b 45 14             	mov    0x14(%ebp),%eax
  80f1d5:	8d 50 04             	lea    0x4(%eax),%edx
  80f1d8:	89 55 14             	mov    %edx,0x14(%ebp)
  80f1db:	8b 00                	mov    (%eax),%eax
  80f1dd:	85 c0                	test   %eax,%eax
  80f1df:	79 02                	jns    80f1e3 <vprintfmt+0x111>
  80f1e1:	f7 d8                	neg    %eax
  80f1e3:	89 c2                	mov    %eax,%edx
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f1e5:	83 f8 11             	cmp    $0x11,%eax
  80f1e8:	7f 0b                	jg     80f1f5 <vprintfmt+0x123>
  80f1ea:	8b 04 85 80 32 81 00 	mov    0x813280(,%eax,4),%eax
  80f1f1:	85 c0                	test   %eax,%eax
  80f1f3:	75 23                	jne    80f218 <vprintfmt+0x146>
				printfmt(putch, putdat, "error %d", err);
  80f1f5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f1f9:	c7 44 24 08 fb 2f 81 	movl   $0x812ffb,0x8(%esp)
  80f200:	00 
  80f201:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f205:	8b 45 08             	mov    0x8(%ebp),%eax
  80f208:	89 04 24             	mov    %eax,(%esp)
  80f20b:	e8 9a fe ff ff       	call   80f0aa <printfmt>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f210:	8b 75 e0             	mov    -0x20(%ebp),%esi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80f213:	e9 dd fe ff ff       	jmp    80f0f5 <vprintfmt+0x23>
			else
				printfmt(putch, putdat, "%s", p);
  80f218:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f21c:	c7 44 24 08 c9 21 81 	movl   $0x8121c9,0x8(%esp)
  80f223:	00 
  80f224:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f228:	8b 55 08             	mov    0x8(%ebp),%edx
  80f22b:	89 14 24             	mov    %edx,(%esp)
  80f22e:	e8 77 fe ff ff       	call   80f0aa <printfmt>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f233:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f236:	e9 ba fe ff ff       	jmp    80f0f5 <vprintfmt+0x23>
  80f23b:	89 f9                	mov    %edi,%ecx
  80f23d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f240:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f243:	8b 45 14             	mov    0x14(%ebp),%eax
  80f246:	8d 50 04             	lea    0x4(%eax),%edx
  80f249:	89 55 14             	mov    %edx,0x14(%ebp)
  80f24c:	8b 30                	mov    (%eax),%esi
  80f24e:	85 f6                	test   %esi,%esi
  80f250:	75 05                	jne    80f257 <vprintfmt+0x185>
				p = "(null)";
  80f252:	be f4 2f 81 00       	mov    $0x812ff4,%esi
			if (width > 0 && padc != '-')
  80f257:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80f25b:	0f 8e 84 00 00 00    	jle    80f2e5 <vprintfmt+0x213>
  80f261:	80 7d d8 2d          	cmpb   $0x2d,-0x28(%ebp)
  80f265:	74 7e                	je     80f2e5 <vprintfmt+0x213>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f267:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f26b:	89 34 24             	mov    %esi,(%esp)
  80f26e:	e8 8b 02 00 00       	call   80f4fe <strnlen>
  80f273:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80f276:	29 c2                	sub    %eax,%edx
  80f278:	89 55 e4             	mov    %edx,-0x1c(%ebp)
					putch(padc, putdat);
  80f27b:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  80f27f:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80f282:	89 7d cc             	mov    %edi,-0x34(%ebp)
  80f285:	89 de                	mov    %ebx,%esi
  80f287:	89 d3                	mov    %edx,%ebx
  80f289:	89 c7                	mov    %eax,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f28b:	eb 0b                	jmp    80f298 <vprintfmt+0x1c6>
					putch(padc, putdat);
  80f28d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f291:	89 3c 24             	mov    %edi,(%esp)
  80f294:	ff 55 08             	call   *0x8(%ebp)
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f297:	4b                   	dec    %ebx
  80f298:	85 db                	test   %ebx,%ebx
  80f29a:	7f f1                	jg     80f28d <vprintfmt+0x1bb>
  80f29c:	8b 7d cc             	mov    -0x34(%ebp),%edi
  80f29f:	89 f3                	mov    %esi,%ebx
  80f2a1:	8b 75 d0             	mov    -0x30(%ebp),%esi

// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
  80f2a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f2a7:	85 c0                	test   %eax,%eax
  80f2a9:	79 05                	jns    80f2b0 <vprintfmt+0x1de>
  80f2ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f2b3:	29 c2                	sub    %eax,%edx
  80f2b5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80f2b8:	eb 2b                	jmp    80f2e5 <vprintfmt+0x213>
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f2ba:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f2be:	74 18                	je     80f2d8 <vprintfmt+0x206>
  80f2c0:	8d 50 e0             	lea    -0x20(%eax),%edx
  80f2c3:	83 fa 5e             	cmp    $0x5e,%edx
  80f2c6:	76 10                	jbe    80f2d8 <vprintfmt+0x206>
					putch('?', putdat);
  80f2c8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f2cc:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f2d3:	ff 55 08             	call   *0x8(%ebp)
  80f2d6:	eb 0a                	jmp    80f2e2 <vprintfmt+0x210>
				else
					putch(ch, putdat);
  80f2d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f2dc:	89 04 24             	mov    %eax,(%esp)
  80f2df:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f2e2:	ff 4d e4             	decl   -0x1c(%ebp)
  80f2e5:	0f be 06             	movsbl (%esi),%eax
  80f2e8:	46                   	inc    %esi
  80f2e9:	85 c0                	test   %eax,%eax
  80f2eb:	74 21                	je     80f30e <vprintfmt+0x23c>
  80f2ed:	85 ff                	test   %edi,%edi
  80f2ef:	78 c9                	js     80f2ba <vprintfmt+0x1e8>
  80f2f1:	4f                   	dec    %edi
  80f2f2:	79 c6                	jns    80f2ba <vprintfmt+0x1e8>
  80f2f4:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f2f7:	89 de                	mov    %ebx,%esi
  80f2f9:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f2fc:	eb 18                	jmp    80f316 <vprintfmt+0x244>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f2fe:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f302:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f309:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f30b:	4b                   	dec    %ebx
  80f30c:	eb 08                	jmp    80f316 <vprintfmt+0x244>
  80f30e:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f311:	89 de                	mov    %ebx,%esi
  80f313:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80f316:	85 db                	test   %ebx,%ebx
  80f318:	7f e4                	jg     80f2fe <vprintfmt+0x22c>
  80f31a:	89 7d 08             	mov    %edi,0x8(%ebp)
  80f31d:	89 f3                	mov    %esi,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f31f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f322:	e9 ce fd ff ff       	jmp    80f0f5 <vprintfmt+0x23>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f327:	83 f9 01             	cmp    $0x1,%ecx
  80f32a:	7e 10                	jle    80f33c <vprintfmt+0x26a>
		return va_arg(*ap, long long);
  80f32c:	8b 45 14             	mov    0x14(%ebp),%eax
  80f32f:	8d 50 08             	lea    0x8(%eax),%edx
  80f332:	89 55 14             	mov    %edx,0x14(%ebp)
  80f335:	8b 30                	mov    (%eax),%esi
  80f337:	8b 78 04             	mov    0x4(%eax),%edi
  80f33a:	eb 26                	jmp    80f362 <vprintfmt+0x290>
	else if (lflag)
  80f33c:	85 c9                	test   %ecx,%ecx
  80f33e:	74 12                	je     80f352 <vprintfmt+0x280>
		return va_arg(*ap, long);
  80f340:	8b 45 14             	mov    0x14(%ebp),%eax
  80f343:	8d 50 04             	lea    0x4(%eax),%edx
  80f346:	89 55 14             	mov    %edx,0x14(%ebp)
  80f349:	8b 30                	mov    (%eax),%esi
  80f34b:	89 f7                	mov    %esi,%edi
  80f34d:	c1 ff 1f             	sar    $0x1f,%edi
  80f350:	eb 10                	jmp    80f362 <vprintfmt+0x290>
	else
		return va_arg(*ap, int);
  80f352:	8b 45 14             	mov    0x14(%ebp),%eax
  80f355:	8d 50 04             	lea    0x4(%eax),%edx
  80f358:	89 55 14             	mov    %edx,0x14(%ebp)
  80f35b:	8b 30                	mov    (%eax),%esi
  80f35d:	89 f7                	mov    %esi,%edi
  80f35f:	c1 ff 1f             	sar    $0x1f,%edi
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80f362:	85 ff                	test   %edi,%edi
  80f364:	78 0a                	js     80f370 <vprintfmt+0x29e>
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80f366:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f36b:	e9 8c 00 00 00       	jmp    80f3fc <vprintfmt+0x32a>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
				putch('-', putdat);
  80f370:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f374:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f37b:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  80f37e:	f7 de                	neg    %esi
  80f380:	83 d7 00             	adc    $0x0,%edi
  80f383:	f7 df                	neg    %edi
			}
			base = 10;
  80f385:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f38a:	eb 70                	jmp    80f3fc <vprintfmt+0x32a>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80f38c:	89 ca                	mov    %ecx,%edx
  80f38e:	8d 45 14             	lea    0x14(%ebp),%eax
  80f391:	e8 c0 fc ff ff       	call   80f056 <getuint>
  80f396:	89 c6                	mov    %eax,%esi
  80f398:	89 d7                	mov    %edx,%edi
			base = 10;
  80f39a:	b8 0a 00 00 00       	mov    $0xa,%eax
			goto number;
  80f39f:	eb 5b                	jmp    80f3fc <vprintfmt+0x32a>
		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			//putch('X', putdat);
			//putch('0', putdat);
			num = getuint(&ap, lflag);
  80f3a1:	89 ca                	mov    %ecx,%edx
  80f3a3:	8d 45 14             	lea    0x14(%ebp),%eax
  80f3a6:	e8 ab fc ff ff       	call   80f056 <getuint>
  80f3ab:	89 c6                	mov    %eax,%esi
  80f3ad:	89 d7                	mov    %edx,%edi
			base = 8;
  80f3af:	b8 08 00 00 00       	mov    $0x8,%eax
			goto number;
  80f3b4:	eb 46                	jmp    80f3fc <vprintfmt+0x32a>
			//break;

		// pointer
		case 'p':
			putch('0', putdat);
  80f3b6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f3ba:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f3c1:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  80f3c4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f3c8:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f3cf:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80f3d2:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3d5:	8d 50 04             	lea    0x4(%eax),%edx
  80f3d8:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80f3db:	8b 30                	mov    (%eax),%esi
  80f3dd:	bf 00 00 00 00       	mov    $0x0,%edi
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80f3e2:	b8 10 00 00 00       	mov    $0x10,%eax
			goto number;
  80f3e7:	eb 13                	jmp    80f3fc <vprintfmt+0x32a>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80f3e9:	89 ca                	mov    %ecx,%edx
  80f3eb:	8d 45 14             	lea    0x14(%ebp),%eax
  80f3ee:	e8 63 fc ff ff       	call   80f056 <getuint>
  80f3f3:	89 c6                	mov    %eax,%esi
  80f3f5:	89 d7                	mov    %edx,%edi
			base = 16;
  80f3f7:	b8 10 00 00 00       	mov    $0x10,%eax
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f3fc:	0f be 55 d8          	movsbl -0x28(%ebp),%edx
  80f400:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f404:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f407:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f40b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f40f:	89 34 24             	mov    %esi,(%esp)
  80f412:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f416:	89 da                	mov    %ebx,%edx
  80f418:	8b 45 08             	mov    0x8(%ebp),%eax
  80f41b:	e8 6c fb ff ff       	call   80ef8c <printnum>
			break;
  80f420:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80f423:	e9 cd fc ff ff       	jmp    80f0f5 <vprintfmt+0x23>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f428:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f42c:	89 04 24             	mov    %eax,(%esp)
  80f42f:	ff 55 08             	call   *0x8(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f432:	8b 75 e0             	mov    -0x20(%ebp),%esi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80f435:	e9 bb fc ff ff       	jmp    80f0f5 <vprintfmt+0x23>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f43a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f43e:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f445:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f448:	eb 01                	jmp    80f44b <vprintfmt+0x379>
  80f44a:	4e                   	dec    %esi
  80f44b:	80 7e ff 25          	cmpb   $0x25,-0x1(%esi)
  80f44f:	75 f9                	jne    80f44a <vprintfmt+0x378>
  80f451:	e9 9f fc ff ff       	jmp    80f0f5 <vprintfmt+0x23>
				/* do nothing */;
			break;
		}
	}
}
  80f456:	83 c4 4c             	add    $0x4c,%esp
  80f459:	5b                   	pop    %ebx
  80f45a:	5e                   	pop    %esi
  80f45b:	5f                   	pop    %edi
  80f45c:	5d                   	pop    %ebp
  80f45d:	c3                   	ret    

0080f45e <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f45e:	55                   	push   %ebp
  80f45f:	89 e5                	mov    %esp,%ebp
  80f461:	83 ec 28             	sub    $0x28,%esp
  80f464:	8b 45 08             	mov    0x8(%ebp),%eax
  80f467:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f46a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f46d:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80f471:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80f474:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80f47b:	85 c0                	test   %eax,%eax
  80f47d:	74 30                	je     80f4af <vsnprintf+0x51>
  80f47f:	85 d2                	test   %edx,%edx
  80f481:	7e 33                	jle    80f4b6 <vsnprintf+0x58>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f483:	8b 45 14             	mov    0x14(%ebp),%eax
  80f486:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f48a:	8b 45 10             	mov    0x10(%ebp),%eax
  80f48d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f491:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f494:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f498:	c7 04 24 90 f0 80 00 	movl   $0x80f090,(%esp)
  80f49f:	e8 2e fc ff ff       	call   80f0d2 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f4a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f4a7:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f4aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f4ad:	eb 0c                	jmp    80f4bb <vsnprintf+0x5d>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80f4af:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f4b4:	eb 05                	jmp    80f4bb <vsnprintf+0x5d>
  80f4b6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80f4bb:	c9                   	leave  
  80f4bc:	c3                   	ret    

0080f4bd <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f4bd:	55                   	push   %ebp
  80f4be:	89 e5                	mov    %esp,%ebp
  80f4c0:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f4c3:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f4c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f4ca:	8b 45 10             	mov    0x10(%ebp),%eax
  80f4cd:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f4d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f4d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f4d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4db:	89 04 24             	mov    %eax,(%esp)
  80f4de:	e8 7b ff ff ff       	call   80f45e <vsnprintf>
	va_end(ap);

	return rc;
}
  80f4e3:	c9                   	leave  
  80f4e4:	c3                   	ret    
  80f4e5:	00 00                	add    %al,(%eax)
	...

0080f4e8 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f4e8:	55                   	push   %ebp
  80f4e9:	89 e5                	mov    %esp,%ebp
  80f4eb:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f4ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4f3:	eb 01                	jmp    80f4f6 <strlen+0xe>
		n++;
  80f4f5:	40                   	inc    %eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f4f6:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f4fa:	75 f9                	jne    80f4f5 <strlen+0xd>
		n++;
	return n;
}
  80f4fc:	5d                   	pop    %ebp
  80f4fd:	c3                   	ret    

0080f4fe <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f4fe:	55                   	push   %ebp
  80f4ff:	89 e5                	mov    %esp,%ebp
  80f501:	8b 4d 08             	mov    0x8(%ebp),%ecx
		n++;
	return n;
}

int
strnlen(const char *s, size_t size)
  80f504:	8b 55 0c             	mov    0xc(%ebp),%edx
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f507:	b8 00 00 00 00       	mov    $0x0,%eax
  80f50c:	eb 01                	jmp    80f50f <strnlen+0x11>
		n++;
  80f50e:	40                   	inc    %eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f50f:	39 d0                	cmp    %edx,%eax
  80f511:	74 06                	je     80f519 <strnlen+0x1b>
  80f513:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f517:	75 f5                	jne    80f50e <strnlen+0x10>
		n++;
	return n;
}
  80f519:	5d                   	pop    %ebp
  80f51a:	c3                   	ret    

0080f51b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f51b:	55                   	push   %ebp
  80f51c:	89 e5                	mov    %esp,%ebp
  80f51e:	53                   	push   %ebx
  80f51f:	8b 45 08             	mov    0x8(%ebp),%eax
  80f522:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f525:	ba 00 00 00 00       	mov    $0x0,%edx
  80f52a:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  80f52d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80f530:	42                   	inc    %edx
  80f531:	84 c9                	test   %cl,%cl
  80f533:	75 f5                	jne    80f52a <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80f535:	5b                   	pop    %ebx
  80f536:	5d                   	pop    %ebp
  80f537:	c3                   	ret    

0080f538 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f538:	55                   	push   %ebp
  80f539:	89 e5                	mov    %esp,%ebp
  80f53b:	53                   	push   %ebx
  80f53c:	83 ec 08             	sub    $0x8,%esp
  80f53f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f542:	89 1c 24             	mov    %ebx,(%esp)
  80f545:	e8 9e ff ff ff       	call   80f4e8 <strlen>
	strcpy(dst + len, src);
  80f54a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f54d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f551:	01 d8                	add    %ebx,%eax
  80f553:	89 04 24             	mov    %eax,(%esp)
  80f556:	e8 c0 ff ff ff       	call   80f51b <strcpy>
	return dst;
}
  80f55b:	89 d8                	mov    %ebx,%eax
  80f55d:	83 c4 08             	add    $0x8,%esp
  80f560:	5b                   	pop    %ebx
  80f561:	5d                   	pop    %ebp
  80f562:	c3                   	ret    

0080f563 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f563:	55                   	push   %ebp
  80f564:	89 e5                	mov    %esp,%ebp
  80f566:	56                   	push   %esi
  80f567:	53                   	push   %ebx
  80f568:	8b 45 08             	mov    0x8(%ebp),%eax
  80f56b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f56e:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f571:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f576:	eb 0c                	jmp    80f584 <strncpy+0x21>
		*dst++ = *src;
  80f578:	8a 1a                	mov    (%edx),%bl
  80f57a:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f57d:	80 3a 01             	cmpb   $0x1,(%edx)
  80f580:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f583:	41                   	inc    %ecx
  80f584:	39 f1                	cmp    %esi,%ecx
  80f586:	75 f0                	jne    80f578 <strncpy+0x15>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f588:	5b                   	pop    %ebx
  80f589:	5e                   	pop    %esi
  80f58a:	5d                   	pop    %ebp
  80f58b:	c3                   	ret    

0080f58c <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f58c:	55                   	push   %ebp
  80f58d:	89 e5                	mov    %esp,%ebp
  80f58f:	56                   	push   %esi
  80f590:	53                   	push   %ebx
  80f591:	8b 75 08             	mov    0x8(%ebp),%esi
  80f594:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f597:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f59a:	85 d2                	test   %edx,%edx
  80f59c:	75 0a                	jne    80f5a8 <strlcpy+0x1c>
  80f59e:	89 f0                	mov    %esi,%eax
  80f5a0:	eb 1a                	jmp    80f5bc <strlcpy+0x30>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f5a2:	88 18                	mov    %bl,(%eax)
  80f5a4:	40                   	inc    %eax
  80f5a5:	41                   	inc    %ecx
  80f5a6:	eb 02                	jmp    80f5aa <strlcpy+0x1e>
strlcpy(char *dst, const char *src, size_t size)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f5a8:	89 f0                	mov    %esi,%eax
		while (--size > 0 && *src != '\0')
  80f5aa:	4a                   	dec    %edx
  80f5ab:	74 0a                	je     80f5b7 <strlcpy+0x2b>
  80f5ad:	8a 19                	mov    (%ecx),%bl
  80f5af:	84 db                	test   %bl,%bl
  80f5b1:	75 ef                	jne    80f5a2 <strlcpy+0x16>
  80f5b3:	89 c2                	mov    %eax,%edx
  80f5b5:	eb 02                	jmp    80f5b9 <strlcpy+0x2d>
  80f5b7:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80f5b9:	c6 02 00             	movb   $0x0,(%edx)
	}
	return dst - dst_in;
  80f5bc:	29 f0                	sub    %esi,%eax
}
  80f5be:	5b                   	pop    %ebx
  80f5bf:	5e                   	pop    %esi
  80f5c0:	5d                   	pop    %ebp
  80f5c1:	c3                   	ret    

0080f5c2 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f5c2:	55                   	push   %ebp
  80f5c3:	89 e5                	mov    %esp,%ebp
  80f5c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f5c8:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f5cb:	eb 02                	jmp    80f5cf <strcmp+0xd>
		p++, q++;
  80f5cd:	41                   	inc    %ecx
  80f5ce:	42                   	inc    %edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f5cf:	8a 01                	mov    (%ecx),%al
  80f5d1:	84 c0                	test   %al,%al
  80f5d3:	74 04                	je     80f5d9 <strcmp+0x17>
  80f5d5:	3a 02                	cmp    (%edx),%al
  80f5d7:	74 f4                	je     80f5cd <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f5d9:	0f b6 c0             	movzbl %al,%eax
  80f5dc:	0f b6 12             	movzbl (%edx),%edx
  80f5df:	29 d0                	sub    %edx,%eax
}
  80f5e1:	5d                   	pop    %ebp
  80f5e2:	c3                   	ret    

0080f5e3 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f5e3:	55                   	push   %ebp
  80f5e4:	89 e5                	mov    %esp,%ebp
  80f5e6:	53                   	push   %ebx
  80f5e7:	8b 45 08             	mov    0x8(%ebp),%eax
  80f5ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5ed:	8b 55 10             	mov    0x10(%ebp),%edx
	while (n > 0 && *p && *p == *q)
  80f5f0:	eb 03                	jmp    80f5f5 <strncmp+0x12>
		n--, p++, q++;
  80f5f2:	4a                   	dec    %edx
  80f5f3:	40                   	inc    %eax
  80f5f4:	41                   	inc    %ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f5f5:	85 d2                	test   %edx,%edx
  80f5f7:	74 14                	je     80f60d <strncmp+0x2a>
  80f5f9:	8a 18                	mov    (%eax),%bl
  80f5fb:	84 db                	test   %bl,%bl
  80f5fd:	74 04                	je     80f603 <strncmp+0x20>
  80f5ff:	3a 19                	cmp    (%ecx),%bl
  80f601:	74 ef                	je     80f5f2 <strncmp+0xf>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f603:	0f b6 00             	movzbl (%eax),%eax
  80f606:	0f b6 11             	movzbl (%ecx),%edx
  80f609:	29 d0                	sub    %edx,%eax
  80f60b:	eb 05                	jmp    80f612 <strncmp+0x2f>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80f60d:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f612:	5b                   	pop    %ebx
  80f613:	5d                   	pop    %ebp
  80f614:	c3                   	ret    

0080f615 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f615:	55                   	push   %ebp
  80f616:	89 e5                	mov    %esp,%ebp
  80f618:	8b 45 08             	mov    0x8(%ebp),%eax
  80f61b:	8a 4d 0c             	mov    0xc(%ebp),%cl
	for (; *s; s++)
  80f61e:	eb 05                	jmp    80f625 <strchr+0x10>
		if (*s == c)
  80f620:	38 ca                	cmp    %cl,%dl
  80f622:	74 0c                	je     80f630 <strchr+0x1b>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80f624:	40                   	inc    %eax
  80f625:	8a 10                	mov    (%eax),%dl
  80f627:	84 d2                	test   %dl,%dl
  80f629:	75 f5                	jne    80f620 <strchr+0xb>
		if (*s == c)
			return (char *) s;
	return 0;
  80f62b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f630:	5d                   	pop    %ebp
  80f631:	c3                   	ret    

0080f632 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f632:	55                   	push   %ebp
  80f633:	89 e5                	mov    %esp,%ebp
  80f635:	8b 45 08             	mov    0x8(%ebp),%eax
  80f638:	8a 4d 0c             	mov    0xc(%ebp),%cl
	for (; *s; s++)
  80f63b:	eb 05                	jmp    80f642 <strfind+0x10>
		if (*s == c)
  80f63d:	38 ca                	cmp    %cl,%dl
  80f63f:	74 07                	je     80f648 <strfind+0x16>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80f641:	40                   	inc    %eax
  80f642:	8a 10                	mov    (%eax),%dl
  80f644:	84 d2                	test   %dl,%dl
  80f646:	75 f5                	jne    80f63d <strfind+0xb>
		if (*s == c)
			break;
	return (char *) s;
}
  80f648:	5d                   	pop    %ebp
  80f649:	c3                   	ret    

0080f64a <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f64a:	55                   	push   %ebp
  80f64b:	89 e5                	mov    %esp,%ebp
  80f64d:	57                   	push   %edi
  80f64e:	56                   	push   %esi
  80f64f:	53                   	push   %ebx
  80f650:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f653:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f656:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f659:	85 c9                	test   %ecx,%ecx
  80f65b:	74 30                	je     80f68d <memset+0x43>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f65d:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f663:	75 25                	jne    80f68a <memset+0x40>
  80f665:	f6 c1 03             	test   $0x3,%cl
  80f668:	75 20                	jne    80f68a <memset+0x40>
		c &= 0xFF;
  80f66a:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f66d:	89 d3                	mov    %edx,%ebx
  80f66f:	c1 e3 08             	shl    $0x8,%ebx
  80f672:	89 d6                	mov    %edx,%esi
  80f674:	c1 e6 18             	shl    $0x18,%esi
  80f677:	89 d0                	mov    %edx,%eax
  80f679:	c1 e0 10             	shl    $0x10,%eax
  80f67c:	09 f0                	or     %esi,%eax
  80f67e:	09 d0                	or     %edx,%eax
  80f680:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f682:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80f685:	fc                   	cld    
  80f686:	f3 ab                	rep stos %eax,%es:(%edi)
  80f688:	eb 03                	jmp    80f68d <memset+0x43>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f68a:	fc                   	cld    
  80f68b:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f68d:	89 f8                	mov    %edi,%eax
  80f68f:	5b                   	pop    %ebx
  80f690:	5e                   	pop    %esi
  80f691:	5f                   	pop    %edi
  80f692:	5d                   	pop    %ebp
  80f693:	c3                   	ret    

0080f694 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f694:	55                   	push   %ebp
  80f695:	89 e5                	mov    %esp,%ebp
  80f697:	57                   	push   %edi
  80f698:	56                   	push   %esi
  80f699:	8b 45 08             	mov    0x8(%ebp),%eax
  80f69c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f69f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f6a2:	39 c6                	cmp    %eax,%esi
  80f6a4:	73 34                	jae    80f6da <memmove+0x46>
  80f6a6:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f6a9:	39 d0                	cmp    %edx,%eax
  80f6ab:	73 2d                	jae    80f6da <memmove+0x46>
		s += n;
		d += n;
  80f6ad:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f6b0:	f6 c2 03             	test   $0x3,%dl
  80f6b3:	75 1b                	jne    80f6d0 <memmove+0x3c>
  80f6b5:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f6bb:	75 13                	jne    80f6d0 <memmove+0x3c>
  80f6bd:	f6 c1 03             	test   $0x3,%cl
  80f6c0:	75 0e                	jne    80f6d0 <memmove+0x3c>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f6c2:	83 ef 04             	sub    $0x4,%edi
  80f6c5:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f6c8:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80f6cb:	fd                   	std    
  80f6cc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f6ce:	eb 07                	jmp    80f6d7 <memmove+0x43>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f6d0:	4f                   	dec    %edi
  80f6d1:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80f6d4:	fd                   	std    
  80f6d5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f6d7:	fc                   	cld    
  80f6d8:	eb 20                	jmp    80f6fa <memmove+0x66>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f6da:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f6e0:	75 13                	jne    80f6f5 <memmove+0x61>
  80f6e2:	a8 03                	test   $0x3,%al
  80f6e4:	75 0f                	jne    80f6f5 <memmove+0x61>
  80f6e6:	f6 c1 03             	test   $0x3,%cl
  80f6e9:	75 0a                	jne    80f6f5 <memmove+0x61>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f6eb:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80f6ee:	89 c7                	mov    %eax,%edi
  80f6f0:	fc                   	cld    
  80f6f1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f6f3:	eb 05                	jmp    80f6fa <memmove+0x66>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80f6f5:	89 c7                	mov    %eax,%edi
  80f6f7:	fc                   	cld    
  80f6f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f6fa:	5e                   	pop    %esi
  80f6fb:	5f                   	pop    %edi
  80f6fc:	5d                   	pop    %ebp
  80f6fd:	c3                   	ret    

0080f6fe <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f6fe:	55                   	push   %ebp
  80f6ff:	89 e5                	mov    %esp,%ebp
  80f701:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f704:	8b 45 10             	mov    0x10(%ebp),%eax
  80f707:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f70b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f70e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f712:	8b 45 08             	mov    0x8(%ebp),%eax
  80f715:	89 04 24             	mov    %eax,(%esp)
  80f718:	e8 77 ff ff ff       	call   80f694 <memmove>
}
  80f71d:	c9                   	leave  
  80f71e:	c3                   	ret    

0080f71f <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f71f:	55                   	push   %ebp
  80f720:	89 e5                	mov    %esp,%ebp
  80f722:	57                   	push   %edi
  80f723:	56                   	push   %esi
  80f724:	53                   	push   %ebx
  80f725:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f728:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f72b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f72e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f733:	eb 16                	jmp    80f74b <memcmp+0x2c>
		if (*s1 != *s2)
  80f735:	8a 04 17             	mov    (%edi,%edx,1),%al
  80f738:	42                   	inc    %edx
  80f739:	8a 4c 16 ff          	mov    -0x1(%esi,%edx,1),%cl
  80f73d:	38 c8                	cmp    %cl,%al
  80f73f:	74 0a                	je     80f74b <memcmp+0x2c>
			return (int) *s1 - (int) *s2;
  80f741:	0f b6 c0             	movzbl %al,%eax
  80f744:	0f b6 c9             	movzbl %cl,%ecx
  80f747:	29 c8                	sub    %ecx,%eax
  80f749:	eb 09                	jmp    80f754 <memcmp+0x35>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f74b:	39 da                	cmp    %ebx,%edx
  80f74d:	75 e6                	jne    80f735 <memcmp+0x16>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80f74f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f754:	5b                   	pop    %ebx
  80f755:	5e                   	pop    %esi
  80f756:	5f                   	pop    %edi
  80f757:	5d                   	pop    %ebp
  80f758:	c3                   	ret    

0080f759 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f759:	55                   	push   %ebp
  80f75a:	89 e5                	mov    %esp,%ebp
  80f75c:	8b 45 08             	mov    0x8(%ebp),%eax
  80f75f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f762:	89 c2                	mov    %eax,%edx
  80f764:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f767:	eb 05                	jmp    80f76e <memfind+0x15>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f769:	38 08                	cmp    %cl,(%eax)
  80f76b:	74 05                	je     80f772 <memfind+0x19>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80f76d:	40                   	inc    %eax
  80f76e:	39 d0                	cmp    %edx,%eax
  80f770:	72 f7                	jb     80f769 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80f772:	5d                   	pop    %ebp
  80f773:	c3                   	ret    

0080f774 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f774:	55                   	push   %ebp
  80f775:	89 e5                	mov    %esp,%ebp
  80f777:	57                   	push   %edi
  80f778:	56                   	push   %esi
  80f779:	53                   	push   %ebx
  80f77a:	8b 55 08             	mov    0x8(%ebp),%edx
  80f77d:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f780:	eb 01                	jmp    80f783 <strtol+0xf>
		s++;
  80f782:	42                   	inc    %edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f783:	8a 02                	mov    (%edx),%al
  80f785:	3c 20                	cmp    $0x20,%al
  80f787:	74 f9                	je     80f782 <strtol+0xe>
  80f789:	3c 09                	cmp    $0x9,%al
  80f78b:	74 f5                	je     80f782 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80f78d:	3c 2b                	cmp    $0x2b,%al
  80f78f:	75 08                	jne    80f799 <strtol+0x25>
		s++;
  80f791:	42                   	inc    %edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80f792:	bf 00 00 00 00       	mov    $0x0,%edi
  80f797:	eb 13                	jmp    80f7ac <strtol+0x38>
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80f799:	3c 2d                	cmp    $0x2d,%al
  80f79b:	75 0a                	jne    80f7a7 <strtol+0x33>
		s++, neg = 1;
  80f79d:	8d 52 01             	lea    0x1(%edx),%edx
  80f7a0:	bf 01 00 00 00       	mov    $0x1,%edi
  80f7a5:	eb 05                	jmp    80f7ac <strtol+0x38>
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80f7a7:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f7ac:	85 db                	test   %ebx,%ebx
  80f7ae:	74 05                	je     80f7b5 <strtol+0x41>
  80f7b0:	83 fb 10             	cmp    $0x10,%ebx
  80f7b3:	75 28                	jne    80f7dd <strtol+0x69>
  80f7b5:	8a 02                	mov    (%edx),%al
  80f7b7:	3c 30                	cmp    $0x30,%al
  80f7b9:	75 10                	jne    80f7cb <strtol+0x57>
  80f7bb:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80f7bf:	75 0a                	jne    80f7cb <strtol+0x57>
		s += 2, base = 16;
  80f7c1:	83 c2 02             	add    $0x2,%edx
  80f7c4:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f7c9:	eb 12                	jmp    80f7dd <strtol+0x69>
	else if (base == 0 && s[0] == '0')
  80f7cb:	85 db                	test   %ebx,%ebx
  80f7cd:	75 0e                	jne    80f7dd <strtol+0x69>
  80f7cf:	3c 30                	cmp    $0x30,%al
  80f7d1:	75 05                	jne    80f7d8 <strtol+0x64>
		s++, base = 8;
  80f7d3:	42                   	inc    %edx
  80f7d4:	b3 08                	mov    $0x8,%bl
  80f7d6:	eb 05                	jmp    80f7dd <strtol+0x69>
	else if (base == 0)
		base = 10;
  80f7d8:	bb 0a 00 00 00       	mov    $0xa,%ebx
  80f7dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80f7e2:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80f7e4:	8a 0a                	mov    (%edx),%cl
  80f7e6:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80f7e9:	80 fb 09             	cmp    $0x9,%bl
  80f7ec:	77 08                	ja     80f7f6 <strtol+0x82>
			dig = *s - '0';
  80f7ee:	0f be c9             	movsbl %cl,%ecx
  80f7f1:	83 e9 30             	sub    $0x30,%ecx
  80f7f4:	eb 1e                	jmp    80f814 <strtol+0xa0>
		else if (*s >= 'a' && *s <= 'z')
  80f7f6:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80f7f9:	80 fb 19             	cmp    $0x19,%bl
  80f7fc:	77 08                	ja     80f806 <strtol+0x92>
			dig = *s - 'a' + 10;
  80f7fe:	0f be c9             	movsbl %cl,%ecx
  80f801:	83 e9 57             	sub    $0x57,%ecx
  80f804:	eb 0e                	jmp    80f814 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
  80f806:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80f809:	80 fb 19             	cmp    $0x19,%bl
  80f80c:	77 12                	ja     80f820 <strtol+0xac>
			dig = *s - 'A' + 10;
  80f80e:	0f be c9             	movsbl %cl,%ecx
  80f811:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80f814:	39 f1                	cmp    %esi,%ecx
  80f816:	7d 0c                	jge    80f824 <strtol+0xb0>
			break;
		s++, val = (val * base) + dig;
  80f818:	42                   	inc    %edx
  80f819:	0f af c6             	imul   %esi,%eax
  80f81c:	01 c8                	add    %ecx,%eax
		// we don't properly detect overflow!
	}
  80f81e:	eb c4                	jmp    80f7e4 <strtol+0x70>

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
  80f820:	89 c1                	mov    %eax,%ecx
  80f822:	eb 02                	jmp    80f826 <strtol+0xb2>
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f824:	89 c1                	mov    %eax,%ecx
			break;
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  80f826:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f82a:	74 05                	je     80f831 <strtol+0xbd>
		*endptr = (char *) s;
  80f82c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f82f:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  80f831:	85 ff                	test   %edi,%edi
  80f833:	74 04                	je     80f839 <strtol+0xc5>
  80f835:	89 c8                	mov    %ecx,%eax
  80f837:	f7 d8                	neg    %eax
}
  80f839:	5b                   	pop    %ebx
  80f83a:	5e                   	pop    %esi
  80f83b:	5f                   	pop    %edi
  80f83c:	5d                   	pop    %ebp
  80f83d:	c3                   	ret    
	...

0080f840 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f840:	55                   	push   %ebp
  80f841:	89 e5                	mov    %esp,%ebp
  80f843:	57                   	push   %edi
  80f844:	56                   	push   %esi
  80f845:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f846:	b8 00 00 00 00       	mov    $0x0,%eax
  80f84b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f84e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f851:	89 c3                	mov    %eax,%ebx
  80f853:	89 c7                	mov    %eax,%edi
  80f855:	89 c6                	mov    %eax,%esi
  80f857:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f859:	5b                   	pop    %ebx
  80f85a:	5e                   	pop    %esi
  80f85b:	5f                   	pop    %edi
  80f85c:	5d                   	pop    %ebp
  80f85d:	c3                   	ret    

0080f85e <sys_cgetc>:

int
sys_cgetc(void)
{
  80f85e:	55                   	push   %ebp
  80f85f:	89 e5                	mov    %esp,%ebp
  80f861:	57                   	push   %edi
  80f862:	56                   	push   %esi
  80f863:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f864:	ba 00 00 00 00       	mov    $0x0,%edx
  80f869:	b8 01 00 00 00       	mov    $0x1,%eax
  80f86e:	89 d1                	mov    %edx,%ecx
  80f870:	89 d3                	mov    %edx,%ebx
  80f872:	89 d7                	mov    %edx,%edi
  80f874:	89 d6                	mov    %edx,%esi
  80f876:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f878:	5b                   	pop    %ebx
  80f879:	5e                   	pop    %esi
  80f87a:	5f                   	pop    %edi
  80f87b:	5d                   	pop    %ebp
  80f87c:	c3                   	ret    

0080f87d <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f87d:	55                   	push   %ebp
  80f87e:	89 e5                	mov    %esp,%ebp
  80f880:	57                   	push   %edi
  80f881:	56                   	push   %esi
  80f882:	53                   	push   %ebx
  80f883:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f886:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f88b:	b8 03 00 00 00       	mov    $0x3,%eax
  80f890:	8b 55 08             	mov    0x8(%ebp),%edx
  80f893:	89 cb                	mov    %ecx,%ebx
  80f895:	89 cf                	mov    %ecx,%edi
  80f897:	89 ce                	mov    %ecx,%esi
  80f899:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f89b:	85 c0                	test   %eax,%eax
  80f89d:	7e 28                	jle    80f8c7 <sys_env_destroy+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f89f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f8a3:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80f8aa:	00 
  80f8ab:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80f8b2:	00 
  80f8b3:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f8ba:	00 
  80f8bb:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80f8c2:	e8 b1 f5 ff ff       	call   80ee78 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f8c7:	83 c4 2c             	add    $0x2c,%esp
  80f8ca:	5b                   	pop    %ebx
  80f8cb:	5e                   	pop    %esi
  80f8cc:	5f                   	pop    %edi
  80f8cd:	5d                   	pop    %ebp
  80f8ce:	c3                   	ret    

0080f8cf <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f8cf:	55                   	push   %ebp
  80f8d0:	89 e5                	mov    %esp,%ebp
  80f8d2:	57                   	push   %edi
  80f8d3:	56                   	push   %esi
  80f8d4:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f8d5:	ba 00 00 00 00       	mov    $0x0,%edx
  80f8da:	b8 02 00 00 00       	mov    $0x2,%eax
  80f8df:	89 d1                	mov    %edx,%ecx
  80f8e1:	89 d3                	mov    %edx,%ebx
  80f8e3:	89 d7                	mov    %edx,%edi
  80f8e5:	89 d6                	mov    %edx,%esi
  80f8e7:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f8e9:	5b                   	pop    %ebx
  80f8ea:	5e                   	pop    %esi
  80f8eb:	5f                   	pop    %edi
  80f8ec:	5d                   	pop    %ebp
  80f8ed:	c3                   	ret    

0080f8ee <sys_yield>:

void
sys_yield(void)
{
  80f8ee:	55                   	push   %ebp
  80f8ef:	89 e5                	mov    %esp,%ebp
  80f8f1:	57                   	push   %edi
  80f8f2:	56                   	push   %esi
  80f8f3:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f8f4:	ba 00 00 00 00       	mov    $0x0,%edx
  80f8f9:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f8fe:	89 d1                	mov    %edx,%ecx
  80f900:	89 d3                	mov    %edx,%ebx
  80f902:	89 d7                	mov    %edx,%edi
  80f904:	89 d6                	mov    %edx,%esi
  80f906:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f908:	5b                   	pop    %ebx
  80f909:	5e                   	pop    %esi
  80f90a:	5f                   	pop    %edi
  80f90b:	5d                   	pop    %ebp
  80f90c:	c3                   	ret    

0080f90d <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f90d:	55                   	push   %ebp
  80f90e:	89 e5                	mov    %esp,%ebp
  80f910:	57                   	push   %edi
  80f911:	56                   	push   %esi
  80f912:	53                   	push   %ebx
  80f913:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f916:	be 00 00 00 00       	mov    $0x0,%esi
  80f91b:	b8 04 00 00 00       	mov    $0x4,%eax
  80f920:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f923:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f926:	8b 55 08             	mov    0x8(%ebp),%edx
  80f929:	89 f7                	mov    %esi,%edi
  80f92b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f92d:	85 c0                	test   %eax,%eax
  80f92f:	7e 28                	jle    80f959 <sys_page_alloc+0x4c>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f931:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f935:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80f93c:	00 
  80f93d:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80f944:	00 
  80f945:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f94c:	00 
  80f94d:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80f954:	e8 1f f5 ff ff       	call   80ee78 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f959:	83 c4 2c             	add    $0x2c,%esp
  80f95c:	5b                   	pop    %ebx
  80f95d:	5e                   	pop    %esi
  80f95e:	5f                   	pop    %edi
  80f95f:	5d                   	pop    %ebp
  80f960:	c3                   	ret    

0080f961 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f961:	55                   	push   %ebp
  80f962:	89 e5                	mov    %esp,%ebp
  80f964:	57                   	push   %edi
  80f965:	56                   	push   %esi
  80f966:	53                   	push   %ebx
  80f967:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f96a:	b8 05 00 00 00       	mov    $0x5,%eax
  80f96f:	8b 75 18             	mov    0x18(%ebp),%esi
  80f972:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f975:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f978:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f97b:	8b 55 08             	mov    0x8(%ebp),%edx
  80f97e:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f980:	85 c0                	test   %eax,%eax
  80f982:	7e 28                	jle    80f9ac <sys_page_map+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f984:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f988:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80f98f:	00 
  80f990:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80f997:	00 
  80f998:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f99f:	00 
  80f9a0:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80f9a7:	e8 cc f4 ff ff       	call   80ee78 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f9ac:	83 c4 2c             	add    $0x2c,%esp
  80f9af:	5b                   	pop    %ebx
  80f9b0:	5e                   	pop    %esi
  80f9b1:	5f                   	pop    %edi
  80f9b2:	5d                   	pop    %ebp
  80f9b3:	c3                   	ret    

0080f9b4 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f9b4:	55                   	push   %ebp
  80f9b5:	89 e5                	mov    %esp,%ebp
  80f9b7:	57                   	push   %edi
  80f9b8:	56                   	push   %esi
  80f9b9:	53                   	push   %ebx
  80f9ba:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80f9bd:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f9c2:	b8 06 00 00 00       	mov    $0x6,%eax
  80f9c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9ca:	8b 55 08             	mov    0x8(%ebp),%edx
  80f9cd:	89 df                	mov    %ebx,%edi
  80f9cf:	89 de                	mov    %ebx,%esi
  80f9d1:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f9d3:	85 c0                	test   %eax,%eax
  80f9d5:	7e 28                	jle    80f9ff <sys_page_unmap+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f9d7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80f9db:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80f9e2:	00 
  80f9e3:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80f9ea:	00 
  80f9eb:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80f9f2:	00 
  80f9f3:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80f9fa:	e8 79 f4 ff ff       	call   80ee78 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f9ff:	83 c4 2c             	add    $0x2c,%esp
  80fa02:	5b                   	pop    %ebx
  80fa03:	5e                   	pop    %esi
  80fa04:	5f                   	pop    %edi
  80fa05:	5d                   	pop    %ebp
  80fa06:	c3                   	ret    

0080fa07 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80fa07:	55                   	push   %ebp
  80fa08:	89 e5                	mov    %esp,%ebp
  80fa0a:	57                   	push   %edi
  80fa0b:	56                   	push   %esi
  80fa0c:	53                   	push   %ebx
  80fa0d:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fa10:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa15:	b8 08 00 00 00       	mov    $0x8,%eax
  80fa1a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fa1d:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa20:	89 df                	mov    %ebx,%edi
  80fa22:	89 de                	mov    %ebx,%esi
  80fa24:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fa26:	85 c0                	test   %eax,%eax
  80fa28:	7e 28                	jle    80fa52 <sys_env_set_status+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fa2a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fa2e:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  80fa35:	00 
  80fa36:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80fa3d:	00 
  80fa3e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fa45:	00 
  80fa46:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80fa4d:	e8 26 f4 ff ff       	call   80ee78 <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80fa52:	83 c4 2c             	add    $0x2c,%esp
  80fa55:	5b                   	pop    %ebx
  80fa56:	5e                   	pop    %esi
  80fa57:	5f                   	pop    %edi
  80fa58:	5d                   	pop    %ebp
  80fa59:	c3                   	ret    

0080fa5a <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fa5a:	55                   	push   %ebp
  80fa5b:	89 e5                	mov    %esp,%ebp
  80fa5d:	57                   	push   %edi
  80fa5e:	56                   	push   %esi
  80fa5f:	53                   	push   %ebx
  80fa60:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fa63:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa68:	b8 09 00 00 00       	mov    $0x9,%eax
  80fa6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fa70:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa73:	89 df                	mov    %ebx,%edi
  80fa75:	89 de                	mov    %ebx,%esi
  80fa77:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fa79:	85 c0                	test   %eax,%eax
  80fa7b:	7e 28                	jle    80faa5 <sys_env_set_trapframe+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fa7d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fa81:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80fa88:	00 
  80fa89:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80fa90:	00 
  80fa91:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fa98:	00 
  80fa99:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80faa0:	e8 d3 f3 ff ff       	call   80ee78 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80faa5:	83 c4 2c             	add    $0x2c,%esp
  80faa8:	5b                   	pop    %ebx
  80faa9:	5e                   	pop    %esi
  80faaa:	5f                   	pop    %edi
  80faab:	5d                   	pop    %ebp
  80faac:	c3                   	ret    

0080faad <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80faad:	55                   	push   %ebp
  80faae:	89 e5                	mov    %esp,%ebp
  80fab0:	57                   	push   %edi
  80fab1:	56                   	push   %esi
  80fab2:	53                   	push   %ebx
  80fab3:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fab6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fabb:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fac0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fac3:	8b 55 08             	mov    0x8(%ebp),%edx
  80fac6:	89 df                	mov    %ebx,%edi
  80fac8:	89 de                	mov    %ebx,%esi
  80faca:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80facc:	85 c0                	test   %eax,%eax
  80face:	7e 28                	jle    80faf8 <sys_env_set_pgfault_upcall+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fad0:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fad4:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80fadb:	00 
  80fadc:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80fae3:	00 
  80fae4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80faeb:	00 
  80faec:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80faf3:	e8 80 f3 ff ff       	call   80ee78 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80faf8:	83 c4 2c             	add    $0x2c,%esp
  80fafb:	5b                   	pop    %ebx
  80fafc:	5e                   	pop    %esi
  80fafd:	5f                   	pop    %edi
  80fafe:	5d                   	pop    %ebp
  80faff:	c3                   	ret    

0080fb00 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fb00:	55                   	push   %ebp
  80fb01:	89 e5                	mov    %esp,%ebp
  80fb03:	57                   	push   %edi
  80fb04:	56                   	push   %esi
  80fb05:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb06:	be 00 00 00 00       	mov    $0x0,%esi
  80fb0b:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fb10:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fb13:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fb16:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fb19:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb1c:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fb1e:	5b                   	pop    %ebx
  80fb1f:	5e                   	pop    %esi
  80fb20:	5f                   	pop    %edi
  80fb21:	5d                   	pop    %ebp
  80fb22:	c3                   	ret    

0080fb23 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80fb23:	55                   	push   %ebp
  80fb24:	89 e5                	mov    %esp,%ebp
  80fb26:	57                   	push   %edi
  80fb27:	56                   	push   %esi
  80fb28:	53                   	push   %ebx
  80fb29:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb2c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb31:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fb36:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb39:	89 cb                	mov    %ecx,%ebx
  80fb3b:	89 cf                	mov    %ecx,%edi
  80fb3d:	89 ce                	mov    %ecx,%esi
  80fb3f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80fb41:	85 c0                	test   %eax,%eax
  80fb43:	7e 28                	jle    80fb6d <sys_ipc_recv+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fb45:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fb49:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80fb50:	00 
  80fb51:	c7 44 24 08 e7 32 81 	movl   $0x8132e7,0x8(%esp)
  80fb58:	00 
  80fb59:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fb60:	00 
  80fb61:	c7 04 24 04 33 81 00 	movl   $0x813304,(%esp)
  80fb68:	e8 0b f3 ff ff       	call   80ee78 <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fb6d:	83 c4 2c             	add    $0x2c,%esp
  80fb70:	5b                   	pop    %ebx
  80fb71:	5e                   	pop    %esi
  80fb72:	5f                   	pop    %edi
  80fb73:	5d                   	pop    %ebp
  80fb74:	c3                   	ret    

0080fb75 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80fb75:	55                   	push   %ebp
  80fb76:	89 e5                	mov    %esp,%ebp
  80fb78:	57                   	push   %edi
  80fb79:	56                   	push   %esi
  80fb7a:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb7b:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb80:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fb85:	89 d1                	mov    %edx,%ecx
  80fb87:	89 d3                	mov    %edx,%ebx
  80fb89:	89 d7                	mov    %edx,%edi
  80fb8b:	89 d6                	mov    %edx,%esi
  80fb8d:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80fb8f:	5b                   	pop    %ebx
  80fb90:	5e                   	pop    %esi
  80fb91:	5f                   	pop    %edi
  80fb92:	5d                   	pop    %ebp
  80fb93:	c3                   	ret    

0080fb94 <sys_e1000_transmit>:

int 
sys_e1000_transmit(char* pck, size_t length){
  80fb94:	55                   	push   %ebp
  80fb95:	89 e5                	mov    %esp,%ebp
  80fb97:	57                   	push   %edi
  80fb98:	56                   	push   %esi
  80fb99:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb9a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fb9f:	b8 10 00 00 00       	mov    $0x10,%eax
  80fba4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fba7:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbaa:	89 df                	mov    %ebx,%edi
  80fbac:	89 de                	mov    %ebx,%esi
  80fbae:	cd 30                	int    $0x30
}

int 
sys_e1000_transmit(char* pck, size_t length){
	return syscall(SYS_e1000_transmit, 0, (uint32_t)pck, length, 0, 0, 0);
}
  80fbb0:	5b                   	pop    %ebx
  80fbb1:	5e                   	pop    %esi
  80fbb2:	5f                   	pop    %edi
  80fbb3:	5d                   	pop    %ebp
  80fbb4:	c3                   	ret    

0080fbb5 <sys_e1000_receive>:

int 
sys_e1000_receive(char* pck, size_t* length){
  80fbb5:	55                   	push   %ebp
  80fbb6:	89 e5                	mov    %esp,%ebp
  80fbb8:	57                   	push   %edi
  80fbb9:	56                   	push   %esi
  80fbba:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbbb:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fbc0:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fbc5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbc8:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbcb:	89 df                	mov    %ebx,%edi
  80fbcd:	89 de                	mov    %ebx,%esi
  80fbcf:	cd 30                	int    $0x30
}

int 
sys_e1000_receive(char* pck, size_t* length){
	return syscall(SYS_e1000_receive, 0, (uint32_t)pck, (uint32_t)length, 0, 0, 0);
}
  80fbd1:	5b                   	pop    %ebx
  80fbd2:	5e                   	pop    %esi
  80fbd3:	5f                   	pop    %edi
  80fbd4:	5d                   	pop    %ebp
  80fbd5:	c3                   	ret    

0080fbd6 <sys_e1000_get_mac>:

int 
sys_e1000_get_mac(uint8_t* mac_addr){
  80fbd6:	55                   	push   %ebp
  80fbd7:	89 e5                	mov    %esp,%ebp
  80fbd9:	57                   	push   %edi
  80fbda:	56                   	push   %esi
  80fbdb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbdc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fbe1:	b8 11 00 00 00       	mov    $0x11,%eax
  80fbe6:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbe9:	89 cb                	mov    %ecx,%ebx
  80fbeb:	89 cf                	mov    %ecx,%edi
  80fbed:	89 ce                	mov    %ecx,%esi
  80fbef:	cd 30                	int    $0x30
}

int 
sys_e1000_get_mac(uint8_t* mac_addr){
	return syscall(SYS_e1000_get_mac, 0, (uint32_t)mac_addr, 0, 0, 0, 0);
}
  80fbf1:	5b                   	pop    %ebx
  80fbf2:	5e                   	pop    %esi
  80fbf3:	5f                   	pop    %edi
  80fbf4:	5d                   	pop    %ebp
  80fbf5:	c3                   	ret    
	...

0080fbf8 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80fbf8:	55                   	push   %ebp
  80fbf9:	89 e5                	mov    %esp,%ebp
  80fbfb:	53                   	push   %ebx
  80fbfc:	83 ec 24             	sub    $0x24,%esp
  80fbff:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80fc02:	8b 18                	mov    (%eax),%ebx
	// Check that the faulting access was (1) a write, and (2) to a
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).
	if ((err & FEC_WR) == 0)
  80fc04:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80fc08:	75 20                	jne    80fc2a <pgfault+0x32>
		panic("pgfault: faulting address [%08x] not a write\n", addr);
  80fc0a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80fc0e:	c7 44 24 08 14 33 81 	movl   $0x813314,0x8(%esp)
  80fc15:	00 
  80fc16:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  80fc1d:	00 
  80fc1e:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fc25:	e8 4e f2 ff ff       	call   80ee78 <_panic>

	void *page_aligned_addr = (void *) ROUNDDOWN(addr, PGSIZE);
  80fc2a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	uint32_t page_num = (uint32_t) page_aligned_addr / PGSIZE;
  80fc30:	89 d8                	mov    %ebx,%eax
  80fc32:	c1 e8 0c             	shr    $0xc,%eax
	if (!(uvpt[page_num] & PTE_COW))
  80fc35:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fc3c:	f6 c4 08             	test   $0x8,%ah
  80fc3f:	75 1c                	jne    80fc5d <pgfault+0x65>
		panic("pgfault: fault was not on a copy-on-write page\n");
  80fc41:	c7 44 24 08 44 33 81 	movl   $0x813344,0x8(%esp)
  80fc48:	00 
  80fc49:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc50:	00 
  80fc51:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fc58:	e8 1b f2 ff ff       	call   80ee78 <_panic>
	//   You should make three system calls.

	// LAB 4: Your code here.

	// Allocate
	if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
  80fc5d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80fc64:	00 
  80fc65:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fc6c:	00 
  80fc6d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fc74:	e8 94 fc ff ff       	call   80f90d <sys_page_alloc>
  80fc79:	85 c0                	test   %eax,%eax
  80fc7b:	79 20                	jns    80fc9d <pgfault+0xa5>
		panic("sys_page_alloc: %e\n", r);
  80fc7d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fc81:	c7 44 24 08 9f 33 81 	movl   $0x81339f,0x8(%esp)
  80fc88:	00 
  80fc89:	c7 44 24 04 31 00 00 	movl   $0x31,0x4(%esp)
  80fc90:	00 
  80fc91:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fc98:	e8 db f1 ff ff       	call   80ee78 <_panic>

	// Copy over
	void *src_addr = (void *) ROUNDDOWN(addr, PGSIZE);
	memmove(PFTEMP, src_addr, PGSIZE);
  80fc9d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80fca4:	00 
  80fca5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fca9:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  80fcb0:	e8 df f9 ff ff       	call   80f694 <memmove>

	// Remap
	if ((r = sys_page_map(0, PFTEMP, 0, src_addr, PTE_P | PTE_U | PTE_W)) < 0)
  80fcb5:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  80fcbc:	00 
  80fcbd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80fcc1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fcc8:	00 
  80fcc9:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80fcd0:	00 
  80fcd1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fcd8:	e8 84 fc ff ff       	call   80f961 <sys_page_map>
  80fcdd:	85 c0                	test   %eax,%eax
  80fcdf:	79 20                	jns    80fd01 <pgfault+0x109>
		panic("sys_page_map: %e\n", r);
  80fce1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fce5:	c7 44 24 08 b3 33 81 	movl   $0x8133b3,0x8(%esp)
  80fcec:	00 
  80fced:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp)
  80fcf4:	00 
  80fcf5:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fcfc:	e8 77 f1 ff ff       	call   80ee78 <_panic>

}
  80fd01:	83 c4 24             	add    $0x24,%esp
  80fd04:	5b                   	pop    %ebx
  80fd05:	5d                   	pop    %ebp
  80fd06:	c3                   	ret    

0080fd07 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80fd07:	55                   	push   %ebp
  80fd08:	89 e5                	mov    %esp,%ebp
  80fd0a:	57                   	push   %edi
  80fd0b:	56                   	push   %esi
  80fd0c:	53                   	push   %ebx
  80fd0d:	83 ec 3c             	sub    $0x3c,%esp
	// LAB 4: Your code here.
	int r;
	envid_t child_envid;

	set_pgfault_handler(pgfault);
  80fd10:	c7 04 24 f8 fb 80 00 	movl   $0x80fbf8,(%esp)
  80fd17:	e8 20 09 00 00       	call   81063c <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  80fd1c:	ba 07 00 00 00       	mov    $0x7,%edx
  80fd21:	89 d0                	mov    %edx,%eax
  80fd23:	cd 30                	int    $0x30
  80fd25:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80fd28:	89 45 e0             	mov    %eax,-0x20(%ebp)

	child_envid = sys_exofork();
	if (child_envid < 0)
  80fd2b:	85 c0                	test   %eax,%eax
  80fd2d:	79 20                	jns    80fd4f <fork+0x48>
		panic("sys_exofork: %e\n", child_envid);
  80fd2f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fd33:	c7 44 24 08 c5 33 81 	movl   $0x8133c5,0x8(%esp)
  80fd3a:	00 
  80fd3b:	c7 44 24 04 82 00 00 	movl   $0x82,0x4(%esp)
  80fd42:	00 
  80fd43:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fd4a:	e8 29 f1 ff ff       	call   80ee78 <_panic>
	if (child_envid == 0) { // child
  80fd4f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80fd53:	75 1c                	jne    80fd71 <fork+0x6a>
		// Fix thisenv like dumbfork does and return 0
		thisenv = &envs[ENVX(sys_getenvid())];
  80fd55:	e8 75 fb ff ff       	call   80f8cf <sys_getenvid>
  80fd5a:	25 ff 03 00 00       	and    $0x3ff,%eax
  80fd5f:	c1 e0 07             	shl    $0x7,%eax
  80fd62:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fd67:	a3 9c b2 b3 00       	mov    %eax,0xb3b29c
		return 0;
  80fd6c:	e9 58 02 00 00       	jmp    80ffc9 <fork+0x2c2>
	set_pgfault_handler(pgfault);

	child_envid = sys_exofork();
	if (child_envid < 0)
		panic("sys_exofork: %e\n", child_envid);
	if (child_envid == 0) { // child
  80fd71:	bf 00 00 00 00       	mov    $0x0,%edi
  80fd76:	be 00 00 00 00       	mov    $0x0,%esi
	// Note that we don't remap anything above UTOP because the kernel took
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
		uint32_t pdx = ROUNDDOWN(page_num, NPDENTRIES) / NPDENTRIES;
  80fd7b:	89 f0                	mov    %esi,%eax
  80fd7d:	c1 e8 0a             	shr    $0xa,%eax
		if ((uvpd[pdx] & PTE_P) == PTE_P &&
  80fd80:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fd87:	a8 01                	test   $0x1,%al
  80fd89:	0f 84 7a 01 00 00    	je     80ff09 <fork+0x202>
			((uvpt[page_num] & PTE_P) == PTE_P)) {
  80fd8f:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
		uint32_t pdx = ROUNDDOWN(page_num, NPDENTRIES) / NPDENTRIES;
		if ((uvpd[pdx] & PTE_P) == PTE_P &&
  80fd96:	a8 01                	test   $0x1,%al
  80fd98:	0f 84 6b 01 00 00    	je     80ff09 <fork+0x202>
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t perm = PTE_P | PTE_COW;
	envid_t this_envid = thisenv->env_id;
  80fd9e:	a1 9c b2 b3 00       	mov    0xb3b29c,%eax
  80fda3:	8b 40 48             	mov    0x48(%eax),%eax
  80fda6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// LAB 4: Your code here.
	if (uvpt[pn] & PTE_SHARE) {
  80fda9:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fdb0:	f6 c4 04             	test   $0x4,%ah
  80fdb3:	74 52                	je     80fe07 <fork+0x100>
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), uvpt[pn] & PTE_SYSCALL)) < 0)
  80fdb5:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fdbc:	25 07 0e 00 00       	and    $0xe07,%eax
  80fdc1:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fdc5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80fdc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fdcc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fdd0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fdd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80fdd7:	89 04 24             	mov    %eax,(%esp)
  80fdda:	e8 82 fb ff ff       	call   80f961 <sys_page_map>
  80fddf:	85 c0                	test   %eax,%eax
  80fde1:	0f 89 22 01 00 00    	jns    80ff09 <fork+0x202>
			panic("sys_page_map: %e\n", r);
  80fde7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fdeb:	c7 44 24 08 b3 33 81 	movl   $0x8133b3,0x8(%esp)
  80fdf2:	00 
  80fdf3:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80fdfa:	00 
  80fdfb:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fe02:	e8 71 f0 ff ff       	call   80ee78 <_panic>
	} else if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W) {
  80fe07:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fe0e:	f6 c4 08             	test   $0x8,%ah
  80fe11:	75 0f                	jne    80fe22 <fork+0x11b>
  80fe13:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fe1a:	a8 02                	test   $0x2,%al
  80fe1c:	0f 84 99 00 00 00    	je     80febb <fork+0x1b4>
		if (uvpt[pn] & PTE_U)
  80fe22:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fe29:	83 e0 04             	and    $0x4,%eax
//
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t perm = PTE_P | PTE_COW;
  80fe2c:	83 f8 01             	cmp    $0x1,%eax
  80fe2f:	19 db                	sbb    %ebx,%ebx
  80fe31:	83 e3 fc             	and    $0xfffffffc,%ebx
  80fe34:	81 c3 05 08 00 00    	add    $0x805,%ebx
	} else if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W) {
		if (uvpt[pn] & PTE_U)
			perm |= PTE_U;

		// Map page COW, U and P in child
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), perm)) < 0)
  80fe3a:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80fe3e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80fe42:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fe45:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fe49:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fe4d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80fe50:	89 04 24             	mov    %eax,(%esp)
  80fe53:	e8 09 fb ff ff       	call   80f961 <sys_page_map>
  80fe58:	85 c0                	test   %eax,%eax
  80fe5a:	79 20                	jns    80fe7c <fork+0x175>
			panic("sys_page_map: %e\n", r);
  80fe5c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fe60:	c7 44 24 08 b3 33 81 	movl   $0x8133b3,0x8(%esp)
  80fe67:	00 
  80fe68:	c7 44 24 04 59 00 00 	movl   $0x59,0x4(%esp)
  80fe6f:	00 
  80fe70:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fe77:	e8 fc ef ff ff       	call   80ee78 <_panic>

		// Map page COW, U and P in parent
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), this_envid, (void *) (pn*PGSIZE), perm)) < 0)
  80fe7c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80fe80:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80fe84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80fe87:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fe8b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fe8f:	89 04 24             	mov    %eax,(%esp)
  80fe92:	e8 ca fa ff ff       	call   80f961 <sys_page_map>
  80fe97:	85 c0                	test   %eax,%eax
  80fe99:	79 6e                	jns    80ff09 <fork+0x202>
			panic("sys_page_map: %e\n", r);
  80fe9b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fe9f:	c7 44 24 08 b3 33 81 	movl   $0x8133b3,0x8(%esp)
  80fea6:	00 
  80fea7:	c7 44 24 04 5d 00 00 	movl   $0x5d,0x4(%esp)
  80feae:	00 
  80feaf:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80feb6:	e8 bd ef ff ff       	call   80ee78 <_panic>

	} else { // map pages that are present but not writable or COW with their original permissions
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), uvpt[pn] & PTE_SYSCALL)) < 0)
  80febb:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80fec2:	25 07 0e 00 00       	and    $0xe07,%eax
  80fec7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fecb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80fecf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fed2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fed6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80feda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80fedd:	89 04 24             	mov    %eax,(%esp)
  80fee0:	e8 7c fa ff ff       	call   80f961 <sys_page_map>
  80fee5:	85 c0                	test   %eax,%eax
  80fee7:	79 20                	jns    80ff09 <fork+0x202>
			panic("sys_page_map: %e\n", r);
  80fee9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80feed:	c7 44 24 08 b3 33 81 	movl   $0x8133b3,0x8(%esp)
  80fef4:	00 
  80fef5:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
  80fefc:	00 
  80fefd:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ff04:	e8 6f ef ff ff       	call   80ee78 <_panic>
	// and let duppage worry about the permissions.
	// Note that we don't remap anything above UTOP because the kernel took
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
  80ff09:	46                   	inc    %esi
  80ff0a:	81 c7 00 10 00 00    	add    $0x1000,%edi
  80ff10:	81 fe ff eb 0e 00    	cmp    $0xeebff,%esi
  80ff16:	0f 85 5f fe ff ff    	jne    80fd7b <fork+0x74>
	}

	// Allocate exception stack space for child. The child can't do this themselves
	// because the mechanism by which it would is to run the pgfault handler, which
	// needs to run on the exception stack (catch 22).
	if ((r = sys_page_alloc(child_envid, (void *) (UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  80ff1c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80ff23:	00 
  80ff24:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  80ff2b:	ee 
  80ff2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ff2f:	89 04 24             	mov    %eax,(%esp)
  80ff32:	e8 d6 f9 ff ff       	call   80f90d <sys_page_alloc>
  80ff37:	85 c0                	test   %eax,%eax
  80ff39:	79 20                	jns    80ff5b <fork+0x254>
		panic("sys_page_alloc: %e\n", r);
  80ff3b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff3f:	c7 44 24 08 9f 33 81 	movl   $0x81339f,0x8(%esp)
  80ff46:	00 
  80ff47:	c7 44 24 04 9d 00 00 	movl   $0x9d,0x4(%esp)
  80ff4e:	00 
  80ff4f:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ff56:	e8 1d ef ff ff       	call   80ee78 <_panic>

	// Set page fault handler for the child
	if ((r = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall)) < 0)
  80ff5b:	c7 44 24 04 b0 06 81 	movl   $0x8106b0,0x4(%esp)
  80ff62:	00 
  80ff63:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ff66:	89 04 24             	mov    %eax,(%esp)
  80ff69:	e8 3f fb ff ff       	call   80faad <sys_env_set_pgfault_upcall>
  80ff6e:	85 c0                	test   %eax,%eax
  80ff70:	79 20                	jns    80ff92 <fork+0x28b>
		panic("sys_env_set_pgfault_upcall: %e\n", r);
  80ff72:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff76:	c7 44 24 08 74 33 81 	movl   $0x813374,0x8(%esp)
  80ff7d:	00 
  80ff7e:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80ff85:	00 
  80ff86:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ff8d:	e8 e6 ee ff ff       	call   80ee78 <_panic>

	// Mark child environment as runnable
	if ((r = sys_env_set_status(child_envid, ENV_RUNNABLE)) < 0)
  80ff92:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ff99:	00 
  80ff9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ff9d:	89 04 24             	mov    %eax,(%esp)
  80ffa0:	e8 62 fa ff ff       	call   80fa07 <sys_env_set_status>
  80ffa5:	85 c0                	test   %eax,%eax
  80ffa7:	79 20                	jns    80ffc9 <fork+0x2c2>
		panic("sys_env_set_status: %e\n", r);
  80ffa9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ffad:	c7 44 24 08 d6 33 81 	movl   $0x8133d6,0x8(%esp)
  80ffb4:	00 
  80ffb5:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
  80ffbc:	00 
  80ffbd:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ffc4:	e8 af ee ff ff       	call   80ee78 <_panic>

	return child_envid;
}
  80ffc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ffcc:	83 c4 3c             	add    $0x3c,%esp
  80ffcf:	5b                   	pop    %ebx
  80ffd0:	5e                   	pop    %esi
  80ffd1:	5f                   	pop    %edi
  80ffd2:	5d                   	pop    %ebp
  80ffd3:	c3                   	ret    

0080ffd4 <sfork>:

// Challenge!
int
sfork(void)
{
  80ffd4:	55                   	push   %ebp
  80ffd5:	89 e5                	mov    %esp,%ebp
  80ffd7:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  80ffda:	c7 44 24 08 ee 33 81 	movl   $0x8133ee,0x8(%esp)
  80ffe1:	00 
  80ffe2:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80ffe9:	00 
  80ffea:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80fff1:	e8 82 ee ff ff       	call   80ee78 <_panic>
	...

0080fff8 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80fff8:	55                   	push   %ebp
  80fff9:	89 e5                	mov    %esp,%ebp
  80fffb:	56                   	push   %esi
  80fffc:	53                   	push   %ebx
  80fffd:	83 ec 10             	sub    $0x10,%esp
  810000:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810003:	8b 45 0c             	mov    0xc(%ebp),%eax
  810006:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 4: Your code here.
	//panic("ipc_recv not implemented");
	int r;
		
	r = sys_ipc_recv(pg?pg:(void*)UTOP);
  810009:	85 c0                	test   %eax,%eax
  81000b:	75 05                	jne    810012 <ipc_recv+0x1a>
  81000d:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  810012:	89 04 24             	mov    %eax,(%esp)
  810015:	e8 09 fb ff ff       	call   80fb23 <sys_ipc_recv>
	if (from_env_store != NULL)
  81001a:	85 db                	test   %ebx,%ebx
  81001c:	74 0b                	je     810029 <ipc_recv+0x31>
		*from_env_store = thisenv->env_ipc_from; 
  81001e:	8b 15 9c b2 b3 00    	mov    0xb3b29c,%edx
  810024:	8b 52 74             	mov    0x74(%edx),%edx
  810027:	89 13                	mov    %edx,(%ebx)
	if (perm_store != NULL)
  810029:	85 f6                	test   %esi,%esi
  81002b:	74 0b                	je     810038 <ipc_recv+0x40>
		*perm_store = thisenv->env_ipc_perm;
  81002d:	8b 15 9c b2 b3 00    	mov    0xb3b29c,%edx
  810033:	8b 52 78             	mov    0x78(%edx),%edx
  810036:	89 16                	mov    %edx,(%esi)
	
	if (r < 0){
  810038:	85 c0                	test   %eax,%eax
  81003a:	79 16                	jns    810052 <ipc_recv+0x5a>
		if(from_env_store != NULL)
  81003c:	85 db                	test   %ebx,%ebx
  81003e:	74 06                	je     810046 <ipc_recv+0x4e>
			*from_env_store = 0;
  810040:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		if(perm_store != NULL)	
  810046:	85 f6                	test   %esi,%esi
  810048:	74 10                	je     81005a <ipc_recv+0x62>
			*perm_store = 0;
  81004a:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  810050:	eb 08                	jmp    81005a <ipc_recv+0x62>
		return r;
	}
	
	return thisenv->env_ipc_value;
  810052:	a1 9c b2 b3 00       	mov    0xb3b29c,%eax
  810057:	8b 40 70             	mov    0x70(%eax),%eax
}
  81005a:	83 c4 10             	add    $0x10,%esp
  81005d:	5b                   	pop    %ebx
  81005e:	5e                   	pop    %esi
  81005f:	5d                   	pop    %ebp
  810060:	c3                   	ret    

00810061 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  810061:	55                   	push   %ebp
  810062:	89 e5                	mov    %esp,%ebp
  810064:	57                   	push   %edi
  810065:	56                   	push   %esi
  810066:	53                   	push   %ebx
  810067:	83 ec 1c             	sub    $0x1c,%esp
  81006a:	8b 75 08             	mov    0x8(%ebp),%esi
  81006d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  810070:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
	int r;
	while((r = sys_ipc_try_send(to_env, val, pg?pg:(void*)UTOP, perm)) < 0){
  810073:	eb 2a                	jmp    81009f <ipc_send+0x3e>
		if (r != -E_IPC_NOT_RECV)
  810075:	83 f8 f9             	cmp    $0xfffffff9,%eax
  810078:	74 20                	je     81009a <ipc_send+0x39>
			panic("ipc_send: sys_ipc_try_send failed %e", r);
  81007a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81007e:	c7 44 24 08 04 34 81 	movl   $0x813404,0x8(%esp)
  810085:	00 
  810086:	c7 44 24 04 3e 00 00 	movl   $0x3e,0x4(%esp)
  81008d:	00 
  81008e:	c7 04 24 29 34 81 00 	movl   $0x813429,(%esp)
  810095:	e8 de ed ff ff       	call   80ee78 <_panic>
		sys_yield();
  81009a:	e8 4f f8 ff ff       	call   80f8ee <sys_yield>
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
	int r;
	while((r = sys_ipc_try_send(to_env, val, pg?pg:(void*)UTOP, perm)) < 0){
  81009f:	85 db                	test   %ebx,%ebx
  8100a1:	75 07                	jne    8100aa <ipc_send+0x49>
  8100a3:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  8100a8:	eb 02                	jmp    8100ac <ipc_send+0x4b>
  8100aa:	89 d8                	mov    %ebx,%eax
  8100ac:	8b 55 14             	mov    0x14(%ebp),%edx
  8100af:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8100b3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8100b7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8100bb:	89 34 24             	mov    %esi,(%esp)
  8100be:	e8 3d fa ff ff       	call   80fb00 <sys_ipc_try_send>
  8100c3:	85 c0                	test   %eax,%eax
  8100c5:	78 ae                	js     810075 <ipc_send+0x14>
		if (r != -E_IPC_NOT_RECV)
			panic("ipc_send: sys_ipc_try_send failed %e", r);
		sys_yield();
	}
}
  8100c7:	83 c4 1c             	add    $0x1c,%esp
  8100ca:	5b                   	pop    %ebx
  8100cb:	5e                   	pop    %esi
  8100cc:	5f                   	pop    %edi
  8100cd:	5d                   	pop    %ebp
  8100ce:	c3                   	ret    

008100cf <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8100cf:	55                   	push   %ebp
  8100d0:	89 e5                	mov    %esp,%ebp
  8100d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  8100d5:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  8100da:	89 c2                	mov    %eax,%edx
  8100dc:	c1 e2 07             	shl    $0x7,%edx
  8100df:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  8100e5:	8b 52 50             	mov    0x50(%edx),%edx
  8100e8:	39 ca                	cmp    %ecx,%edx
  8100ea:	75 0d                	jne    8100f9 <ipc_find_env+0x2a>
			return envs[i].env_id;
  8100ec:	c1 e0 07             	shl    $0x7,%eax
  8100ef:	05 08 00 c0 ee       	add    $0xeec00008,%eax
  8100f4:	8b 40 40             	mov    0x40(%eax),%eax
  8100f7:	eb 0c                	jmp    810105 <ipc_find_env+0x36>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  8100f9:	40                   	inc    %eax
  8100fa:	3d 00 04 00 00       	cmp    $0x400,%eax
  8100ff:	75 d9                	jne    8100da <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  810101:	66 b8 00 00          	mov    $0x0,%ax
}
  810105:	5d                   	pop    %ebp
  810106:	c3                   	ret    
	...

00810108 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810108:	55                   	push   %ebp
  810109:	89 e5                	mov    %esp,%ebp
  81010b:	53                   	push   %ebx
  81010c:	83 ec 14             	sub    $0x14,%esp
  81010f:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810111:	83 3d 10 b2 b3 00 00 	cmpl   $0x0,0xb3b210
  810118:	75 11                	jne    81012b <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  81011a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  810121:	e8 a9 ff ff ff       	call   8100cf <ipc_find_env>
  810126:	a3 10 b2 b3 00       	mov    %eax,0xb3b210
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  81012b:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810132:	00 
  810133:	c7 44 24 08 00 c0 b3 	movl   $0xb3c000,0x8(%esp)
  81013a:	00 
  81013b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81013f:	a1 10 b2 b3 00       	mov    0xb3b210,%eax
  810144:	89 04 24             	mov    %eax,(%esp)
  810147:	e8 15 ff ff ff       	call   810061 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  81014c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810153:	00 
  810154:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81015b:	00 
  81015c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810163:	e8 90 fe ff ff       	call   80fff8 <ipc_recv>
}
  810168:	83 c4 14             	add    $0x14,%esp
  81016b:	5b                   	pop    %ebx
  81016c:	5d                   	pop    %ebp
  81016d:	c3                   	ret    

0081016e <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81016e:	55                   	push   %ebp
  81016f:	89 e5                	mov    %esp,%ebp
  810171:	56                   	push   %esi
  810172:	53                   	push   %ebx
  810173:	83 ec 10             	sub    $0x10,%esp
  810176:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810179:	8b 45 08             	mov    0x8(%ebp),%eax
  81017c:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810181:	8b 06                	mov    (%esi),%eax
  810183:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810188:	b8 01 00 00 00       	mov    $0x1,%eax
  81018d:	e8 76 ff ff ff       	call   810108 <nsipc>
  810192:	89 c3                	mov    %eax,%ebx
  810194:	85 c0                	test   %eax,%eax
  810196:	78 23                	js     8101bb <nsipc_accept+0x4d>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  810198:	a1 10 c0 b3 00       	mov    0xb3c010,%eax
  81019d:	89 44 24 08          	mov    %eax,0x8(%esp)
  8101a1:	c7 44 24 04 00 c0 b3 	movl   $0xb3c000,0x4(%esp)
  8101a8:	00 
  8101a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101ac:	89 04 24             	mov    %eax,(%esp)
  8101af:	e8 e0 f4 ff ff       	call   80f694 <memmove>
		*addrlen = ret->ret_addrlen;
  8101b4:	a1 10 c0 b3 00       	mov    0xb3c010,%eax
  8101b9:	89 06                	mov    %eax,(%esi)
	}
	return r;
}
  8101bb:	89 d8                	mov    %ebx,%eax
  8101bd:	83 c4 10             	add    $0x10,%esp
  8101c0:	5b                   	pop    %ebx
  8101c1:	5e                   	pop    %esi
  8101c2:	5d                   	pop    %ebp
  8101c3:	c3                   	ret    

008101c4 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8101c4:	55                   	push   %ebp
  8101c5:	89 e5                	mov    %esp,%ebp
  8101c7:	53                   	push   %ebx
  8101c8:	83 ec 14             	sub    $0x14,%esp
  8101cb:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  8101ce:	8b 45 08             	mov    0x8(%ebp),%eax
  8101d1:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8101d6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8101da:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8101e1:	c7 04 24 04 c0 b3 00 	movl   $0xb3c004,(%esp)
  8101e8:	e8 a7 f4 ff ff       	call   80f694 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8101ed:	89 1d 14 c0 b3 00    	mov    %ebx,0xb3c014
	return nsipc(NSREQ_BIND);
  8101f3:	b8 02 00 00 00       	mov    $0x2,%eax
  8101f8:	e8 0b ff ff ff       	call   810108 <nsipc>
}
  8101fd:	83 c4 14             	add    $0x14,%esp
  810200:	5b                   	pop    %ebx
  810201:	5d                   	pop    %ebp
  810202:	c3                   	ret    

00810203 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810203:	55                   	push   %ebp
  810204:	89 e5                	mov    %esp,%ebp
  810206:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810209:	8b 45 08             	mov    0x8(%ebp),%eax
  81020c:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	nsipcbuf.shutdown.req_how = how;
  810211:	8b 45 0c             	mov    0xc(%ebp),%eax
  810214:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return nsipc(NSREQ_SHUTDOWN);
  810219:	b8 03 00 00 00       	mov    $0x3,%eax
  81021e:	e8 e5 fe ff ff       	call   810108 <nsipc>
}
  810223:	c9                   	leave  
  810224:	c3                   	ret    

00810225 <nsipc_close>:

int
nsipc_close(int s)
{
  810225:	55                   	push   %ebp
  810226:	89 e5                	mov    %esp,%ebp
  810228:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  81022b:	8b 45 08             	mov    0x8(%ebp),%eax
  81022e:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return nsipc(NSREQ_CLOSE);
  810233:	b8 04 00 00 00       	mov    $0x4,%eax
  810238:	e8 cb fe ff ff       	call   810108 <nsipc>
}
  81023d:	c9                   	leave  
  81023e:	c3                   	ret    

0081023f <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  81023f:	55                   	push   %ebp
  810240:	89 e5                	mov    %esp,%ebp
  810242:	53                   	push   %ebx
  810243:	83 ec 14             	sub    $0x14,%esp
  810246:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810249:	8b 45 08             	mov    0x8(%ebp),%eax
  81024c:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810251:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810255:	8b 45 0c             	mov    0xc(%ebp),%eax
  810258:	89 44 24 04          	mov    %eax,0x4(%esp)
  81025c:	c7 04 24 04 c0 b3 00 	movl   $0xb3c004,(%esp)
  810263:	e8 2c f4 ff ff       	call   80f694 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810268:	89 1d 14 c0 b3 00    	mov    %ebx,0xb3c014
	return nsipc(NSREQ_CONNECT);
  81026e:	b8 05 00 00 00       	mov    $0x5,%eax
  810273:	e8 90 fe ff ff       	call   810108 <nsipc>
}
  810278:	83 c4 14             	add    $0x14,%esp
  81027b:	5b                   	pop    %ebx
  81027c:	5d                   	pop    %ebp
  81027d:	c3                   	ret    

0081027e <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  81027e:	55                   	push   %ebp
  81027f:	89 e5                	mov    %esp,%ebp
  810281:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810284:	8b 45 08             	mov    0x8(%ebp),%eax
  810287:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	nsipcbuf.listen.req_backlog = backlog;
  81028c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81028f:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return nsipc(NSREQ_LISTEN);
  810294:	b8 06 00 00 00       	mov    $0x6,%eax
  810299:	e8 6a fe ff ff       	call   810108 <nsipc>
}
  81029e:	c9                   	leave  
  81029f:	c3                   	ret    

008102a0 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8102a0:	55                   	push   %ebp
  8102a1:	89 e5                	mov    %esp,%ebp
  8102a3:	56                   	push   %esi
  8102a4:	53                   	push   %ebx
  8102a5:	83 ec 10             	sub    $0x10,%esp
  8102a8:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8102ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8102ae:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	nsipcbuf.recv.req_len = len;
  8102b3:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	nsipcbuf.recv.req_flags = flags;
  8102b9:	8b 45 14             	mov    0x14(%ebp),%eax
  8102bc:	a3 08 c0 b3 00       	mov    %eax,0xb3c008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8102c1:	b8 07 00 00 00       	mov    $0x7,%eax
  8102c6:	e8 3d fe ff ff       	call   810108 <nsipc>
  8102cb:	89 c3                	mov    %eax,%ebx
  8102cd:	85 c0                	test   %eax,%eax
  8102cf:	78 46                	js     810317 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  8102d1:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  8102d6:	7f 04                	jg     8102dc <nsipc_recv+0x3c>
  8102d8:	39 c6                	cmp    %eax,%esi
  8102da:	7d 24                	jge    810300 <nsipc_recv+0x60>
  8102dc:	c7 44 24 0c 33 34 81 	movl   $0x813433,0xc(%esp)
  8102e3:	00 
  8102e4:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  8102eb:	00 
  8102ec:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  8102f3:	00 
  8102f4:	c7 04 24 48 34 81 00 	movl   $0x813448,(%esp)
  8102fb:	e8 78 eb ff ff       	call   80ee78 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810300:	89 44 24 08          	mov    %eax,0x8(%esp)
  810304:	c7 44 24 04 00 c0 b3 	movl   $0xb3c000,0x4(%esp)
  81030b:	00 
  81030c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81030f:	89 04 24             	mov    %eax,(%esp)
  810312:	e8 7d f3 ff ff       	call   80f694 <memmove>
	}

	return r;
}
  810317:	89 d8                	mov    %ebx,%eax
  810319:	83 c4 10             	add    $0x10,%esp
  81031c:	5b                   	pop    %ebx
  81031d:	5e                   	pop    %esi
  81031e:	5d                   	pop    %ebp
  81031f:	c3                   	ret    

00810320 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810320:	55                   	push   %ebp
  810321:	89 e5                	mov    %esp,%ebp
  810323:	53                   	push   %ebx
  810324:	83 ec 14             	sub    $0x14,%esp
  810327:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  81032a:	8b 45 08             	mov    0x8(%ebp),%eax
  81032d:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	assert(size < 1600);
  810332:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810338:	7e 24                	jle    81035e <nsipc_send+0x3e>
  81033a:	c7 44 24 0c 54 34 81 	movl   $0x813454,0xc(%esp)
  810341:	00 
  810342:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  810349:	00 
  81034a:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  810351:	00 
  810352:	c7 04 24 48 34 81 00 	movl   $0x813448,(%esp)
  810359:	e8 1a eb ff ff       	call   80ee78 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81035e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810362:	8b 45 0c             	mov    0xc(%ebp),%eax
  810365:	89 44 24 04          	mov    %eax,0x4(%esp)
  810369:	c7 04 24 0c c0 b3 00 	movl   $0xb3c00c,(%esp)
  810370:	e8 1f f3 ff ff       	call   80f694 <memmove>
	nsipcbuf.send.req_size = size;
  810375:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
	nsipcbuf.send.req_flags = flags;
  81037b:	8b 45 14             	mov    0x14(%ebp),%eax
  81037e:	a3 08 c0 b3 00       	mov    %eax,0xb3c008
	return nsipc(NSREQ_SEND);
  810383:	b8 08 00 00 00       	mov    $0x8,%eax
  810388:	e8 7b fd ff ff       	call   810108 <nsipc>
}
  81038d:	83 c4 14             	add    $0x14,%esp
  810390:	5b                   	pop    %ebx
  810391:	5d                   	pop    %ebp
  810392:	c3                   	ret    

00810393 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810393:	55                   	push   %ebp
  810394:	89 e5                	mov    %esp,%ebp
  810396:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810399:	8b 45 08             	mov    0x8(%ebp),%eax
  81039c:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	nsipcbuf.socket.req_type = type;
  8103a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8103a4:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	nsipcbuf.socket.req_protocol = protocol;
  8103a9:	8b 45 10             	mov    0x10(%ebp),%eax
  8103ac:	a3 08 c0 b3 00       	mov    %eax,0xb3c008
	return nsipc(NSREQ_SOCKET);
  8103b1:	b8 09 00 00 00       	mov    $0x9,%eax
  8103b6:	e8 4d fd ff ff       	call   810108 <nsipc>
}
  8103bb:	c9                   	leave  
  8103bc:	c3                   	ret    
  8103bd:	00 00                	add    %al,(%eax)
	...

008103c0 <free>:
	return v;
}

void
free(void *v)
{
  8103c0:	55                   	push   %ebp
  8103c1:	89 e5                	mov    %esp,%ebp
  8103c3:	53                   	push   %ebx
  8103c4:	83 ec 14             	sub    $0x14,%esp
  8103c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8103ca:	85 db                	test   %ebx,%ebx
  8103cc:	0f 84 b8 00 00 00    	je     81048a <free+0xca>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8103d2:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  8103d8:	76 08                	jbe    8103e2 <free+0x22>
  8103da:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  8103e0:	76 24                	jbe    810406 <free+0x46>
  8103e2:	c7 44 24 0c 60 34 81 	movl   $0x813460,0xc(%esp)
  8103e9:	00 
  8103ea:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  8103f1:	00 
  8103f2:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8103f9:	00 
  8103fa:	c7 04 24 90 34 81 00 	movl   $0x813490,(%esp)
  810401:	e8 72 ea ff ff       	call   80ee78 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  810406:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  81040c:	eb 4a                	jmp    810458 <free+0x98>
		sys_page_unmap(0, c);
  81040e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810412:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810419:	e8 96 f5 ff ff       	call   80f9b4 <sys_page_unmap>
		c += PGSIZE;
  81041e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810424:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  81042a:	76 08                	jbe    810434 <free+0x74>
  81042c:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  810432:	76 24                	jbe    810458 <free+0x98>
  810434:	c7 44 24 0c 9d 34 81 	movl   $0x81349d,0xc(%esp)
  81043b:	00 
  81043c:	c7 44 24 08 b7 21 81 	movl   $0x8121b7,0x8(%esp)
  810443:	00 
  810444:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  81044b:	00 
  81044c:	c7 04 24 90 34 81 00 	movl   $0x813490,(%esp)
  810453:	e8 20 ea ff ff       	call   80ee78 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810458:	89 d8                	mov    %ebx,%eax
  81045a:	c1 e8 0c             	shr    $0xc,%eax
  81045d:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810464:	f6 c4 02             	test   $0x2,%ah
  810467:	75 a5                	jne    81040e <free+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810469:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  81046f:	48                   	dec    %eax
  810470:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810476:	85 c0                	test   %eax,%eax
  810478:	75 10                	jne    81048a <free+0xca>
		sys_page_unmap(0, c);
  81047a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81047e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810485:	e8 2a f5 ff ff       	call   80f9b4 <sys_page_unmap>
}
  81048a:	83 c4 14             	add    $0x14,%esp
  81048d:	5b                   	pop    %ebx
  81048e:	5d                   	pop    %ebp
  81048f:	c3                   	ret    

00810490 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  810490:	55                   	push   %ebp
  810491:	89 e5                	mov    %esp,%ebp
  810493:	57                   	push   %edi
  810494:	56                   	push   %esi
  810495:	53                   	push   %ebx
  810496:	83 ec 2c             	sub    $0x2c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  810499:	83 3d 14 b2 b3 00 00 	cmpl   $0x0,0xb3b214
  8104a0:	75 0a                	jne    8104ac <malloc+0x1c>
		mptr = mbegin;
  8104a2:	c7 05 14 b2 b3 00 00 	movl   $0x8000000,0xb3b214
  8104a9:	00 00 08 

	n = ROUNDUP(n, 4);
  8104ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8104af:	83 c0 03             	add    $0x3,%eax
  8104b2:	83 e0 fc             	and    $0xfffffffc,%eax
  8104b5:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  8104b8:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8104bd:	0f 87 6a 01 00 00    	ja     81062d <malloc+0x19d>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  8104c3:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
  8104c8:	89 c2                	mov    %eax,%edx
  8104ca:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8104cf:	74 4d                	je     81051e <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8104d1:	89 c3                	mov    %eax,%ebx
  8104d3:	c1 eb 0c             	shr    $0xc,%ebx
  8104d6:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8104d9:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  8104dd:	c1 e9 0c             	shr    $0xc,%ecx
  8104e0:	39 cb                	cmp    %ecx,%ebx
  8104e2:	75 1e                	jne    810502 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8104e4:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  8104ea:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  8104f0:	ff 42 fc             	incl   -0x4(%edx)
			v = mptr;
			mptr += n;
  8104f3:	89 f2                	mov    %esi,%edx
  8104f5:	01 c2                	add    %eax,%edx
  8104f7:	89 15 14 b2 b3 00    	mov    %edx,0xb3b214
			return v;
  8104fd:	e9 30 01 00 00       	jmp    810632 <malloc+0x1a2>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  810502:	89 04 24             	mov    %eax,(%esp)
  810505:	e8 b6 fe ff ff       	call   8103c0 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  81050a:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
  81050f:	05 00 10 00 00       	add    $0x1000,%eax
  810514:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810519:	a3 14 b2 b3 00       	mov    %eax,0xb3b214
  81051e:	8b 1d 14 b2 b3 00    	mov    0xb3b214,%ebx
	return 1;
}

void*
malloc(size_t n)
{
  810524:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81052b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  81052e:	83 c6 04             	add    $0x4,%esi
  810531:	eb 05                	jmp    810538 <malloc+0xa8>
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  810533:	bb 00 00 00 08       	mov    $0x8000000,%ebx
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810538:	89 df                	mov    %ebx,%edi
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81053a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;
  81053d:	89 d8                	mov    %ebx,%eax
			return 0;
	return 1;
}

void*
malloc(size_t n)
  81053f:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
  810542:	eb 2e                	jmp    810572 <malloc+0xe2>
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  810544:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810549:	77 30                	ja     81057b <malloc+0xeb>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  81054b:	89 c2                	mov    %eax,%edx
  81054d:	c1 ea 16             	shr    $0x16,%edx
  810550:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810557:	f6 c2 01             	test   $0x1,%dl
  81055a:	74 11                	je     81056d <malloc+0xdd>
  81055c:	89 c2                	mov    %eax,%edx
  81055e:	c1 ea 0c             	shr    $0xc,%edx
  810561:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810568:	f6 c2 01             	test   $0x1,%dl
  81056b:	75 0e                	jne    81057b <malloc+0xeb>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81056d:	05 00 10 00 00       	add    $0x1000,%eax
  810572:	39 c1                	cmp    %eax,%ecx
  810574:	77 ce                	ja     810544 <malloc+0xb4>
  810576:	e9 84 00 00 00       	jmp    8105ff <malloc+0x16f>
  81057b:	81 c3 00 10 00 00    	add    $0x1000,%ebx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  810581:	81 fb 00 00 00 10    	cmp    $0x10000000,%ebx
  810587:	75 af                	jne    810538 <malloc+0xa8>
			mptr = mbegin;
			if (++nwrap == 2)
  810589:	ff 4d dc             	decl   -0x24(%ebp)
  81058c:	75 a5                	jne    810533 <malloc+0xa3>
  81058e:	c7 05 14 b2 b3 00 00 	movl   $0x8000000,0xb3b214
  810595:	00 00 08 
				return 0;	/* out of address space */
  810598:	b8 00 00 00 00       	mov    $0x0,%eax
  81059d:	e9 90 00 00 00       	jmp    810632 <malloc+0x1a2>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8105a2:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  8105a8:	39 fe                	cmp    %edi,%esi
  8105aa:	19 c0                	sbb    %eax,%eax
  8105ac:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8105b1:	83 c8 07             	or     $0x7,%eax
  8105b4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8105b8:	03 15 14 b2 b3 00    	add    0xb3b214,%edx
  8105be:	89 54 24 04          	mov    %edx,0x4(%esp)
  8105c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105c9:	e8 3f f3 ff ff       	call   80f90d <sys_page_alloc>
  8105ce:	85 c0                	test   %eax,%eax
  8105d0:	78 22                	js     8105f4 <malloc+0x164>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8105d2:	89 f3                	mov    %esi,%ebx
  8105d4:	eb 37                	jmp    81060d <malloc+0x17d>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  8105d6:	89 d8                	mov    %ebx,%eax
  8105d8:	03 05 14 b2 b3 00    	add    0xb3b214,%eax
  8105de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105e9:	e8 c6 f3 ff ff       	call   80f9b4 <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8105ee:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  8105f4:	85 db                	test   %ebx,%ebx
  8105f6:	79 de                	jns    8105d6 <malloc+0x146>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  8105f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8105fd:	eb 33                	jmp    810632 <malloc+0x1a2>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8105ff:	89 3d 14 b2 b3 00    	mov    %edi,0xb3b214
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810605:	bb 00 00 00 00       	mov    $0x0,%ebx
  81060a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  81060d:	89 da                	mov    %ebx,%edx
  81060f:	39 fb                	cmp    %edi,%ebx
  810611:	72 8f                	jb     8105a2 <malloc+0x112>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  810613:	a1 14 b2 b3 00       	mov    0xb3b214,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810618:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  81061f:	00 
	v = mptr;
	mptr += n;
  810620:	8b 55 e0             	mov    -0x20(%ebp),%edx
  810623:	01 c2                	add    %eax,%edx
  810625:	89 15 14 b2 b3 00    	mov    %edx,0xb3b214
	return v;
  81062b:	eb 05                	jmp    810632 <malloc+0x1a2>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  81062d:	b8 00 00 00 00       	mov    $0x0,%eax
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  810632:	83 c4 2c             	add    $0x2c,%esp
  810635:	5b                   	pop    %ebx
  810636:	5e                   	pop    %esi
  810637:	5f                   	pop    %edi
  810638:	5d                   	pop    %ebp
  810639:	c3                   	ret    
	...

0081063c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  81063c:	55                   	push   %ebp
  81063d:	89 e5                	mov    %esp,%ebp
  81063f:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  810642:	83 3d 00 d0 b3 00 00 	cmpl   $0x0,0xb3d000
  810649:	75 58                	jne    8106a3 <set_pgfault_handler+0x67>
		// First time through!
		// LAB 4: Your code here.	
		//panic("set_pgfault_handler not implemented");
		
		if (sys_page_alloc(thisenv->env_id,(void *) (UXSTACKTOP - PGSIZE),(PTE_W|PTE_U|PTE_P)) != 0){
  81064b:	a1 9c b2 b3 00       	mov    0xb3b29c,%eax
  810650:	8b 40 48             	mov    0x48(%eax),%eax
  810653:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  81065a:	00 
  81065b:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  810662:	ee 
  810663:	89 04 24             	mov    %eax,(%esp)
  810666:	e8 a2 f2 ff ff       	call   80f90d <sys_page_alloc>
  81066b:	85 c0                	test   %eax,%eax
  81066d:	74 1c                	je     81068b <set_pgfault_handler+0x4f>
			panic("set_pg_fault_handler");
  81066f:	c7 44 24 08 b5 34 81 	movl   $0x8134b5,0x8(%esp)
  810676:	00 
  810677:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  81067e:	00 
  81067f:	c7 04 24 ca 34 81 00 	movl   $0x8134ca,(%esp)
  810686:	e8 ed e7 ff ff       	call   80ee78 <_panic>
		}
		sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall);
  81068b:	a1 9c b2 b3 00       	mov    0xb3b29c,%eax
  810690:	8b 40 48             	mov    0x48(%eax),%eax
  810693:	c7 44 24 04 b0 06 81 	movl   $0x8106b0,0x4(%esp)
  81069a:	00 
  81069b:	89 04 24             	mov    %eax,(%esp)
  81069e:	e8 0a f4 ff ff       	call   80faad <sys_env_set_pgfault_upcall>
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8106a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8106a6:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
}
  8106ab:	c9                   	leave  
  8106ac:	c3                   	ret    
  8106ad:	00 00                	add    %al,(%eax)
	...

008106b0 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8106b0:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8106b1:	a1 00 d0 b3 00       	mov    0xb3d000,%eax
	call *%eax
  8106b6:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8106b8:	83 c4 04             	add    $0x4,%esp
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	
	// Save trap-time eip in eax
	movl 0x28(%esp), %eax
  8106bb:	8b 44 24 28          	mov    0x28(%esp),%eax

	// Save our current stack
	movl %esp, %ebp
  8106bf:	89 e5                	mov    %esp,%ebp

	// Switch to trap-time stack
	movl 0x30(%esp), %esp
  8106c1:	8b 64 24 30          	mov    0x30(%esp),%esp

	// Push trap-time eip to the trap-time stack
	pushl %eax
  8106c5:	50                   	push   %eax

	// We now have to update the trap-time esp with its new value
	movl %esp, 0x30(%ebp)
  8106c6:	89 65 30             	mov    %esp,0x30(%ebp)

	// Go back to our exception stack
	movl %ebp, %esp
  8106c9:	89 ec                	mov    %ebp,%esp
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	
	// Pop fault_va and err, both can be ignored
	popl %eax
  8106cb:	58                   	pop    %eax
	popl %eax
  8106cc:	58                   	pop    %eax

	// Pop all registers back
	popal
  8106cd:	61                   	popa   
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	// Skip %eip
	addl $0x4, %esp
  8106ce:	83 c4 04             	add    $0x4,%esp

	// Pop eflags back
	popfl
  8106d1:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	
	popl %esp
  8106d2:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.

	ret
  8106d3:	c3                   	ret    

008106d4 <__udivdi3>:
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  8106d4:	55                   	push   %ebp
  8106d5:	57                   	push   %edi
  8106d6:	56                   	push   %esi
  8106d7:	83 ec 10             	sub    $0x10,%esp
  8106da:	8b 74 24 20          	mov    0x20(%esp),%esi
  8106de:	8b 4c 24 28          	mov    0x28(%esp),%ecx
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
  8106e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8106e6:	8b 7c 24 24          	mov    0x24(%esp),%edi
  const DWunion dd = {.ll = d};
  8106ea:	89 cd                	mov    %ecx,%ebp
  8106ec:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  d1 = dd.s.high;
  n0 = nn.s.low;
  n1 = nn.s.high;

#if !UDIV_NEEDS_NORMALIZATION
  if (d1 == 0)
  8106f0:	85 c0                	test   %eax,%eax
  8106f2:	75 2c                	jne    810720 <__udivdi3+0x4c>
    {
      if (d0 > n1)
  8106f4:	39 f9                	cmp    %edi,%ecx
  8106f6:	77 68                	ja     810760 <__udivdi3+0x8c>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
  8106f8:	85 c9                	test   %ecx,%ecx
  8106fa:	75 0b                	jne    810707 <__udivdi3+0x33>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  8106fc:	b8 01 00 00 00       	mov    $0x1,%eax
  810701:	31 d2                	xor    %edx,%edx
  810703:	f7 f1                	div    %ecx
  810705:	89 c1                	mov    %eax,%ecx

	  udiv_qrnnd (q1, n1, 0, n1, d0);
  810707:	31 d2                	xor    %edx,%edx
  810709:	89 f8                	mov    %edi,%eax
  81070b:	f7 f1                	div    %ecx
  81070d:	89 c7                	mov    %eax,%edi
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  81070f:	89 f0                	mov    %esi,%eax
  810711:	f7 f1                	div    %ecx
  810713:	89 c6                	mov    %eax,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  810715:	89 f0                	mov    %esi,%eax
  810717:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  810719:	83 c4 10             	add    $0x10,%esp
  81071c:	5e                   	pop    %esi
  81071d:	5f                   	pop    %edi
  81071e:	5d                   	pop    %ebp
  81071f:	c3                   	ret    
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  810720:	39 f8                	cmp    %edi,%eax
  810722:	77 2c                	ja     810750 <__udivdi3+0x7c>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
  810724:	0f bd f0             	bsr    %eax,%esi
	  if (bm == 0)
  810727:	83 f6 1f             	xor    $0x1f,%esi
  81072a:	75 4c                	jne    810778 <__udivdi3+0xa4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  81072c:	39 f8                	cmp    %edi,%eax
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  81072e:	bf 00 00 00 00       	mov    $0x0,%edi

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  810733:	72 0a                	jb     81073f <__udivdi3+0x6b>
  810735:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
  810739:	0f 87 ad 00 00 00    	ja     8107ec <__udivdi3+0x118>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  81073f:	be 01 00 00 00       	mov    $0x1,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  810744:	89 f0                	mov    %esi,%eax
  810746:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  810748:	83 c4 10             	add    $0x10,%esp
  81074b:	5e                   	pop    %esi
  81074c:	5f                   	pop    %edi
  81074d:	5d                   	pop    %ebp
  81074e:	c3                   	ret    
  81074f:	90                   	nop
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  810750:	31 ff                	xor    %edi,%edi
  810752:	31 f6                	xor    %esi,%esi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  810754:	89 f0                	mov    %esi,%eax
  810756:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  810758:	83 c4 10             	add    $0x10,%esp
  81075b:	5e                   	pop    %esi
  81075c:	5f                   	pop    %edi
  81075d:	5d                   	pop    %ebp
  81075e:	c3                   	ret    
  81075f:	90                   	nop
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
  810760:	89 fa                	mov    %edi,%edx
  810762:	89 f0                	mov    %esi,%eax
  810764:	f7 f1                	div    %ecx
  810766:	89 c6                	mov    %eax,%esi
  810768:	31 ff                	xor    %edi,%edi
		}
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  81076a:	89 f0                	mov    %esi,%eax
  81076c:	89 fa                	mov    %edi,%edx
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  81076e:	83 c4 10             	add    $0x10,%esp
  810771:	5e                   	pop    %esi
  810772:	5f                   	pop    %edi
  810773:	5d                   	pop    %ebp
  810774:	c3                   	ret    
  810775:	8d 76 00             	lea    0x0(%esi),%esi
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
  810778:	89 f1                	mov    %esi,%ecx
  81077a:	d3 e0                	shl    %cl,%eax
  81077c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
  810780:	b8 20 00 00 00       	mov    $0x20,%eax
  810785:	29 f0                	sub    %esi,%eax

	      d1 = (d1 << bm) | (d0 >> b);
  810787:	89 ea                	mov    %ebp,%edx
  810789:	88 c1                	mov    %al,%cl
  81078b:	d3 ea                	shr    %cl,%edx
  81078d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  810791:	09 ca                	or     %ecx,%edx
  810793:	89 54 24 08          	mov    %edx,0x8(%esp)
	      d0 = d0 << bm;
  810797:	89 f1                	mov    %esi,%ecx
  810799:	d3 e5                	shl    %cl,%ebp
  81079b:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
	      n2 = n1 >> b;
  81079f:	89 fd                	mov    %edi,%ebp
  8107a1:	88 c1                	mov    %al,%cl
  8107a3:	d3 ed                	shr    %cl,%ebp
	      n1 = (n1 << bm) | (n0 >> b);
  8107a5:	89 fa                	mov    %edi,%edx
  8107a7:	89 f1                	mov    %esi,%ecx
  8107a9:	d3 e2                	shl    %cl,%edx
  8107ab:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8107af:	88 c1                	mov    %al,%cl
  8107b1:	d3 ef                	shr    %cl,%edi
  8107b3:	09 d7                	or     %edx,%edi
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
  8107b5:	89 f8                	mov    %edi,%eax
  8107b7:	89 ea                	mov    %ebp,%edx
  8107b9:	f7 74 24 08          	divl   0x8(%esp)
  8107bd:	89 d1                	mov    %edx,%ecx
  8107bf:	89 c7                	mov    %eax,%edi
	      umul_ppmm (m1, m0, q0, d0);
  8107c1:	f7 64 24 0c          	mull   0xc(%esp)

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  8107c5:	39 d1                	cmp    %edx,%ecx
  8107c7:	72 17                	jb     8107e0 <__udivdi3+0x10c>
  8107c9:	74 09                	je     8107d4 <__udivdi3+0x100>
  8107cb:	89 fe                	mov    %edi,%esi
  8107cd:	31 ff                	xor    %edi,%edi
  8107cf:	e9 41 ff ff ff       	jmp    810715 <__udivdi3+0x41>

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
  8107d4:	8b 54 24 04          	mov    0x4(%esp),%edx
  8107d8:	89 f1                	mov    %esi,%ecx
  8107da:	d3 e2                	shl    %cl,%edx

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  8107dc:	39 c2                	cmp    %eax,%edx
  8107de:	73 eb                	jae    8107cb <__udivdi3+0xf7>
		{
		  q0--;
  8107e0:	8d 77 ff             	lea    -0x1(%edi),%esi
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  8107e3:	31 ff                	xor    %edi,%edi
  8107e5:	e9 2b ff ff ff       	jmp    810715 <__udivdi3+0x41>
  8107ea:	66 90                	xchg   %ax,%ax

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  8107ec:	31 f6                	xor    %esi,%esi
  8107ee:	e9 22 ff ff ff       	jmp    810715 <__udivdi3+0x41>
	...

008107f4 <__umoddi3>:
#endif

#ifdef L_umoddi3
UDWtype
__umoddi3 (UDWtype u, UDWtype v)
{
  8107f4:	55                   	push   %ebp
  8107f5:	57                   	push   %edi
  8107f6:	56                   	push   %esi
  8107f7:	83 ec 20             	sub    $0x20,%esp
  8107fa:	8b 44 24 30          	mov    0x30(%esp),%eax
  8107fe:	8b 4c 24 38          	mov    0x38(%esp),%ecx
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
  810802:	89 44 24 14          	mov    %eax,0x14(%esp)
  810806:	8b 74 24 34          	mov    0x34(%esp),%esi
  const DWunion dd = {.ll = d};
  81080a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  81080e:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
  d1 = dd.s.high;
  n0 = nn.s.low;
  810812:	89 c7                	mov    %eax,%edi
  n1 = nn.s.high;
  810814:	89 f2                	mov    %esi,%edx

#if !UDIV_NEEDS_NORMALIZATION
  if (d1 == 0)
  810816:	85 ed                	test   %ebp,%ebp
  810818:	75 16                	jne    810830 <__umoddi3+0x3c>
    {
      if (d0 > n1)
  81081a:	39 f1                	cmp    %esi,%ecx
  81081c:	0f 86 a6 00 00 00    	jbe    8108c8 <__umoddi3+0xd4>

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  udiv_qrnnd (q1, n1, 0, n1, d0);
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  810822:	f7 f1                	div    %ecx

      if (rp != 0)
	{
	  rr.s.low = n0;
	  rr.s.high = 0;
	  *rp = rr.ll;
  810824:	89 d0                	mov    %edx,%eax
  810826:	31 d2                	xor    %edx,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  810828:	83 c4 20             	add    $0x20,%esp
  81082b:	5e                   	pop    %esi
  81082c:	5f                   	pop    %edi
  81082d:	5d                   	pop    %ebp
  81082e:	c3                   	ret    
  81082f:	90                   	nop
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
  810830:	39 f5                	cmp    %esi,%ebp
  810832:	0f 87 ac 00 00 00    	ja     8108e4 <__umoddi3+0xf0>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
  810838:	0f bd c5             	bsr    %ebp,%eax
	  if (bm == 0)
  81083b:	83 f0 1f             	xor    $0x1f,%eax
  81083e:	89 44 24 10          	mov    %eax,0x10(%esp)
  810842:	0f 84 a8 00 00 00    	je     8108f0 <__umoddi3+0xfc>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
  810848:	8a 4c 24 10          	mov    0x10(%esp),%cl
  81084c:	d3 e5                	shl    %cl,%ebp
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
  81084e:	bf 20 00 00 00       	mov    $0x20,%edi
  810853:	2b 7c 24 10          	sub    0x10(%esp),%edi

	      d1 = (d1 << bm) | (d0 >> b);
  810857:	8b 44 24 0c          	mov    0xc(%esp),%eax
  81085b:	89 f9                	mov    %edi,%ecx
  81085d:	d3 e8                	shr    %cl,%eax
  81085f:	09 e8                	or     %ebp,%eax
  810861:	89 44 24 18          	mov    %eax,0x18(%esp)
	      d0 = d0 << bm;
  810865:	8b 44 24 0c          	mov    0xc(%esp),%eax
  810869:	8a 4c 24 10          	mov    0x10(%esp),%cl
  81086d:	d3 e0                	shl    %cl,%eax
  81086f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
  810873:	89 f2                	mov    %esi,%edx
  810875:	d3 e2                	shl    %cl,%edx
	      n0 = n0 << bm;
  810877:	8b 44 24 14          	mov    0x14(%esp),%eax
  81087b:	d3 e0                	shl    %cl,%eax
  81087d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
  810881:	8b 44 24 14          	mov    0x14(%esp),%eax
  810885:	89 f9                	mov    %edi,%ecx
  810887:	d3 e8                	shr    %cl,%eax
  810889:	09 d0                	or     %edx,%eax

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
  81088b:	d3 ee                	shr    %cl,%esi
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
  81088d:	89 f2                	mov    %esi,%edx
  81088f:	f7 74 24 18          	divl   0x18(%esp)
  810893:	89 d6                	mov    %edx,%esi
	      umul_ppmm (m1, m0, q0, d0);
  810895:	f7 64 24 0c          	mull   0xc(%esp)
  810899:	89 c5                	mov    %eax,%ebp
  81089b:	89 d1                	mov    %edx,%ecx

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  81089d:	39 d6                	cmp    %edx,%esi
  81089f:	72 67                	jb     810908 <__umoddi3+0x114>
  8108a1:	74 75                	je     810918 <__umoddi3+0x124>
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
  8108a3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  8108a7:	29 e8                	sub    %ebp,%eax
  8108a9:	19 ce                	sbb    %ecx,%esi
		  rr.s.low = (n1 << b) | (n0 >> bm);
  8108ab:	8a 4c 24 10          	mov    0x10(%esp),%cl
  8108af:	d3 e8                	shr    %cl,%eax
  8108b1:	89 f2                	mov    %esi,%edx
  8108b3:	89 f9                	mov    %edi,%ecx
  8108b5:	d3 e2                	shl    %cl,%edx
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
  8108b7:	09 d0                	or     %edx,%eax
  8108b9:	89 f2                	mov    %esi,%edx
  8108bb:	8a 4c 24 10          	mov    0x10(%esp),%cl
  8108bf:	d3 ea                	shr    %cl,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  8108c1:	83 c4 20             	add    $0x20,%esp
  8108c4:	5e                   	pop    %esi
  8108c5:	5f                   	pop    %edi
  8108c6:	5d                   	pop    %ebp
  8108c7:	c3                   	ret    
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
  8108c8:	85 c9                	test   %ecx,%ecx
  8108ca:	75 0b                	jne    8108d7 <__umoddi3+0xe3>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  8108cc:	b8 01 00 00 00       	mov    $0x1,%eax
  8108d1:	31 d2                	xor    %edx,%edx
  8108d3:	f7 f1                	div    %ecx
  8108d5:	89 c1                	mov    %eax,%ecx

	  udiv_qrnnd (q1, n1, 0, n1, d0);
  8108d7:	89 f0                	mov    %esi,%eax
  8108d9:	31 d2                	xor    %edx,%edx
  8108db:	f7 f1                	div    %ecx
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  8108dd:	89 f8                	mov    %edi,%eax
  8108df:	e9 3e ff ff ff       	jmp    810822 <__umoddi3+0x2e>
	  /* Remainder in n1n0.  */
	  if (rp != 0)
	    {
	      rr.s.low = n0;
	      rr.s.high = n1;
	      *rp = rr.ll;
  8108e4:	89 f2                	mov    %esi,%edx
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  8108e6:	83 c4 20             	add    $0x20,%esp
  8108e9:	5e                   	pop    %esi
  8108ea:	5f                   	pop    %edi
  8108eb:	5d                   	pop    %ebp
  8108ec:	c3                   	ret    
  8108ed:	8d 76 00             	lea    0x0(%esi),%esi

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
  8108f0:	39 f5                	cmp    %esi,%ebp
  8108f2:	72 04                	jb     8108f8 <__umoddi3+0x104>
  8108f4:	39 f9                	cmp    %edi,%ecx
  8108f6:	77 06                	ja     8108fe <__umoddi3+0x10a>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  8108f8:	89 f2                	mov    %esi,%edx
  8108fa:	29 cf                	sub    %ecx,%edi
  8108fc:	19 ea                	sbb    %ebp,%edx

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
  8108fe:	89 f8                	mov    %edi,%eax
  UDWtype w;

  (void) __udivmoddi4 (u, v, &w);

  return w;
}
  810900:	83 c4 20             	add    $0x20,%esp
  810903:	5e                   	pop    %esi
  810904:	5f                   	pop    %edi
  810905:	5d                   	pop    %ebp
  810906:	c3                   	ret    
  810907:	90                   	nop
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  810908:	89 d1                	mov    %edx,%ecx
  81090a:	89 c5                	mov    %eax,%ebp
  81090c:	2b 6c 24 0c          	sub    0xc(%esp),%ebp
  810910:	1b 4c 24 18          	sbb    0x18(%esp),%ecx
  810914:	eb 8d                	jmp    8108a3 <__umoddi3+0xaf>
  810916:	66 90                	xchg   %ax,%ax
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  810918:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
  81091c:	72 ea                	jb     810908 <__umoddi3+0x114>
  81091e:	89 f1                	mov    %esi,%ecx
  810920:	eb 81                	jmp    8108a3 <__umoddi3+0xaf>
